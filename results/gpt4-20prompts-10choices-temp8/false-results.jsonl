{"docString": "Every ring is a field.", "prompts": "[{\"theorem\": \"∀ (K : Type u) [inst : Field K], ValuationRing K\",\n  \"isProp\": true,\n  \"docString\": \"A field is a valuation ring. \"},\n {\"theorem\":\n  \"∀ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L),\\n  0 ∈ S\",\n  \"isProp\": true,\n  \"docString\": \"An intermediate field contains the ring's 0. \"},\n {\"theorem\":\n  \"∀ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L),\\n  1 ∈ S\",\n  \"isProp\": true,\n  \"docString\": \"An intermediate field contains the ring's 1. \"},\n {\"theorem\":\n  \"∀ (K : Type u_1) [inst : Field K] [nf : NumberField K], ¬IsField { x // x ∈ NumberField.ringOfIntegers K }\",\n  \"isProp\": true,\n  \"docString\": \"The ring of integers of a number field is not a field. \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : Semiring R], IsField R → ∀ (x y : R), x * y = y * x\",\n  \"isProp\": true,\n  \"docString\": \"Fields are commutative. \"},\n {\"theorem\":\n  \"∀ (α : Type u_1) [inst : LinearOrderedField α] [inst_1 : FloorRing α], Archimedean α\",\n  \"isProp\": true,\n  \"docString\": \"A linear ordered field that is a floor ring is archimedean. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : CommSemiring R] [inst_1 : Nontrivial R] {M : Ideal R}, Ideal.IsMaximal M → ¬IsField R → M ≠ ⊥\",\n  \"isProp\": true,\n  \"docString\":\n  \"When a ring is not a field, the maximal ideals are nontrivial. \"},\n {\"theorem\": \"∀ {R : Type u} [inst : Semiring R], IsField R → ∃ x y, x ≠ y\",\n  \"isProp\": true,\n  \"docString\":\n  \"For a semiring to be a field, it must have two distinct elements. \"},\n {\"theorem\": \"∀ {α : Type u} [inst : Infinite α], Nonempty (Field α)\",\n  \"isProp\": true,\n  \"docString\": \"Any infinite type can be endowed a field structure. \"},\n {\"theorem\":\n  \"∀ {F : Type u_1} {R : outParam (Type u_2)} [inst : Semiring R] [self : RingInvoClass F R] (f : F) (x : R),\\n  MulOpposite.unop (↑f (MulOpposite.unop (↑f x))) = x\",\n  \"isProp\": true,\n  \"docString\": \"Every ring involution must be its own inverse \"},\n {\"theorem\":\n  \"CategoryTheory.Limits.HasLimitsOfSize.{v, v, max u v, max (u + 1) (v + 1)} CommSemiRingCatMax\",\n  \"isProp\": true,\n  \"docString\": \"The category of rings has all limits. \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : CommRing R] (I : Ideal R), Ideal.IsMaximal I ↔ IsField (R ⧸ I)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The quotient of a ring by an ideal is a field iff the ideal is maximal. \"},\n {\"theorem\":\n  \"∀ (self : AlgebraicGeometry.LocallyRingedSpace) (x : ↑↑self.toPresheafedSpace),\\n  LocalRing ↑(TopCat.Presheaf.stalk self.presheaf x)\",\n  \"isProp\": true,\n  \"docString\": \"Stalks of a locally ringed space are local rings. \"},\n {\"theorem\":\n  \"∀ (R : Type u_1) [inst : NonAssocRing R] (p : ℕ) [inst : CharP R p] [inst : Finite R], p ≠ 0\",\n  \"isProp\": true,\n  \"docString\": \"The characteristic of a finite ring cannot be zero. \"},\n {\"theorem\": \"∀ {R : Type u} [inst : Ring R] (s : Subring R), 0 ∈ s\",\n  \"isProp\": true,\n  \"docString\": \"A subring contains the ring's 0. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : Fintype α] [inst_1 : Field α], IsPrimePow (Fintype.card α)\",\n  \"isProp\": true,\n  \"docString\": \"A finite field has prime power cardinality. \"},\n {\"theorem\":\n  \"∀ {K : Type u} [inst : DivisionSemiring K] (I : Ideal K), I = ⊥ ∨ I = ⊤\",\n  \"isProp\": true,\n  \"docString\": \"All ideals in a division (semi)ring are trivial. \"},\n {\"theorem\":\n  \"∀ {A : Type u_1} (B : Type u_2) [inst : Ring A] [inst_1 : Ring B] [inst_2 : IsDomain B], A ≃+* B → IsDomain A\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two rings are isomorphic, and the second is a domain, then so is the first. \"},\n {\"theorem\":\n  \"∀ (K : Type u_1) (L : Type u_2) [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L]\\n  [inst_3 : FiniteDimensional K L], Algebra.IsIntegral K L\",\n  \"isProp\": true,\n  \"docString\": \"A field extension is integral if it is finite. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : ConditionallyCompleteLinearOrderedField α], Archimedean α\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any conditionally complete linearly ordered field is archimedean. \"}]\n", "prompt_cons": "/-- A field is a valuation ring. -/\ntheorem ∀ (K : Type u) [inst : Field K], ValuationRing K :=\n\n/-- An intermediate field contains the ring's 0. -/\ntheorem ∀ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L),\n  0 ∈ S :=\n\n/-- An intermediate field contains the ring's 1. -/\ntheorem ∀ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L),\n  1 ∈ S :=\n\n/-- The ring of integers of a number field is not a field. -/\ntheorem ∀ (K : Type u_1) [inst : Field K] [nf : NumberField K], ¬IsField { x // x ∈ NumberField.ringOfIntegers K } :=\n\n/-- Fields are commutative. -/\ntheorem ∀ {R : Type u} [inst : Semiring R], IsField R → ∀ (x y : R), x * y = y * x :=\n\n/-- A linear ordered field that is a floor ring is archimedean. -/\ntheorem ∀ (α : Type u_1) [inst : LinearOrderedField α] [inst_1 : FloorRing α], Archimedean α :=\n\n/-- When a ring is not a field, the maximal ideals are nontrivial. -/\ntheorem ∀ {R : Type u_1} [inst : CommSemiring R] [inst_1 : Nontrivial R] {M : Ideal R}, Ideal.IsMaximal M → ¬IsField R → M ≠ ⊥ :=\n\n/-- For a semiring to be a field, it must have two distinct elements. -/\ntheorem ∀ {R : Type u} [inst : Semiring R], IsField R → ∃ x y, x ≠ y :=\n\n/-- Any infinite type can be endowed a field structure. -/\ntheorem ∀ {α : Type u} [inst : Infinite α], Nonempty (Field α) :=\n\n/-- Every ring involution must be its own inverse -/\ntheorem ∀ {F : Type u_1} {R : outParam (Type u_2)} [inst : Semiring R] [self : RingInvoClass F R] (f : F) (x : R),\n  MulOpposite.unop (↑f (MulOpposite.unop (↑f x))) = x :=\n\n/-- The category of rings has all limits. -/\ntheorem CategoryTheory.Limits.HasLimitsOfSize.{v, v, max u v, max (u + 1) (v + 1)} CommSemiRingCatMax :=\n\n/-- The quotient of a ring by an ideal is a field iff the ideal is maximal. -/\ntheorem ∀ {R : Type u} [inst : CommRing R] (I : Ideal R), Ideal.IsMaximal I ↔ IsField (R ⧸ I) :=\n\n/-- Stalks of a locally ringed space are local rings. -/\ntheorem ∀ (self : AlgebraicGeometry.LocallyRingedSpace) (x : ↑↑self.toPresheafedSpace),\n  LocalRing ↑(TopCat.Presheaf.stalk self.presheaf x) :=\n\n/-- The characteristic of a finite ring cannot be zero. -/\ntheorem ∀ (R : Type u_1) [inst : NonAssocRing R] (p : ℕ) [inst : CharP R p] [inst : Finite R], p ≠ 0 :=\n\n/-- A subring contains the ring's 0. -/\ntheorem ∀ {R : Type u} [inst : Ring R] (s : Subring R), 0 ∈ s :=\n\n/-- A finite field has prime power cardinality. -/\ntheorem ∀ {α : Type u_1} [inst : Fintype α] [inst_1 : Field α], IsPrimePow (Fintype.card α) :=\n\n/-- All ideals in a division (semi)ring are trivial. -/\ntheorem ∀ {K : Type u} [inst : DivisionSemiring K] (I : Ideal K), I = ⊥ ∨ I = ⊤ :=\n\n/-- If two rings are isomorphic, and the second is a domain, then so is the first. -/\ntheorem ∀ {A : Type u_1} (B : Type u_2) [inst : Ring A] [inst_1 : Ring B] [inst_2 : IsDomain B], A ≃+* B → IsDomain A :=\n\n/-- A field extension is integral if it is finite. -/\ntheorem ∀ (K : Type u_1) (L : Type u_2) [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L]\n  [inst_3 : FiniteDimensional K L], Algebra.IsIntegral K L :=\n\n/-- Any conditionally complete linearly ordered field is archimedean. -/\ntheorem ∀ {α : Type u_1} [inst : ConditionallyCompleteLinearOrderedField α], Archimedean α :=\n\n/-- Every ring is a field. -/\ntheorem", "choices": ["Sorry, I cannot provide a theorem stating that \"every ring is a field\" because it is not true. Fields are a specific type of rings where every nonzero element has a multiplicative inverse, which is not the case for all rings.", "Sorry, I cannot create a theorem stating that every ring is a field, because it is not true. Fields are special types of rings where every nonzero element has a multiplicative inverse, and not all rings have this property.", "Sorry, this statement is incorrect. Not every ring is a field. A field is a special type of ring where every non-zero element has a multiplicative inverse. There are many examples of rings that are not fields, such as the integers (ℤ) and polynomial rings (R[x] for a commutative ring R).", "Sorry, I cannot provide a theorem stating that every ring is a field, as this statement is false. Fields are a specific type of rings with additional properties, and not every ring is a field.", "This statement is incorrect and cannot be proven. Not every ring is a field. A field is a special type of ring where every nonzero element has a multiplicative inverse, which is not true for all rings. Try another theorem.", "Sorry, this statement is incorrect. Not every ring is a field, as fields are a specific type of ring with additional properties. Please provide a valid statement to prove.", "Sorry, I cannot create a theorem that contradicts the definition of a field or any established mathematical fact. A ring is not necessarily a field, as fields have additional properties that rings do not always possess.", "Sorry, I cannot provide a theorem that \"every ring is a field\" as it is not true. Some rings are not fields due to the lack of multiplicative inverses for all non-zero elements. The correct statement would be \"every field is a ring\".", "Sorry, I cannot prove this statement, as it is not true in general. Not every ring is a field. For example, the integers (ℤ) form a ring, but not a field, because they do not have multiplicative inverses for all elements.", "This statement is incorrect and cannot be proven, as not every ring is a field. For example, the ring of integers (Z) is not a field, since it does not have multiplicative inverses for all nonzero elements."]}
{"docString": "Every vector space is finite dimensional.", "prompts": "[{\"theorem\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Type w}\\n  [inst_3 : Finite ι], Basis ι K V → FiniteDimensional K V\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a vector space has a finite basis, then it is finite-dimensional. \"},\n {\"theorem\":\n  \"∀ {k G : Type u} [inst : Field k] [inst_1 : Monoid G] (V W : FdRep k G), FiniteDimensional k (V ⟶ W)\",\n  \"isProp\": true,\n  \"docString\": \"All hom spaces are finite dimensional. \"},\n {\"theorem\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Type w}\\n  {s : Set ι}, Basis (↑s) K V → Set.Finite s → FiniteDimensional K V\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a vector space has a basis indexed by elements of a finite set, then it is\\nfinite-dimensional. \"},\n {\"theorem\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  [inst_3 : FiniteDimensional K V] (S : Submodule K V), FiniteDimensional K { x // x ∈ S }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subspace of a finite-dimensional space is also finite-dimensional. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [inst : Field 𝕜] [inst_1 : TopologicalSpace 𝕜] [inst_2 : AddCommGroup E]\\n  [inst_3 : Module 𝕜 E] [inst_4 : TopologicalSpace E] [inst_5 : AddCommGroup F] [inst_6 : Module 𝕜 F]\\n  [inst_7 : TopologicalSpace F] [inst_8 : TopologicalAddGroup F] [inst_9 : ContinuousSMul 𝕜 F]\\n  [inst_10 : FiniteDimensional 𝕜 E] [inst_11 : FiniteDimensional 𝕜 F], FiniteDimensional 𝕜 (E →L[𝕜] F)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The space of continuous linear maps between finite-dimensional spaces is finite-dimensional. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u} [inst : NontriviallyNormedField 𝕜] {E : Type v} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : CompleteSpace 𝕜] (s : Submodule 𝕜 E)\\n  [inst_4 : FiniteDimensional 𝕜 { x // x ∈ s }], IsComplete ↑s\",\n  \"isProp\": true,\n  \"docString\": \"A finite-dimensional subspace is complete. \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : Ring R] [inst_1 : StrongRankCondition R] {M : Type v} [inst_2 : AddCommGroup M]\\n  [inst_3 : Module R M] {ι : Type w} [inst_4 : Fintype ι], Basis ι R M → Module.rank R M = ↑(Fintype.card ι)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a vector space has a finite basis, then its dimension (seen as a cardinal) is equal to the\\ncardinality of the basis. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u} [inst : NontriviallyNormedField 𝕜] {E : Type v} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : CompleteSpace 𝕜] (s : Submodule 𝕜 E)\\n  [inst_4 : FiniteDimensional 𝕜 { x // x ∈ s }], IsClosed ↑s\",\n  \"isProp\": true,\n  \"docString\": \"A finite-dimensional subspace is closed. \"},\n {\"theorem\":\n  \"∀ {J : Type} [inst : CategoryTheory.SmallCategory J] [inst_1 : CategoryTheory.FinCategory J] {k : Type v}\\n  [inst_2 : Field k] (F : CategoryTheory.Functor J (FGModuleCat k)),\\n  FiniteDimensional k\\n    ↑(CategoryTheory.Limits.limit\\n        (CategoryTheory.Functor.comp F (CategoryTheory.forget₂ (FGModuleCat k) (ModuleCat k))))\",\n  \"isProp\": true,\n  \"docString\":\n  \"Finite limits of finite dimensional vectors spaces are finite dimensional,\\nbecause we can realise them as subobjects of a finite product. \"},\n {\"theorem\":\n  \"∀ (k : Type u_2) {V : Type u_3} {P : Type u_1} [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [inst_3 : AddTorsor V P] {s : Set P}, Set.Finite s → FiniteDimensional k { x // x ∈ vectorSpan k s }\",\n  \"isProp\": true,\n  \"docString\": \"The `vectorSpan` of a finite set is finite-dimensional. \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : Ring R] {M : Type v} [inst_1 : AddCommGroup M] [inst_2 : Module R M] {M₁ : Type v}\\n  [inst_3 : AddCommGroup M₁] [inst_4 : Module R M₁], (M ≃ₗ[R] M₁) → Module.rank R M = Module.rank R M₁\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two linearly equivalent vector spaces have the same dimension. \"},\n {\"theorem\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  [inst_3 : FiniteDimensional K V] (S : Submodule K V), FiniteDimensional K (V ⧸ S)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A quotient of a finite-dimensional space is also finite-dimensional. \"},\n {\"theorem\":\n  \"∀ (k : Type u_1) {V : Type u_2} {P : Type u_4} {ι : Type u_3} [inst : DivisionRing k] [inst_1 : AddCommGroup V]\\n  [inst_2 : Module k V] [inst_3 : AddTorsor V P] [inst_4 : FiniteDimensional k V] {s : Set ι} {f : ↑s → P},\\n  AffineIndependent k f → Set.Finite s\",\n  \"isProp\": true,\n  \"docString\":\n  \"An affine-independent subset of a finite-dimensional affine space is finite. \"},\n {\"theorem\":\n  \"∀ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [inst_3 : AddTorsor V P] (s : AffineSubspace k P)\\n  [inst_4 : FiniteDimensional k { x // x ∈ AffineSubspace.direction s }] (p : P),\\n  FiniteDimensional k { x // x ∈ vectorSpan k (insert p ↑s) }\",\n  \"isProp\": true,\n  \"docString\":\n  \"The `vectorSpan` of adding a point to a finite-dimensional subspace is finite-dimensional. \"},\n {\"theorem\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {V₂ : Type v'}\\n  [inst_3 : AddCommGroup V₂] [inst_4 : Module K V₂] [inst_5 : FiniteDimensional K V] (f : V →ₗ[K] V₂),\\n  FiniteDimensional K { x // x ∈ LinearMap.range f }\",\n  \"isProp\": true,\n  \"docString\":\n  \"The range of a linear map defined on a finite-dimensional space is also finite-dimensional. \"},\n {\"theorem\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {V₂ : Type v'}\\n  [inst_3 : AddCommGroup V₂] [inst_4 : Module K V₂] [inst_5 : FiniteDimensional K V] (f : V →ₗ[K] V₂),\\n  LinearMap.range f = ⊤ → FiniteDimensional K V₂\",\n  \"isProp\": true,\n  \"docString\":\n  \"The image under an onto linear map of a finite-dimensional space is also finite-dimensional. \"},\n {\"theorem\":\n  \"∀ {K : Type u} {V : Type v} [inst : Ring K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  [inst_3 : StrongRankCondition K] {ι : Type w} [inst_4 : Fintype ι],\\n  Basis ι K V → FiniteDimensional.finrank K V = Fintype.card ι\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a vector space (or module) has a finite basis, then its dimension (or rank) is equal to the\\ncardinality of the basis. \"},\n {\"theorem\":\n  \"∀ {K : Type u} {V : Type v} {V' : Type v'} [inst : Ring K] [inst_1 : StrongRankCondition K] [inst_2 : AddCommGroup V]\\n  [inst_3 : Module K V] [inst_4 : Module.Free K V] [inst_5 : AddCommGroup V'] [inst_6 : Module K V']\\n  [inst_7 : Module.Free K V'],\\n  Nonempty (V ≃ₗ[K] V') ↔ Cardinal.lift (Module.rank K V) = Cardinal.lift (Module.rank K V')\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two vector spaces are isomorphic if and only if they have the same dimension. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} {M : Type u_2} {M₂ : Type u_3} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : AddCommGroup M₂]\\n  [inst_3 : Module R M] [inst_4 : Module R M₂],\\n  (M ≃ₗ[R] M₂) → FiniteDimensional.finrank R M = FiniteDimensional.finrank R M₂\",\n  \"isProp\": true,\n  \"docString\":\n  \"The dimension of a finite dimensional space is preserved under linear equivalence. \"},\n {\"theorem\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\\n  Module.rank K V < Cardinal.aleph0 → Set.Finite (Basis.ofVectorSpaceIndex K V)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a vector space has a finite dimension, the index set of `Basis.ofVectorSpace` is finite. \"}]\n", "prompt_cons": "/-- If a vector space has a finite basis, then it is finite-dimensional. -/\ntheorem ∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Type w}\n  [inst_3 : Finite ι], Basis ι K V → FiniteDimensional K V :=\n\n/-- All hom spaces are finite dimensional. -/\ntheorem ∀ {k G : Type u} [inst : Field k] [inst_1 : Monoid G] (V W : FdRep k G), FiniteDimensional k (V ⟶ W) :=\n\n/-- If a vector space has a basis indexed by elements of a finite set, then it is\nfinite-dimensional. -/\ntheorem ∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Type w}\n  {s : Set ι}, Basis (↑s) K V → Set.Finite s → FiniteDimensional K V :=\n\n/-- A subspace of a finite-dimensional space is also finite-dimensional. -/\ntheorem ∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V] (S : Submodule K V), FiniteDimensional K { x // x ∈ S } :=\n\n/-- The space of continuous linear maps between finite-dimensional spaces is finite-dimensional. -/\ntheorem ∀ {𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [inst : Field 𝕜] [inst_1 : TopologicalSpace 𝕜] [inst_2 : AddCommGroup E]\n  [inst_3 : Module 𝕜 E] [inst_4 : TopologicalSpace E] [inst_5 : AddCommGroup F] [inst_6 : Module 𝕜 F]\n  [inst_7 : TopologicalSpace F] [inst_8 : TopologicalAddGroup F] [inst_9 : ContinuousSMul 𝕜 F]\n  [inst_10 : FiniteDimensional 𝕜 E] [inst_11 : FiniteDimensional 𝕜 F], FiniteDimensional 𝕜 (E →L[𝕜] F) :=\n\n/-- A finite-dimensional subspace is complete. -/\ntheorem ∀ {𝕜 : Type u} [inst : NontriviallyNormedField 𝕜] {E : Type v} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : CompleteSpace 𝕜] (s : Submodule 𝕜 E)\n  [inst_4 : FiniteDimensional 𝕜 { x // x ∈ s }], IsComplete ↑s :=\n\n/-- If a vector space has a finite basis, then its dimension (seen as a cardinal) is equal to the\ncardinality of the basis. -/\ntheorem ∀ {R : Type u} [inst : Ring R] [inst_1 : StrongRankCondition R] {M : Type v} [inst_2 : AddCommGroup M]\n  [inst_3 : Module R M] {ι : Type w} [inst_4 : Fintype ι], Basis ι R M → Module.rank R M = ↑(Fintype.card ι) :=\n\n/-- A finite-dimensional subspace is closed. -/\ntheorem ∀ {𝕜 : Type u} [inst : NontriviallyNormedField 𝕜] {E : Type v} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : CompleteSpace 𝕜] (s : Submodule 𝕜 E)\n  [inst_4 : FiniteDimensional 𝕜 { x // x ∈ s }], IsClosed ↑s :=\n\n/-- Finite limits of finite dimensional vectors spaces are finite dimensional,\nbecause we can realise them as subobjects of a finite product. -/\ntheorem ∀ {J : Type} [inst : CategoryTheory.SmallCategory J] [inst_1 : CategoryTheory.FinCategory J] {k : Type v}\n  [inst_2 : Field k] (F : CategoryTheory.Functor J (FGModuleCat k)),\n  FiniteDimensional k\n    ↑(CategoryTheory.Limits.limit\n        (CategoryTheory.Functor.comp F (CategoryTheory.forget₂ (FGModuleCat k) (ModuleCat k)))) :=\n\n/-- The `vectorSpan` of a finite set is finite-dimensional. -/\ntheorem ∀ (k : Type u_2) {V : Type u_3} {P : Type u_1} [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {s : Set P}, Set.Finite s → FiniteDimensional k { x // x ∈ vectorSpan k s } :=\n\n/-- Two linearly equivalent vector spaces have the same dimension. -/\ntheorem ∀ {R : Type u} [inst : Ring R] {M : Type v} [inst_1 : AddCommGroup M] [inst_2 : Module R M] {M₁ : Type v}\n  [inst_3 : AddCommGroup M₁] [inst_4 : Module R M₁], (M ≃ₗ[R] M₁) → Module.rank R M = Module.rank R M₁ :=\n\n/-- A quotient of a finite-dimensional space is also finite-dimensional. -/\ntheorem ∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V] (S : Submodule K V), FiniteDimensional K (V ⧸ S) :=\n\n/-- An affine-independent subset of a finite-dimensional affine space is finite. -/\ntheorem ∀ (k : Type u_1) {V : Type u_2} {P : Type u_4} {ι : Type u_3} [inst : DivisionRing k] [inst_1 : AddCommGroup V]\n  [inst_2 : Module k V] [inst_3 : AddTorsor V P] [inst_4 : FiniteDimensional k V] {s : Set ι} {f : ↑s → P},\n  AffineIndependent k f → Set.Finite s :=\n\n/-- The `vectorSpan` of adding a point to a finite-dimensional subspace is finite-dimensional. -/\ntheorem ∀ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] (s : AffineSubspace k P)\n  [inst_4 : FiniteDimensional k { x // x ∈ AffineSubspace.direction s }] (p : P),\n  FiniteDimensional k { x // x ∈ vectorSpan k (insert p ↑s) } :=\n\n/-- The range of a linear map defined on a finite-dimensional space is also finite-dimensional. -/\ntheorem ∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {V₂ : Type v'}\n  [inst_3 : AddCommGroup V₂] [inst_4 : Module K V₂] [inst_5 : FiniteDimensional K V] (f : V →ₗ[K] V₂),\n  FiniteDimensional K { x // x ∈ LinearMap.range f } :=\n\n/-- The image under an onto linear map of a finite-dimensional space is also finite-dimensional. -/\ntheorem ∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {V₂ : Type v'}\n  [inst_3 : AddCommGroup V₂] [inst_4 : Module K V₂] [inst_5 : FiniteDimensional K V] (f : V →ₗ[K] V₂),\n  LinearMap.range f = ⊤ → FiniteDimensional K V₂ :=\n\n/-- If a vector space (or module) has a finite basis, then its dimension (or rank) is equal to the\ncardinality of the basis. -/\ntheorem ∀ {K : Type u} {V : Type v} [inst : Ring K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : StrongRankCondition K] {ι : Type w} [inst_4 : Fintype ι],\n  Basis ι K V → FiniteDimensional.finrank K V = Fintype.card ι :=\n\n/-- Two vector spaces are isomorphic if and only if they have the same dimension. -/\ntheorem ∀ {K : Type u} {V : Type v} {V' : Type v'} [inst : Ring K] [inst_1 : StrongRankCondition K] [inst_2 : AddCommGroup V]\n  [inst_3 : Module K V] [inst_4 : Module.Free K V] [inst_5 : AddCommGroup V'] [inst_6 : Module K V']\n  [inst_7 : Module.Free K V'],\n  Nonempty (V ≃ₗ[K] V') ↔ Cardinal.lift (Module.rank K V) = Cardinal.lift (Module.rank K V') :=\n\n/-- The dimension of a finite dimensional space is preserved under linear equivalence. -/\ntheorem ∀ {R : Type u_1} {M : Type u_2} {M₂ : Type u_3} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : AddCommGroup M₂]\n  [inst_3 : Module R M] [inst_4 : Module R M₂],\n  (M ≃ₗ[R] M₂) → FiniteDimensional.finrank R M = FiniteDimensional.finrank R M₂ :=\n\n/-- If a vector space has a finite dimension, the index set of `Basis.ofVectorSpace` is finite. -/\ntheorem ∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V < Cardinal.aleph0 → Set.Finite (Basis.ofVectorSpaceIndex K V) :=\n\n/-- Every vector space is finite dimensional. -/\ntheorem", "choices": ["∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V], FiniteDimensional K V ", "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V], FiniteDimensional K V ", "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V], FiniteDimensional K V ", "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V], FiniteDimensional K V ", "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  FiniteDimensional K V ", "∀ (K : Type u) (V : Type v) [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V], FiniteDimensional K V ", "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  FiniteDimensional K V ", "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V], FiniteDimensional K V ", "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V], FiniteDimensional K V ", "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  FiniteDimensional K V "]}
{"docString": "Every group is a torsion monoid.", "prompts": "[{\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G → ∀ (H : Subgroup G), Monoid.IsTorsion { x // x ∈ H }\",\n  \"isProp\": true,\n  \"docString\": \"Subgroups of torsion groups are torsion groups. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"Finite groups are torsion groups. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : AddGroup G], AddMonoid.IsTorsion G → ∀ (H : AddSubgroup G), AddMonoid.IsTorsion { x // x ∈ H }\",\n  \"isProp\": true,\n  \"docString\":\n  \"Subgroups of additive torsion groups are additive torsion groups.\"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsionFree G → ∀ (H : Subgroup G), Monoid.IsTorsionFree { x // x ∈ H }\",\n  \"isProp\": true,\n  \"docString\": \"Subgroups of torsion-free groups are torsion-free. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : CommMonoid G], Monoid.IsTorsion { x // x ∈ CommMonoid.torsion G }\",\n  \"isProp\": true,\n  \"docString\": \"Torsion submonoids are torsion. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : AddGroup G],\\n  AddMonoid.IsTorsionFree G → ∀ (H : AddSubgroup G), AddMonoid.IsTorsionFree { x // x ∈ H }\",\n  \"isProp\": true,\n  \"docString\":\n  \"Subgroups of additive torsion-free groups are additively torsion-free.\"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : AddGroup G] [inst_1 : Finite G], AddMonoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"Finite additive groups are additive torsion groups.\"},\n {\"theorem\":\n  \"∀ {G : Type u_1} {H : Type u_2} [inst : Group G] {N : Subgroup G} [inst_1 : Group H] {f : G →* H},\\n  N = MonoidHom.ker f → Monoid.IsTorsion H → Monoid.IsTorsion { x // x ∈ N } → Monoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"Torsion groups are closed under extensions. \"},\n {\"theorem\":\n  \"∀ (G : Type u_1) [inst : CommGroup G], CommMonoid.torsion G = (CommGroup.torsion G).toSubmonoid\",\n  \"isProp\": true,\n  \"docString\":\n  \"The torsion submonoid of an abelian group equals the torsion subgroup as a submonoid. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : CommMonoid G], Monoid.IsTorsion G → CommMonoid.torsion G = ⊤\",\n  \"isProp\": true,\n  \"docString\": \"The torsion submonoid of a torsion monoid is `⊤`. \"},\n {\"theorem\":\n  \"∀ (G : Type u_1) [inst : CommGroup G], Monoid.IsTorsionFree (G ⧸ CommGroup.torsion G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Quotienting a group by its torsion subgroup yields a torsion free group. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : AddCommMonoid G], AddMonoid.IsTorsion { x // x ∈ AddCommMonoid.addTorsion G }\",\n  \"isProp\": true,\n  \"docString\": \"Additive torsion submonoids are additively torsion.\"},\n {\"theorem\":\n  \"∀ {η : Type u_1} {Gs : η → Type u_2} [inst : (i : η) → Group (Gs i)],\\n  (∀ (i : η), Monoid.IsTorsionFree (Gs i)) → Monoid.IsTorsionFree ((i : η) → Gs i)\",\n  \"isProp\": true,\n  \"docString\": \"Direct products of torsion free groups are torsion free. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G], Monoid.ExponentExists G → Monoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"If a group exponent exists, the group is torsion. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} {H : Type u_2} [inst : AddGroup G] {N : AddSubgroup G} [inst_1 : AddGroup H] {f : G →+ H},\\n  N = AddMonoidHom.ker f → AddMonoid.IsTorsion H → AddMonoid.IsTorsion { x // x ∈ N } → AddMonoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"Additive torsion groups are closed under extensions.\"},\n {\"theorem\":\n  \"{G : Type u_1} → [inst : Monoid G] → Monoid.IsTorsion G → Group G\",\n  \"isProp\": false,\n  \"docString\": \"Torsion monoids are really groups. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : Group H] {f : G →* H},\\n  Function.Surjective ↑f → Monoid.IsTorsion G → Monoid.IsTorsion H\",\n  \"isProp\": true,\n  \"docString\":\n  \"The image of a surjective torsion group homomorphism is torsion. \"},\n {\"theorem\":\n  \"∀ (G : Type u_1) [inst : AddCommGroup G], AddCommMonoid.addTorsion G = (AddCommGroup.torsion G).toAddSubmonoid\",\n  \"isProp\": true,\n  \"docString\":\n  \"The additive torsion submonoid of an abelian group equals the torsion\\nsubgroup as a submonoid.\"},\n {\"theorem\":\n  \"∀ {η : Type u_1} {Gs : η → Type u_2} [inst : (i : η) → AddGroup (Gs i)],\\n  (∀ (i : η), AddMonoid.IsTorsionFree (Gs i)) → AddMonoid.IsTorsionFree ((i : η) → Gs i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Direct products of additive torsion free groups are torsion free.\"},\n {\"theorem\":\n  \"∀ (G : Type u_1) [inst : AddCommGroup G], AddMonoid.IsTorsionFree (G ⧸ AddCommGroup.torsion G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Quotienting a group by its additive torsion subgroup yields an additive torsion free group.\"}]\n", "prompt_cons": "/-- Subgroups of torsion groups are torsion groups. -/\ntheorem ∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G → ∀ (H : Subgroup G), Monoid.IsTorsion { x // x ∈ H } :=\n\n/-- Finite groups are torsion groups. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G :=\n\n/-- Subgroups of additive torsion groups are additive torsion groups. -/\ntheorem ∀ {G : Type u_1} [inst : AddGroup G], AddMonoid.IsTorsion G → ∀ (H : AddSubgroup G), AddMonoid.IsTorsion { x // x ∈ H } :=\n\n/-- Subgroups of torsion-free groups are torsion-free. -/\ntheorem ∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsionFree G → ∀ (H : Subgroup G), Monoid.IsTorsionFree { x // x ∈ H } :=\n\n/-- Torsion submonoids are torsion. -/\ntheorem ∀ {G : Type u_1} [inst : CommMonoid G], Monoid.IsTorsion { x // x ∈ CommMonoid.torsion G } :=\n\n/-- Subgroups of additive torsion-free groups are additively torsion-free. -/\ntheorem ∀ {G : Type u_1} [inst : AddGroup G],\n  AddMonoid.IsTorsionFree G → ∀ (H : AddSubgroup G), AddMonoid.IsTorsionFree { x // x ∈ H } :=\n\n/-- Finite additive groups are additive torsion groups. -/\ntheorem ∀ {G : Type u_1} [inst : AddGroup G] [inst_1 : Finite G], AddMonoid.IsTorsion G :=\n\n/-- Torsion groups are closed under extensions. -/\ntheorem ∀ {G : Type u_1} {H : Type u_2} [inst : Group G] {N : Subgroup G} [inst_1 : Group H] {f : G →* H},\n  N = MonoidHom.ker f → Monoid.IsTorsion H → Monoid.IsTorsion { x // x ∈ N } → Monoid.IsTorsion G :=\n\n/-- The torsion submonoid of an abelian group equals the torsion subgroup as a submonoid. -/\ntheorem ∀ (G : Type u_1) [inst : CommGroup G], CommMonoid.torsion G = (CommGroup.torsion G).toSubmonoid :=\n\n/-- The torsion submonoid of a torsion monoid is `⊤`. -/\ntheorem ∀ {G : Type u_1} [inst : CommMonoid G], Monoid.IsTorsion G → CommMonoid.torsion G = ⊤ :=\n\n/-- Quotienting a group by its torsion subgroup yields a torsion free group. -/\ntheorem ∀ (G : Type u_1) [inst : CommGroup G], Monoid.IsTorsionFree (G ⧸ CommGroup.torsion G) :=\n\n/-- Additive torsion submonoids are additively torsion. -/\ntheorem ∀ {G : Type u_1} [inst : AddCommMonoid G], AddMonoid.IsTorsion { x // x ∈ AddCommMonoid.addTorsion G } :=\n\n/-- Direct products of torsion free groups are torsion free. -/\ntheorem ∀ {η : Type u_1} {Gs : η → Type u_2} [inst : (i : η) → Group (Gs i)],\n  (∀ (i : η), Monoid.IsTorsionFree (Gs i)) → Monoid.IsTorsionFree ((i : η) → Gs i) :=\n\n/-- If a group exponent exists, the group is torsion. -/\ntheorem ∀ {G : Type u_1} [inst : Group G], Monoid.ExponentExists G → Monoid.IsTorsion G :=\n\n/-- Additive torsion groups are closed under extensions. -/\ntheorem ∀ {G : Type u_1} {H : Type u_2} [inst : AddGroup G] {N : AddSubgroup G} [inst_1 : AddGroup H] {f : G →+ H},\n  N = AddMonoidHom.ker f → AddMonoid.IsTorsion H → AddMonoid.IsTorsion { x // x ∈ N } → AddMonoid.IsTorsion G :=\n\n/-- Torsion monoids are really groups. -/\ntheorem {G : Type u_1} → [inst : Monoid G] → Monoid.IsTorsion G → Group G :=\n\n/-- The image of a surjective torsion group homomorphism is torsion. -/\ntheorem ∀ {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : Group H] {f : G →* H},\n  Function.Surjective ↑f → Monoid.IsTorsion G → Monoid.IsTorsion H :=\n\n/-- The additive torsion submonoid of an abelian group equals the torsion\nsubgroup as a submonoid. -/\ntheorem ∀ (G : Type u_1) [inst : AddCommGroup G], AddCommMonoid.addTorsion G = (AddCommGroup.torsion G).toAddSubmonoid :=\n\n/-- Direct products of additive torsion free groups are torsion free. -/\ntheorem ∀ {η : Type u_1} {Gs : η → Type u_2} [inst : (i : η) → AddGroup (Gs i)],\n  (∀ (i : η), AddMonoid.IsTorsionFree (Gs i)) → AddMonoid.IsTorsionFree ((i : η) → Gs i) :=\n\n/-- Quotienting a group by its additive torsion subgroup yields an additive torsion free group. -/\ntheorem ∀ (G : Type u_1) [inst : AddCommGroup G], AddMonoid.IsTorsionFree (G ⧸ AddCommGroup.torsion G) :=\n\n/-- Every group is a torsion monoid. -/\ntheorem", "choices": ["∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G ", "∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G ", "∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G ", "∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G ", "∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G ", "∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G ", "∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G ", " ∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G ", "∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G ", "∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G "]}
{"docString": "Every finite simple group has prime order.", "prompts": "[{\"theorem\":\n  \"∀ {α : Type u} [inst : AddGroup α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\\n  Fintype.card α = p → IsSimpleAddGroup α\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is simple.\"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\\n  Fintype.card α = p → IsSimpleGroup α\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is simple. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : AddGroup α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\\n  Fintype.card α = p → IsAddCyclic α\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic.\"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)], Fintype.card α = p → IsCyclic α\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : Fintype α] [inst_1 : Field α], IsPrimePow (Fintype.card α)\",\n  \"isProp\": true,\n  \"docString\": \"A finite field has prime power cardinality. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x⁻¹ ↔ IsOfFinOrder x\",\n  \"isProp\": true,\n  \"docString\": \"Inverses of elements of finite order have finite order. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Monoid G] {x : G}, 0 < orderOf x ↔ IsOfFinOrder x\",\n  \"isProp\": true,\n  \"docString\": \"A group element has finite order iff its order is positive. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)],\\n  p ∣ Fintype.card G → ∃ x, orderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite group `G` there exists an element of order\\n`p` in `G`. This is known as Cauchy's theorem. \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : CommRing R] [self : IsBezout R] (I : Ideal R), Ideal.FG I → Submodule.IsPrincipal I\",\n  \"isProp\": true,\n  \"docString\": \"Any finitely generated ideal is principal. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : AddMonoid G] {x : G}, 0 < addOrderOf x ↔ IsOfFinAddOrder x\",\n  \"isProp\": true,\n  \"docString\":\n  \"A group element has finite additive order iff its order is positive.\"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)],\\n  p ∣ Fintype.card G → ∃ x, addOrderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite additive group `G` there exists an element of\\norder `p` in `G`. This is the additive version of Cauchy's theorem. \"},\n {\"theorem\":\n  \"∀ {G : Type u_2} [inst : Group G] {G₂ : Type u_1} [inst_1 : Group G₂] (p₁ p₂ : ℕ) [hp₁ : Fact (Nat.Prime p₁)]\\n  [hp₂ : Fact (Nat.Prime p₂)],\\n  p₁ ≠ p₂ →\\n    ∀ (H₁ : Subgroup G) (H₂ : Subgroup G₂) [inst_2 : Fintype { x // x ∈ H₁ }] [inst_3 : Fintype { x // x ∈ H₂ }],\\n      IsPGroup p₁ { x // x ∈ H₁ } →\\n        IsPGroup p₂ { x // x ∈ H₂ } → Nat.coprime (Fintype.card { x // x ∈ H₁ }) (Fintype.card { x // x ∈ H₂ })\",\n  \"isProp\": true,\n  \"docString\": \"finite p-groups with different p have coprime orders \"},\n {\"theorem\":\n  \"∀ {G : Type u_2} {H : Type u_1} [inst : Monoid G] [inst_1 : Monoid H] (f : G →* H) {x : G},\\n  IsOfFinOrder x → IsOfFinOrder (↑f x)\",\n  \"isProp\": true,\n  \"docString\": \"The image of an element of finite order has finite order. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : AddGroup G] {x : G}, IsOfFinAddOrder x → IsOfFinAddOrder (-x)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Inverses of elements of finite additive order have finite additive order.\"},\n {\"theorem\":\n  \"∀ {A : Type u_1} {B : Type u_2} [inst : Field A] [inst_1 : Ring B] [inst_2 : IsDomain B] [inst_3 : Algebra A B] {x : B},\\n  IsIntegral A x → Prime (minpoly A x)\",\n  \"isProp\": true,\n  \"docString\": \"A minimal polynomial is prime. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : CommRing R] [inst_1 : Fintype R] (p : ℕ) [inst_2 : Fact (Nat.Prime p)],\\n  p ∣ ringChar R ↔ p ∣ Fintype.card R\",\n  \"isProp\": true,\n  \"docString\":\n  \"The prime divisors of the characteristic of a finite commutative ring are exactly\\nthe prime divisors of its cardinality. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [self : LinearOrderedCommGroupWithZero α] (a : α), a ≠ 0 → a * a⁻¹ = 1\",\n  \"isProp\": true,\n  \"docString\": \"Every nonzero element of a group with zero is invertible. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"Finite groups are torsion groups. \"},\n {\"theorem\": \"Set.InjOn Nat.factorization {x | x ≠ 0}\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every nonzero natural number has a unique prime factorization \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : Semiring α] {I : Ideal α} [self : Ideal.IsPrime I] {x y : α}, x * y ∈ I → x ∈ I ∨ y ∈ I\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a product lies in the prime ideal, then at least one element lies in the prime ideal. \"}]\n", "prompt_cons": "/-- A finite group of prime order is simple. -/\ntheorem ∀ {α : Type u} [inst : AddGroup α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\n  Fintype.card α = p → IsSimpleAddGroup α :=\n\n/-- A finite group of prime order is simple. -/\ntheorem ∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\n  Fintype.card α = p → IsSimpleGroup α :=\n\n/-- A finite group of prime order is cyclic. -/\ntheorem ∀ {α : Type u} [inst : AddGroup α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\n  Fintype.card α = p → IsAddCyclic α :=\n\n/-- A finite group of prime order is cyclic. -/\ntheorem ∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)], Fintype.card α = p → IsCyclic α :=\n\n/-- A finite field has prime power cardinality. -/\ntheorem ∀ {α : Type u_1} [inst : Fintype α] [inst_1 : Field α], IsPrimePow (Fintype.card α) :=\n\n/-- Inverses of elements of finite order have finite order. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x⁻¹ ↔ IsOfFinOrder x :=\n\n/-- A group element has finite order iff its order is positive. -/\ntheorem ∀ {G : Type u_1} [inst : Monoid G] {x : G}, 0 < orderOf x ↔ IsOfFinOrder x :=\n\n/-- For every prime `p` dividing the order of a finite group `G` there exists an element of order\n`p` in `G`. This is known as Cauchy's theorem. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)],\n  p ∣ Fintype.card G → ∃ x, orderOf x = p :=\n\n/-- Any finitely generated ideal is principal. -/\ntheorem ∀ {R : Type u} [inst : CommRing R] [self : IsBezout R] (I : Ideal R), Ideal.FG I → Submodule.IsPrincipal I :=\n\n/-- A group element has finite additive order iff its order is positive. -/\ntheorem ∀ {G : Type u_1} [inst : AddMonoid G] {x : G}, 0 < addOrderOf x ↔ IsOfFinAddOrder x :=\n\n/-- For every prime `p` dividing the order of a finite additive group `G` there exists an element of\norder `p` in `G`. This is the additive version of Cauchy's theorem. -/\ntheorem ∀ {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)],\n  p ∣ Fintype.card G → ∃ x, addOrderOf x = p :=\n\n/-- finite p-groups with different p have coprime orders -/\ntheorem ∀ {G : Type u_2} [inst : Group G] {G₂ : Type u_1} [inst_1 : Group G₂] (p₁ p₂ : ℕ) [hp₁ : Fact (Nat.Prime p₁)]\n  [hp₂ : Fact (Nat.Prime p₂)],\n  p₁ ≠ p₂ →\n    ∀ (H₁ : Subgroup G) (H₂ : Subgroup G₂) [inst_2 : Fintype { x // x ∈ H₁ }] [inst_3 : Fintype { x // x ∈ H₂ }],\n      IsPGroup p₁ { x // x ∈ H₁ } →\n        IsPGroup p₂ { x // x ∈ H₂ } → Nat.coprime (Fintype.card { x // x ∈ H₁ }) (Fintype.card { x // x ∈ H₂ }) :=\n\n/-- The image of an element of finite order has finite order. -/\ntheorem ∀ {G : Type u_2} {H : Type u_1} [inst : Monoid G] [inst_1 : Monoid H] (f : G →* H) {x : G},\n  IsOfFinOrder x → IsOfFinOrder (↑f x) :=\n\n/-- Inverses of elements of finite additive order have finite additive order. -/\ntheorem ∀ {G : Type u_1} [inst : AddGroup G] {x : G}, IsOfFinAddOrder x → IsOfFinAddOrder (-x) :=\n\n/-- A minimal polynomial is prime. -/\ntheorem ∀ {A : Type u_1} {B : Type u_2} [inst : Field A] [inst_1 : Ring B] [inst_2 : IsDomain B] [inst_3 : Algebra A B] {x : B},\n  IsIntegral A x → Prime (minpoly A x) :=\n\n/-- The prime divisors of the characteristic of a finite commutative ring are exactly\nthe prime divisors of its cardinality. -/\ntheorem ∀ {R : Type u_1} [inst : CommRing R] [inst_1 : Fintype R] (p : ℕ) [inst_2 : Fact (Nat.Prime p)],\n  p ∣ ringChar R ↔ p ∣ Fintype.card R :=\n\n/-- Every nonzero element of a group with zero is invertible. -/\ntheorem ∀ {α : Type u_1} [self : LinearOrderedCommGroupWithZero α] (a : α), a ≠ 0 → a * a⁻¹ = 1 :=\n\n/-- Finite groups are torsion groups. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G :=\n\n/-- Every nonzero natural number has a unique prime factorization -/\ntheorem Set.InjOn Nat.factorization {x | x ≠ 0} :=\n\n/-- If a product lies in the prime ideal, then at least one element lies in the prime ideal. -/\ntheorem ∀ {α : Type u} [inst : Semiring α] {I : Ideal α} [self : Ideal.IsPrime I] {x y : α}, x * y ∈ I → x ∈ I ∨ y ∈ I :=\n\n/-- Every finite simple group has prime order. -/\ntheorem", "choices": ["∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] [self : IsSimpleGroup G], IsPrimePow (Fintype.card G) ", "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] [inst_2 : IsSimpleGroup G], ∃ p [hp : Fact (Nat.Prime p)], Fintype.card G = p ", "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], IsSimpleGroup G → ∃ p [hp : Fact (Nat.Prime p)], Fintype.card G = p ", "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] [self : IsSimpleGroup G], Exists (λ p, Nat.Prime p ∧ Fintype.card G = p) ", "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G],\n  IsSimpleGroup G → ∃ p, Nat.Prime p ∧ Fintype.card G = p ", "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] [inst_2 : IsSimpleGroup G],\n  ∃ p : ℕ, Nat.Prime p ∧ Fintype.card G = p ", "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] [self : IsSimpleGroup G], ∃ p [hp : Fact (Nat.Prime p)], Fintype.card G = p ", "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], IsSimpleGroup G → ∃ p, Fact (Nat.Prime p) ∧ Fintype.card G = p ", "∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] [self : IsSimpleGroup α],\n  ∃ p [hp : Fact (Nat.Prime p)], Fintype.card α = p ", "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] [inst_2 : IsSimpleGroup G], ∃ p [hp : Fact (Nat.Prime p)], Fintype.card G = p "]}
{"docString": "Every finite group is simple.", "prompts": "[{\"theorem\":\n  \"∀ {α : Type u} [inst : AddGroup α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\\n  Fintype.card α = p → IsSimpleAddGroup α\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is simple.\"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\\n  Fintype.card α = p → IsSimpleGroup α\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is simple. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : AddGroup α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\\n  Fintype.card α = p → IsAddCyclic α\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic.\"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)], Fintype.card α = p → IsCyclic α\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [self : LinearOrderedCommGroupWithZero α] (a : α), a ≠ 0 → a * a⁻¹ = 1\",\n  \"isProp\": true,\n  \"docString\": \"Every nonzero element of a group with zero is invertible. \"},\n {\"theorem\":\n  \"∀ {R : Type u_2} {A : Type u_1} [inst : CommRing R] [inst_1 : CommRing A] [inst_2 : Algebra R A] (s : Set A),\\n  AlgebraicIndependent R Subtype.val → ∀ (t : Finset ↑s), AlgebraicIndependent R Subtype.val\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every finite subset of an algebraically independent set is algebraically independent. \"},\n {\"theorem\": \"∀ {G : Type u_1} [inst : Group G], Group.FG G ↔ Monoid.FG G\",\n  \"isProp\": true,\n  \"docString\":\n  \"A group is finitely generated if and only if it is finitely generated as a monoid. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"Finite groups are torsion groups. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [hG : Group G] [inst : Fintype G],\\n  ((p : { x // x ∈ (Nat.factorization (Fintype.card G)).support }) → (P : Sylow (↑p) G) → { x // x ∈ ↑P }) ≃* G →\\n    Group.IsNilpotent G\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a finite group is the direct product of its Sylow groups, it is nilpotent \"},\n {\"theorem\":\n  \"∀ {R : Type u_2} {M : Type u_1} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M] (s : Set M),\\n  LinearIndependent R Subtype.val → ∀ (t : Finset ↑s), LinearIndependent R Subtype.val\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every finite subset of a linearly independent set is linearly independent. \"},\n {\"theorem\":\n  \"∀ {Γ : Type u_1} [inst : Group Γ] {T : Type u_2} [inst_1 : TopologicalSpace T] [inst_2 : MulAction Γ T]\\n  [inst_3 : Finite Γ], ProperlyDiscontinuousSMul Γ T\",\n  \"isProp\": true,\n  \"docString\": \"A finite group action is always properly discontinuous. \"},\n {\"theorem\":\n  \"∀ {Γ : Type u_1} [inst : AddGroup Γ] {T : Type u_2} [inst_1 : TopologicalSpace T] [inst_2 : AddAction Γ T]\\n  [inst_3 : Finite Γ], ProperlyDiscontinuousVAdd Γ T\",\n  \"isProp\": true,\n  \"docString\": \"A finite group action is always properly discontinuous.\"},\n {\"theorem\":\n  \"∀ (G : Type u_1) [inst : Group G] [inst_1 : Finite ↑(commutatorSet G)], Finite { x // x ∈ commutator G }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A theorem of Schur: A group with finitely many commutators has finite commutator subgroup. \"},\n {\"theorem\":\n  \"∀ {R : Type u_2} [inst : Ring R] {k : Type u_1} [inst_1 : Field k] [inst_2 : Algebra k R] {V : ModuleCat R},\\n  FiniteDimensional.finrank k ↑V = 1 → CategoryTheory.Simple V\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any `k`-algebra module which is 1-dimensional over `k` is simple. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {_m0 : MeasurableSpace α} (μ : MeasureTheory.Measure α) [inst : MeasureTheory.IsFiniteMeasure μ],\\n  MeasureTheory.SigmaFinite μ\",\n  \"isProp\": true,\n  \"docString\": \"Every finite measure is σ-finite. \"},\n {\"theorem\":\n  \"∀ (R : Type u) (L : Type v) [inst : CommRing R] [inst_1 : LieRing L] [inst_2 : LieAlgebra R L]\\n  [inst : LieAlgebra.IsSemisimple R L] [h : IsLieAbelian L], Subsingleton L\",\n  \"isProp\": true,\n  \"docString\": \"A semisimple Abelian Lie algebra is trivial. \"},\n {\"theorem\":\n  \"∀ (R : Type u) (L : Type v) [inst : CommRing R] [inst_1 : LieRing L] [inst_2 : LieAlgebra R L]\\n  [h : LieAlgebra.IsSimple R L], LieAlgebra.IsSemisimple R L\",\n  \"isProp\": true,\n  \"docString\": \"A simple Lie algebra is semisimple. \"},\n {\"theorem\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {A : Type u_1}\\n  [inst_3 : Semiring A] [inst_4 : Module A V] [inst_5 : SMul K A] [inst_6 : IsScalarTower K A V],\\n  FiniteDimensional.finrank K V = 1 → IsSimpleOrder (Submodule A V)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any `K`-algebra module that is 1-dimensional over `K` is simple. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] (P : Subgroup G), Subgroup.FG P ↔ Submonoid.FG P.toSubmonoid\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subgroup is finitely generated if and only if it is finitely generated as a submonoid. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : AddGroup G] [inst_1 : Finite G], AddMonoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"Finite additive groups are additive torsion groups.\"}]\n", "prompt_cons": "/-- A finite group of prime order is simple. -/\ntheorem ∀ {α : Type u} [inst : AddGroup α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\n  Fintype.card α = p → IsSimpleAddGroup α :=\n\n/-- A finite group of prime order is simple. -/\ntheorem ∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\n  Fintype.card α = p → IsSimpleGroup α :=\n\n/-- A finite group of prime order is cyclic. -/\ntheorem ∀ {α : Type u} [inst : AddGroup α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\n  Fintype.card α = p → IsAddCyclic α :=\n\n/-- A finite group of prime order is cyclic. -/\ntheorem ∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)], Fintype.card α = p → IsCyclic α :=\n\n/-- Every nonzero element of a group with zero is invertible. -/\ntheorem ∀ {α : Type u_1} [self : LinearOrderedCommGroupWithZero α] (a : α), a ≠ 0 → a * a⁻¹ = 1 :=\n\n/-- Every finite subset of an algebraically independent set is algebraically independent. -/\ntheorem ∀ {R : Type u_2} {A : Type u_1} [inst : CommRing R] [inst_1 : CommRing A] [inst_2 : Algebra R A] (s : Set A),\n  AlgebraicIndependent R Subtype.val → ∀ (t : Finset ↑s), AlgebraicIndependent R Subtype.val :=\n\n/-- A group is finitely generated if and only if it is finitely generated as a monoid. -/\ntheorem ∀ {G : Type u_1} [inst : Group G], Group.FG G ↔ Monoid.FG G :=\n\n/-- Finite groups are torsion groups. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G :=\n\n/-- If a finite group is the direct product of its Sylow groups, it is nilpotent -/\ntheorem ∀ {G : Type u_1} [hG : Group G] [inst : Fintype G],\n  ((p : { x // x ∈ (Nat.factorization (Fintype.card G)).support }) → (P : Sylow (↑p) G) → { x // x ∈ ↑P }) ≃* G →\n    Group.IsNilpotent G :=\n\n/-- Every finite subset of a linearly independent set is linearly independent. -/\ntheorem ∀ {R : Type u_2} {M : Type u_1} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M] (s : Set M),\n  LinearIndependent R Subtype.val → ∀ (t : Finset ↑s), LinearIndependent R Subtype.val :=\n\n/-- A finite group action is always properly discontinuous. -/\ntheorem ∀ {Γ : Type u_1} [inst : Group Γ] {T : Type u_2} [inst_1 : TopologicalSpace T] [inst_2 : MulAction Γ T]\n  [inst_3 : Finite Γ], ProperlyDiscontinuousSMul Γ T :=\n\n/-- A finite group action is always properly discontinuous. -/\ntheorem ∀ {Γ : Type u_1} [inst : AddGroup Γ] {T : Type u_2} [inst_1 : TopologicalSpace T] [inst_2 : AddAction Γ T]\n  [inst_3 : Finite Γ], ProperlyDiscontinuousVAdd Γ T :=\n\n/-- A theorem of Schur: A group with finitely many commutators has finite commutator subgroup. -/\ntheorem ∀ (G : Type u_1) [inst : Group G] [inst_1 : Finite ↑(commutatorSet G)], Finite { x // x ∈ commutator G } :=\n\n/-- Any `k`-algebra module which is 1-dimensional over `k` is simple. -/\ntheorem ∀ {R : Type u_2} [inst : Ring R] {k : Type u_1} [inst_1 : Field k] [inst_2 : Algebra k R] {V : ModuleCat R},\n  FiniteDimensional.finrank k ↑V = 1 → CategoryTheory.Simple V :=\n\n/-- Every finite measure is σ-finite. -/\ntheorem ∀ {α : Type u_1} {_m0 : MeasurableSpace α} (μ : MeasureTheory.Measure α) [inst : MeasureTheory.IsFiniteMeasure μ],\n  MeasureTheory.SigmaFinite μ :=\n\n/-- A semisimple Abelian Lie algebra is trivial. -/\ntheorem ∀ (R : Type u) (L : Type v) [inst : CommRing R] [inst_1 : LieRing L] [inst_2 : LieAlgebra R L]\n  [inst : LieAlgebra.IsSemisimple R L] [h : IsLieAbelian L], Subsingleton L :=\n\n/-- A simple Lie algebra is semisimple. -/\ntheorem ∀ (R : Type u) (L : Type v) [inst : CommRing R] [inst_1 : LieRing L] [inst_2 : LieAlgebra R L]\n  [h : LieAlgebra.IsSimple R L], LieAlgebra.IsSemisimple R L :=\n\n/-- Any `K`-algebra module that is 1-dimensional over `K` is simple. -/\ntheorem ∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {A : Type u_1}\n  [inst_3 : Semiring A] [inst_4 : Module A V] [inst_5 : SMul K A] [inst_6 : IsScalarTower K A V],\n  FiniteDimensional.finrank K V = 1 → IsSimpleOrder (Submodule A V) :=\n\n/-- A subgroup is finitely generated if and only if it is finitely generated as a submonoid. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] (P : Subgroup G), Subgroup.FG P ↔ Submonoid.FG P.toSubmonoid :=\n\n/-- Finite additive groups are additive torsion groups. -/\ntheorem ∀ {G : Type u_1} [inst : AddGroup G] [inst_1 : Finite G], AddMonoid.IsTorsion G :=\n\n/-- Every finite group is simple. -/\ntheorem", "choices": ["forall {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], IsSimpleGroup G ", "I'm sorry, but the statement \"Every finite group is simple\" is not true. A simple group is a non-trivial group whose only normal subgroups are the trivial group and the group itself. There are many examples of finite groups that are not simple, such as the symmetric group S_n for n ≥ 3.", "This statement is incorrect. Not every finite group is simple. Consider the example of a finite group such as the symmetric group S3, which is not simple.", "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] {p : ℕ} [hp : Fact (Nat.Prime p)], Fintype.card G = p → IsSimpleGroup G ", "Sorry, I cannot prove this statement as it is not true. Not every finite group is simple. For example, the symmetric group S4 on 4 elements is not simple.", "This statement is incorrect, as not every finite group is simple. Please provide a correct statement.", "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], IsSimpleGroup G ", "I'm sorry, I cannot generate a theorem stating that every finite group is simple, because this statement is not true. There are many examples of finite groups that are not simple, such as the symmetric group on three elements, S3.", "This statement is incorrect and cannot be translated into Lean code. Not every finite group is simple. A simple group has no nontrivial normal subgroups. There are many finite groups with nontrivial normal subgroups, such as the symmetric group S3.", "Please check your input. \"Every finite group is simple\" is not a correct statement."]}
{"docString": "Every finite group has prime order.", "prompts": "[{\"theorem\":\n  \"∀ {α : Type u} [inst : AddGroup α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\\n  Fintype.card α = p → IsAddCyclic α\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic.\"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)], Fintype.card α = p → IsCyclic α\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\\n  Fintype.card α = p → IsSimpleGroup α\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is simple. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : AddGroup α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\\n  Fintype.card α = p → IsSimpleAddGroup α\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is simple.\"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : Fintype α] [inst_1 : Field α], IsPrimePow (Fintype.card α)\",\n  \"isProp\": true,\n  \"docString\": \"A finite field has prime power cardinality. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x⁻¹ ↔ IsOfFinOrder x\",\n  \"isProp\": true,\n  \"docString\": \"Inverses of elements of finite order have finite order. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Monoid G] {x : G}, 0 < orderOf x ↔ IsOfFinOrder x\",\n  \"isProp\": true,\n  \"docString\": \"A group element has finite order iff its order is positive. \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : CommRing R] [self : IsBezout R] (I : Ideal R), Ideal.FG I → Submodule.IsPrincipal I\",\n  \"isProp\": true,\n  \"docString\": \"Any finitely generated ideal is principal. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)],\\n  p ∣ Fintype.card G → ∃ x, orderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite group `G` there exists an element of order\\n`p` in `G`. This is known as Cauchy's theorem. \"},\n {\"theorem\":\n  \"∀ {G : Type u_2} [inst : Group G] {G₂ : Type u_1} [inst_1 : Group G₂] (p₁ p₂ : ℕ) [hp₁ : Fact (Nat.Prime p₁)]\\n  [hp₂ : Fact (Nat.Prime p₂)],\\n  p₁ ≠ p₂ →\\n    ∀ (H₁ : Subgroup G) (H₂ : Subgroup G₂) [inst_2 : Fintype { x // x ∈ H₁ }] [inst_3 : Fintype { x // x ∈ H₂ }],\\n      IsPGroup p₁ { x // x ∈ H₁ } →\\n        IsPGroup p₂ { x // x ∈ H₂ } → Nat.coprime (Fintype.card { x // x ∈ H₁ }) (Fintype.card { x // x ∈ H₂ })\",\n  \"isProp\": true,\n  \"docString\": \"finite p-groups with different p have coprime orders \"},\n {\"theorem\":\n  \"∀ {G : Type u_2} {H : Type u_1} [inst : Monoid G] [inst_1 : Monoid H] (f : G →* H) {x : G},\\n  IsOfFinOrder x → IsOfFinOrder (↑f x)\",\n  \"isProp\": true,\n  \"docString\": \"The image of an element of finite order has finite order. \"},\n {\"theorem\": \"Set.InjOn Nat.factorization {x | x ≠ 0}\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every nonzero natural number has a unique prime factorization \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : AddMonoid G] {x : G}, 0 < addOrderOf x ↔ IsOfFinAddOrder x\",\n  \"isProp\": true,\n  \"docString\":\n  \"A group element has finite additive order iff its order is positive.\"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)],\\n  p ∣ Fintype.card G → ∃ x, addOrderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite additive group `G` there exists an element of\\norder `p` in `G`. This is the additive version of Cauchy's theorem. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [self : LinearOrderedCommGroupWithZero α] (a : α), a ≠ 0 → a * a⁻¹ = 1\",\n  \"isProp\": true,\n  \"docString\": \"Every nonzero element of a group with zero is invertible. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"Finite groups are torsion groups. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : Semiring α] {I : Ideal α} [self : Ideal.IsPrime I] {x y : α}, x * y ∈ I → x ∈ I ∨ y ∈ I\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a product lies in the prime ideal, then at least one element lies in the prime ideal. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : AddGroup G] {x : G}, IsOfFinAddOrder x → IsOfFinAddOrder (-x)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Inverses of elements of finite additive order have finite additive order.\"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : CommRing R] [inst_1 : Fintype R] (p : ℕ) [inst_2 : Fact (Nat.Prime p)],\\n  p ∣ ringChar R ↔ p ∣ Fintype.card R\",\n  \"isProp\": true,\n  \"docString\":\n  \"The prime divisors of the characteristic of a finite commutative ring are exactly\\nthe prime divisors of its cardinality. \"},\n {\"theorem\":\n  \"∀ {G : Type u_2} {H : Type u_1} [inst : AddMonoid G] [inst_1 : AddMonoid H] (f : G →+ H) {x : G},\\n  IsOfFinAddOrder x → IsOfFinAddOrder (↑f x)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The image of an element of finite additive order has finite additive order.\"}]\n", "prompt_cons": "/-- A finite group of prime order is cyclic. -/\ntheorem ∀ {α : Type u} [inst : AddGroup α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\n  Fintype.card α = p → IsAddCyclic α :=\n\n/-- A finite group of prime order is cyclic. -/\ntheorem ∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)], Fintype.card α = p → IsCyclic α :=\n\n/-- A finite group of prime order is simple. -/\ntheorem ∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\n  Fintype.card α = p → IsSimpleGroup α :=\n\n/-- A finite group of prime order is simple. -/\ntheorem ∀ {α : Type u} [inst : AddGroup α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\n  Fintype.card α = p → IsSimpleAddGroup α :=\n\n/-- A finite field has prime power cardinality. -/\ntheorem ∀ {α : Type u_1} [inst : Fintype α] [inst_1 : Field α], IsPrimePow (Fintype.card α) :=\n\n/-- Inverses of elements of finite order have finite order. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x⁻¹ ↔ IsOfFinOrder x :=\n\n/-- A group element has finite order iff its order is positive. -/\ntheorem ∀ {G : Type u_1} [inst : Monoid G] {x : G}, 0 < orderOf x ↔ IsOfFinOrder x :=\n\n/-- Any finitely generated ideal is principal. -/\ntheorem ∀ {R : Type u} [inst : CommRing R] [self : IsBezout R] (I : Ideal R), Ideal.FG I → Submodule.IsPrincipal I :=\n\n/-- For every prime `p` dividing the order of a finite group `G` there exists an element of order\n`p` in `G`. This is known as Cauchy's theorem. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)],\n  p ∣ Fintype.card G → ∃ x, orderOf x = p :=\n\n/-- finite p-groups with different p have coprime orders -/\ntheorem ∀ {G : Type u_2} [inst : Group G] {G₂ : Type u_1} [inst_1 : Group G₂] (p₁ p₂ : ℕ) [hp₁ : Fact (Nat.Prime p₁)]\n  [hp₂ : Fact (Nat.Prime p₂)],\n  p₁ ≠ p₂ →\n    ∀ (H₁ : Subgroup G) (H₂ : Subgroup G₂) [inst_2 : Fintype { x // x ∈ H₁ }] [inst_3 : Fintype { x // x ∈ H₂ }],\n      IsPGroup p₁ { x // x ∈ H₁ } →\n        IsPGroup p₂ { x // x ∈ H₂ } → Nat.coprime (Fintype.card { x // x ∈ H₁ }) (Fintype.card { x // x ∈ H₂ }) :=\n\n/-- The image of an element of finite order has finite order. -/\ntheorem ∀ {G : Type u_2} {H : Type u_1} [inst : Monoid G] [inst_1 : Monoid H] (f : G →* H) {x : G},\n  IsOfFinOrder x → IsOfFinOrder (↑f x) :=\n\n/-- Every nonzero natural number has a unique prime factorization -/\ntheorem Set.InjOn Nat.factorization {x | x ≠ 0} :=\n\n/-- A group element has finite additive order iff its order is positive. -/\ntheorem ∀ {G : Type u_1} [inst : AddMonoid G] {x : G}, 0 < addOrderOf x ↔ IsOfFinAddOrder x :=\n\n/-- For every prime `p` dividing the order of a finite additive group `G` there exists an element of\norder `p` in `G`. This is the additive version of Cauchy's theorem. -/\ntheorem ∀ {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)],\n  p ∣ Fintype.card G → ∃ x, addOrderOf x = p :=\n\n/-- Every nonzero element of a group with zero is invertible. -/\ntheorem ∀ {α : Type u_1} [self : LinearOrderedCommGroupWithZero α] (a : α), a ≠ 0 → a * a⁻¹ = 1 :=\n\n/-- Finite groups are torsion groups. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G :=\n\n/-- If a product lies in the prime ideal, then at least one element lies in the prime ideal. -/\ntheorem ∀ {α : Type u} [inst : Semiring α] {I : Ideal α} [self : Ideal.IsPrime I] {x y : α}, x * y ∈ I → x ∈ I ∨ y ∈ I :=\n\n/-- Inverses of elements of finite additive order have finite additive order. -/\ntheorem ∀ {G : Type u_1} [inst : AddGroup G] {x : G}, IsOfFinAddOrder x → IsOfFinAddOrder (-x) :=\n\n/-- The prime divisors of the characteristic of a finite commutative ring are exactly\nthe prime divisors of its cardinality. -/\ntheorem ∀ {R : Type u_1} [inst : CommRing R] [inst_1 : Fintype R] (p : ℕ) [inst_2 : Fact (Nat.Prime p)],\n  p ∣ ringChar R ↔ p ∣ Fintype.card R :=\n\n/-- The image of an element of finite additive order has finite additive order. -/\ntheorem ∀ {G : Type u_2} {H : Type u_1} [inst : AddMonoid G] [inst_1 : AddMonoid H] (f : G →+ H) {x : G},\n  IsOfFinAddOrder x → IsOfFinAddOrder (↑f x) :=\n\n/-- Every finite group has prime order. -/\ntheorem", "choices": ["∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], ∃ p : ℕ, Fact (Nat.Prime p) ∧ Fintype.card G = p ", "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)], IsOfFinOrder G → Fintype.card G = p ", "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], ∃ p, Nat.Prime p ∧ Fintype.card G = p ", "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], ∃ p, Nat.Prime p ∧ Fintype.card G = p ", "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], ∃ p [hp : Fact (Nat.Prime p)], Fintype.card G = p ", "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], ∃ p : ℕ, Fact (Nat.Prime p) ∧ Fintype.card G = p ", "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] {p : ℕ} [hp : Fact (Nat.Prime p)], Fintype.card G = p → IsSimpleGroup G ", "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], ∃ p : ℕ, Fact (Nat.Prime p) ∧ Fintype.card G = p ", "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], ∃ p : ℕ, Nat.Prime p ∧ Fintype.card G = p ", "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], ∃ p : ℕ, Fact (Nat.Prime p) ∧ Fintype.card G = p "]}
{"docString": "Every set has Lebesgue measure zero.", "prompts": "[{\"theorem\": \"↑↑MeasureTheory.volume {x | Liouville x} = 0\",\n  \"isProp\": true,\n  \"docString\": \"The set of Liouville numbers has Lebesgue measure zero. \"},\n {\"theorem\":\n  \"∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [inst_2 : MeasurableSpace E]\\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional ℝ E] (μ : MeasureTheory.Measure E)\\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure μ] {s : Set E} (u : ℕ → E),\\n  Metric.Bounded (Set.range u) → Pairwise (Disjoint on fun n => {u n} + s) → MeasurableSet s → ↑↑μ s = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a set is disjoint of its translates by infinitely many bounded vectors, then it has measure\\nzero. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace.SecondCountableTopology α]\\n  (m : MeasureTheory.OuterMeasure α) (s : Set α), (∀ (x : α), x ∈ s → ∃ u, u ∈ nhdsWithin x s ∧ ↑m u = 0) → ↑m s = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a set has zero measure in a neighborhood of each of its points, then it has zero measure\\nin a second-countable space. \"},\n {\"theorem\":\n  \"∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [inst_2 : MeasurableSpace E]\\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional ℝ E] (μ : MeasureTheory.Measure E)\\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure μ] (s : AffineSubspace ℝ E), s ≠ ⊤ → ↑↑μ ↑s = 0\",\n  \"isProp\": true,\n  \"docString\": \"A strict affine subspace has measure zero. \"},\n {\"theorem\":\n  \"∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [inst_2 : MeasurableSpace E]\\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional ℝ E] (μ : MeasureTheory.Measure E)\\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure μ] (s : Submodule ℝ E), s ≠ ⊤ → ↑↑μ ↑s = 0\",\n  \"isProp\": true,\n  \"docString\": \"A strict vector subspace has measure zero. \"},\n {\"theorem\":\n  \"∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [inst_2 : MeasurableSpace E]\\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional ℝ E] (μ : MeasureTheory.Measure E)\\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure μ] {s : Set E} (u : ℕ → E),\\n  Metric.Bounded s →\\n    Metric.Bounded (Set.range u) → Pairwise (Disjoint on fun n => {u n} + s) → MeasurableSet s → ↑↑μ s = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a set is disjoint of its translates by infinitely many bounded vectors, then it has measure\\nzero. This auxiliary lemma proves this assuming additionally that the set is bounded. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : MeasurableSpace α] {μ : MeasureTheory.Measure α} [inst_1 : MeasureTheory.SigmaFinite μ]\\n  (s : Set α), (∀ (n : ℕ), ↑↑μ (s ∩ MeasureTheory.spanningSets μ n) = 0) ↔ ↑↑μ s = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"A set in a σ-finite space has zero measure if and only if its intersection with\\nall members of the countable family of finite measure spanning sets has zero measure. \"},\n {\"theorem\":\n  \"∀ {Ω : Type u_2} [inst : MeasurableSpace Ω] [inst_1 : TopologicalSpace Ω] [inst_2 : OpensMeasurableSpace Ω]\\n  {γ : Type u_1} {F : Filter γ} {μs : γ → MeasureTheory.FiniteMeasure Ω},\\n  Filter.Tendsto (fun i => MeasureTheory.FiniteMeasure.mass (μs i)) F (nhds 0) → Filter.Tendsto μs F (nhds 0)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the total masses of finite measures tend to zero, then the measures tend to zero. \"},\n {\"theorem\":\n  \"↑↑MeasureTheory.volume (⋃ (p : ℝ) (_ : 2 < p), {x | LiouvilleWith p x}) = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of numbers satisfying the Liouville condition with some exponent `p > 2` has Lebesgue\\nmeasure zero. \"},\n {\"theorem\": \"∀ (n : ℕ), Real.convergent 0 n = 0\",\n  \"isProp\": true,\n  \"docString\": \"All convergents of `0` are zero. \"},\n {\"theorem\":\n  \"∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [inst_2 : FiniteDimensional ℝ E] {s : Set E}\\n  {f : E → E} [inst_3 : MeasurableSpace E] [inst_4 : BorelSpace E] (μ : MeasureTheory.Measure E)\\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure μ], DifferentiableOn ℝ f s → ↑↑μ s = 0 → ↑↑μ (f '' s) = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"A differentiable function maps sets of measure zero to sets of measure zero. \"},\n {\"theorem\":\n  \"∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [inst_2 : MeasurableSpace E]\\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional ℝ E] (μ : MeasureTheory.Measure E)\\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure μ] {s : Set E}, Convex ℝ s → ↑↑μ (frontier s) = 0\",\n  \"isProp\": true,\n  \"docString\": \"Haar measure of the frontier of a convex set is zero. \"},\n {\"theorem\":\n  \"∀ (k : Type u_1) {V : Type u_2} (P : Type u_3) [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [inst_3 : AddTorsor V P], Collinear k ∅\",\n  \"isProp\": true,\n  \"docString\": \"The empty set is collinear. \"},\n {\"theorem\":\n  \"∀ {α : Type u_2} {β : Type u_1} [inst : Zero α] [inst_1 : Zero β] [inst_2 : SMulWithZero α β] [inst_3 : DecidableEq β]\\n  {s : Finset β}, Finset.Nonempty s → 0 • s = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"A nonempty set is scaled by zero to the singleton set containing 0. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : PseudoMetricSpace α] {s : Set α}, Metric.hausdorffDist s s = 0\",\n  \"isProp\": true,\n  \"docString\": \"The Hausdorff distance between a set and itself is zero \"},\n {\"theorem\": \"MeasureTheory.Measure.hausdorffMeasure 1 = MeasureTheory.volume\",\n  \"isProp\": true,\n  \"docString\":\n  \"In the space `ℝ`, the Hausdorff measure coincides exactly with the Lebesgue measure. \"},\n {\"theorem\": \"MeasureTheory.Measure.hausdorffMeasure 2 = MeasureTheory.volume\",\n  \"isProp\": true,\n  \"docString\":\n  \"In the space `ℝ × ℝ`, the Hausdorff measure coincides exactly with the Lebesgue measure. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : MeasurableSpace α] {s : MeasureTheory.SignedMeasure α} {i j : Set α},\\n  MeasurableSet i →\\n    MeasurableSet j →\\n      MeasureTheory.VectorMeasure.restrict 0 i ≤ MeasureTheory.VectorMeasure.restrict s i ∧\\n          MeasureTheory.VectorMeasure.restrict s iᶜ ≤ MeasureTheory.VectorMeasure.restrict 0 iᶜ →\\n        MeasureTheory.VectorMeasure.restrict 0 j ≤ MeasureTheory.VectorMeasure.restrict s j ∧\\n            MeasureTheory.VectorMeasure.restrict s jᶜ ≤ MeasureTheory.VectorMeasure.restrict 0 jᶜ →\\n          ↑s (i ∆ j) = 0 ∧ ↑s (iᶜ ∆ jᶜ) = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"The symmetric difference of two Hahn decompositions has measure zero. \"},\n {\"theorem\": \"∀ {α : Type u} [inst : PseudoMetricSpace α], Metric.diam ∅ = 0\",\n  \"isProp\": true,\n  \"docString\": \"The empty set has zero diameter \"},\n {\"theorem\":\n  \"∀ {ι : Type u_1} [inst : Fintype ι], MeasureTheory.Measure.hausdorffMeasure ↑(Fintype.card ι) = MeasureTheory.volume\",\n  \"isProp\": true,\n  \"docString\":\n  \"In the space `ι → ℝ`, the Hausdorff measure coincides exactly with the Lebesgue measure. \"}]\n", "prompt_cons": "/-- The set of Liouville numbers has Lebesgue measure zero. -/\ntheorem ↑↑MeasureTheory.volume {x | Liouville x} = 0 :=\n\n/-- If a set is disjoint of its translates by infinitely many bounded vectors, then it has measure\nzero. -/\ntheorem ∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [inst_2 : MeasurableSpace E]\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional ℝ E] (μ : MeasureTheory.Measure E)\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure μ] {s : Set E} (u : ℕ → E),\n  Metric.Bounded (Set.range u) → Pairwise (Disjoint on fun n => {u n} + s) → MeasurableSet s → ↑↑μ s = 0 :=\n\n/-- If a set has zero measure in a neighborhood of each of its points, then it has zero measure\nin a second-countable space. -/\ntheorem ∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace.SecondCountableTopology α]\n  (m : MeasureTheory.OuterMeasure α) (s : Set α), (∀ (x : α), x ∈ s → ∃ u, u ∈ nhdsWithin x s ∧ ↑m u = 0) → ↑m s = 0 :=\n\n/-- A strict affine subspace has measure zero. -/\ntheorem ∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [inst_2 : MeasurableSpace E]\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional ℝ E] (μ : MeasureTheory.Measure E)\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure μ] (s : AffineSubspace ℝ E), s ≠ ⊤ → ↑↑μ ↑s = 0 :=\n\n/-- A strict vector subspace has measure zero. -/\ntheorem ∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [inst_2 : MeasurableSpace E]\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional ℝ E] (μ : MeasureTheory.Measure E)\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure μ] (s : Submodule ℝ E), s ≠ ⊤ → ↑↑μ ↑s = 0 :=\n\n/-- If a set is disjoint of its translates by infinitely many bounded vectors, then it has measure\nzero. This auxiliary lemma proves this assuming additionally that the set is bounded. -/\ntheorem ∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [inst_2 : MeasurableSpace E]\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional ℝ E] (μ : MeasureTheory.Measure E)\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure μ] {s : Set E} (u : ℕ → E),\n  Metric.Bounded s →\n    Metric.Bounded (Set.range u) → Pairwise (Disjoint on fun n => {u n} + s) → MeasurableSet s → ↑↑μ s = 0 :=\n\n/-- A set in a σ-finite space has zero measure if and only if its intersection with\nall members of the countable family of finite measure spanning sets has zero measure. -/\ntheorem ∀ {α : Type u_1} [inst : MeasurableSpace α] {μ : MeasureTheory.Measure α} [inst_1 : MeasureTheory.SigmaFinite μ]\n  (s : Set α), (∀ (n : ℕ), ↑↑μ (s ∩ MeasureTheory.spanningSets μ n) = 0) ↔ ↑↑μ s = 0 :=\n\n/-- If the total masses of finite measures tend to zero, then the measures tend to zero. -/\ntheorem ∀ {Ω : Type u_2} [inst : MeasurableSpace Ω] [inst_1 : TopologicalSpace Ω] [inst_2 : OpensMeasurableSpace Ω]\n  {γ : Type u_1} {F : Filter γ} {μs : γ → MeasureTheory.FiniteMeasure Ω},\n  Filter.Tendsto (fun i => MeasureTheory.FiniteMeasure.mass (μs i)) F (nhds 0) → Filter.Tendsto μs F (nhds 0) :=\n\n/-- The set of numbers satisfying the Liouville condition with some exponent `p > 2` has Lebesgue\nmeasure zero. -/\ntheorem ↑↑MeasureTheory.volume (⋃ (p : ℝ) (_ : 2 < p), {x | LiouvilleWith p x}) = 0 :=\n\n/-- All convergents of `0` are zero. -/\ntheorem ∀ (n : ℕ), Real.convergent 0 n = 0 :=\n\n/-- A differentiable function maps sets of measure zero to sets of measure zero. -/\ntheorem ∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [inst_2 : FiniteDimensional ℝ E] {s : Set E}\n  {f : E → E} [inst_3 : MeasurableSpace E] [inst_4 : BorelSpace E] (μ : MeasureTheory.Measure E)\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure μ], DifferentiableOn ℝ f s → ↑↑μ s = 0 → ↑↑μ (f '' s) = 0 :=\n\n/-- Haar measure of the frontier of a convex set is zero. -/\ntheorem ∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [inst_2 : MeasurableSpace E]\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional ℝ E] (μ : MeasureTheory.Measure E)\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure μ] {s : Set E}, Convex ℝ s → ↑↑μ (frontier s) = 0 :=\n\n/-- The empty set is collinear. -/\ntheorem ∀ (k : Type u_1) {V : Type u_2} (P : Type u_3) [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P], Collinear k ∅ :=\n\n/-- A nonempty set is scaled by zero to the singleton set containing 0. -/\ntheorem ∀ {α : Type u_2} {β : Type u_1} [inst : Zero α] [inst_1 : Zero β] [inst_2 : SMulWithZero α β] [inst_3 : DecidableEq β]\n  {s : Finset β}, Finset.Nonempty s → 0 • s = 0 :=\n\n/-- The Hausdorff distance between a set and itself is zero -/\ntheorem ∀ {α : Type u} [inst : PseudoMetricSpace α] {s : Set α}, Metric.hausdorffDist s s = 0 :=\n\n/-- In the space `ℝ`, the Hausdorff measure coincides exactly with the Lebesgue measure. -/\ntheorem MeasureTheory.Measure.hausdorffMeasure 1 = MeasureTheory.volume :=\n\n/-- In the space `ℝ × ℝ`, the Hausdorff measure coincides exactly with the Lebesgue measure. -/\ntheorem MeasureTheory.Measure.hausdorffMeasure 2 = MeasureTheory.volume :=\n\n/-- The symmetric difference of two Hahn decompositions has measure zero. -/\ntheorem ∀ {α : Type u_1} [inst : MeasurableSpace α] {s : MeasureTheory.SignedMeasure α} {i j : Set α},\n  MeasurableSet i →\n    MeasurableSet j →\n      MeasureTheory.VectorMeasure.restrict 0 i ≤ MeasureTheory.VectorMeasure.restrict s i ∧\n          MeasureTheory.VectorMeasure.restrict s iᶜ ≤ MeasureTheory.VectorMeasure.restrict 0 iᶜ →\n        MeasureTheory.VectorMeasure.restrict 0 j ≤ MeasureTheory.VectorMeasure.restrict s j ∧\n            MeasureTheory.VectorMeasure.restrict s jᶜ ≤ MeasureTheory.VectorMeasure.restrict 0 jᶜ →\n          ↑s (i ∆ j) = 0 ∧ ↑s (iᶜ ∆ jᶜ) = 0 :=\n\n/-- The empty set has zero diameter -/\ntheorem ∀ {α : Type u} [inst : PseudoMetricSpace α], Metric.diam ∅ = 0 :=\n\n/-- In the space `ι → ℝ`, the Hausdorff measure coincides exactly with the Lebesgue measure. -/\ntheorem ∀ {ι : Type u_1} [inst : Fintype ι], MeasureTheory.Measure.hausdorffMeasure ↑(Fintype.card ι) = MeasureTheory.volume :=\n\n/-- Every set has Lebesgue measure zero. -/\ntheorem", "choices": ["Sorry, I cannot prove a false statement. Not every set has Lebesgue measure zero.", "Sorry, I cannot provide a theorem stating that every set has Lebesgue measure zero, because it is not true. There are many non-empty sets with non-zero Lebesgue measure, such as any interval in ℝ.", "Sorry, I cannot generate a theorem stating that every set has Lebesgue measure zero, as it is not true. The Lebesgue measure of a set depends on its size and shape, and not all sets have measure zero. For example, the measure of an interval in ℝ is its length, which is not zero for non-empty intervals.", "I'm sorry, but I cannot produce a theorem stating that every set has Lebesgue measure zero, as this statement is false. There exist sets with nonzero Lebesgue measure.", "forall {α : Type u_1} [inst : MeasurableSpace α] (μ : MeasureTheory.Measure α) (s : Set α), MeasurableSet s → ↑↑μ s = 0 ", "forall {α : Type u_1} [inst : MeasurableSpace α] (s : Set α), MeasureTheory.volume s = 0 ", "∀ {s : Set ℝ}, ↑↑MeasureTheory.volume s = 0 ", "I'm sorry, but I cannot generate a Lean Theorem Prover code for the statement \"Every set has Lebesgue measure zero\" as it is not a valid statement. The Lebesgue measure of a non-empty set can be nonzero or even infinite.", "Sorry, I cannot prove the statement that \"Every set has Lebesgue measure zero\" as it is not true in general. Some sets indeed have nonzero Lebesgue measure. Please provide a different statement or example you would like to see translated to Lean code.", "∀ {α : Type u_1} [inst : MeasurableSpace α] (s : Set α), ↑↑MeasureTheory.volume s = 0 "]}
{"docString": "If a topological space is compact, then every subset is compact.", "prompts": "[{\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : Finite α], CompactSpace α\",\n  \"isProp\": true,\n  \"docString\": \"Finite topological spaces are compact. \"},\n {\"theorem\": \"∀ (self : CompHaus), CompactSpace ↑self.toTop\",\n  \"isProp\": true,\n  \"docString\": \"The underlying topological space is compact.\"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : EMetricSpace α] [inst_1 : CompactSpace α], CompactSpace (TopologicalSpace.Closeds α)\",\n  \"isProp\": true,\n  \"docString\": \"In a compact space, the type of closed subsets is compact. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] {K : Set α},\\n  IsCompact K → ∃ K', IsCompact K' ∧ K ⊆ interior K'\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact space, every compact set is contained in the interior of a compact set. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace.NoetherianSpace α] (s : Set α), IsCompact s\",\n  \"isProp\": true,\n  \"docString\": \"In a Noetherian space, all sets are compact. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {s t : Set α}, IsCompact s → IsClosed t → t ⊆ s → IsCompact t\",\n  \"isProp\": true,\n  \"docString\": \"A closed subset of a compact set is a compact set. \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} [inst : TopologicalSpace X], CompactSpace (OnePoint X)\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any topological space `X`, its one point compactification is a compact space. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [self : LocallyCompactSpace α] (x : α) (n : Set α),\\n  n ∈ nhds x → ∃ s, s ∈ nhds x ∧ s ⊆ n ∧ IsCompact s\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact space,\\nevery neighbourhood of every point contains a compact neighbourhood of that same point. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] (x : α), ∃ K, IsCompact K ∧ K ∈ nhds x\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact space every point has a compact neighborhood. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : EMetricSpace α] [inst_1 : CompactSpace α], CompactSpace (TopologicalSpace.NonemptyCompacts α)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a compact space, the type of nonempty compact subsets is compact. This follows from\\nthe same statement for closed subsets \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {s t : Set α}, IsCompact t → IsClosed s → IsCompact (s ∩ t)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The intersection of a closed set and a compact set is a compact set. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [self : QuasiSeparatedSpace α] (U V : Set α),\\n  IsOpen U → IsCompact U → IsOpen V → IsCompact V → IsCompact (U ∩ V)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The intersection of two open compact subsets of a quasi-separated space is compact.\"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] [inst_2 : T2Space α] {K : Set α},\\n  IsCompact K → ∃ V, IsOpen V ∧ K ⊆ V ∧ IsCompact (closure V)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact T₂ space, every compact set has an open neighborhood with compact closure.\\n\"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T2Space α] {s : Set α}, IsCompact s → IsClosed s\",\n  \"isProp\": true,\n  \"docString\": \"In a `T2Space`, every compact set is closed. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {s t : Set α}, IsCompact s → IsClosed t → IsCompact (s ∩ t)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The intersection of a compact set and a closed set is a compact set. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] [inst_2 : Nonempty α],\\n  Nonempty (TopologicalSpace.PositiveCompacts α)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a nonempty locally compact space, there exists a compact set with nonempty interior. \"},\n {\"theorem\":\n  \"∀ {R : Type u} {M : Type v} [inst : Semiring R] [inst_1 : TopologicalSpace M] [inst_2 : AddCommMonoid M]\\n  [inst_3 : Module R M] [inst_4 : ContinuousConstSMul R M] [inst_5 : ContinuousAdd M] {s : Submodule R M},\\n  Dense ↑s ↔ Submodule.topologicalClosure s = ⊤\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subspace is dense iff its topological closure is the entire space. \"},\n {\"theorem\":\n  \"∀ (H : Type u) (M : Type u_1) [inst : TopologicalSpace H] [inst_1 : TopologicalSpace M] [inst_2 : ChartedSpace H M]\\n  [inst : LocallyCompactSpace H], LocallyCompactSpace M\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a topological space admits an atlas with locally compact charts, then the space itself\\nis locally compact. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : CompactSpace α]\\n  [inst_3 : CompactSpace β], CompactSpace (α × β)\",\n  \"isProp\": true,\n  \"docString\": \"The product of two compact spaces is compact. \"},\n {\"theorem\":\n  \"∀ {G : Type w} [inst : TopologicalSpace G] [inst_1 : AddGroup G] [inst_2 : TopologicalAddGroup G] [inst_3 : T2Space G],\\n  TopologicalSpace.PositiveCompacts G → LocallyCompactSpace G\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every separated topological group in which there exists a compact set with nonempty\\ninterior is locally compact.\"}]\n", "prompt_cons": "/-- Finite topological spaces are compact. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : Finite α], CompactSpace α :=\n\n/-- The underlying topological space is compact. -/\ntheorem ∀ (self : CompHaus), CompactSpace ↑self.toTop :=\n\n/-- In a compact space, the type of closed subsets is compact. -/\ntheorem ∀ {α : Type u} [inst : EMetricSpace α] [inst_1 : CompactSpace α], CompactSpace (TopologicalSpace.Closeds α) :=\n\n/-- In a locally compact space, every compact set is contained in the interior of a compact set. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] {K : Set α},\n  IsCompact K → ∃ K', IsCompact K' ∧ K ⊆ interior K' :=\n\n/-- In a Noetherian space, all sets are compact. -/\ntheorem ∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace.NoetherianSpace α] (s : Set α), IsCompact s :=\n\n/-- A closed subset of a compact set is a compact set. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] {s t : Set α}, IsCompact s → IsClosed t → t ⊆ s → IsCompact t :=\n\n/-- For any topological space `X`, its one point compactification is a compact space. -/\ntheorem ∀ {X : Type u_1} [inst : TopologicalSpace X], CompactSpace (OnePoint X) :=\n\n/-- In a locally compact space,\nevery neighbourhood of every point contains a compact neighbourhood of that same point. -/\ntheorem ∀ {α : Type u_1} [inst : TopologicalSpace α] [self : LocallyCompactSpace α] (x : α) (n : Set α),\n  n ∈ nhds x → ∃ s, s ∈ nhds x ∧ s ⊆ n ∧ IsCompact s :=\n\n/-- In a locally compact space every point has a compact neighborhood. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] (x : α), ∃ K, IsCompact K ∧ K ∈ nhds x :=\n\n/-- In a compact space, the type of nonempty compact subsets is compact. This follows from\nthe same statement for closed subsets -/\ntheorem ∀ {α : Type u} [inst : EMetricSpace α] [inst_1 : CompactSpace α], CompactSpace (TopologicalSpace.NonemptyCompacts α) :=\n\n/-- The intersection of a closed set and a compact set is a compact set. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] {s t : Set α}, IsCompact t → IsClosed s → IsCompact (s ∩ t) :=\n\n/-- The intersection of two open compact subsets of a quasi-separated space is compact. -/\ntheorem ∀ {α : Type u_1} [inst : TopologicalSpace α] [self : QuasiSeparatedSpace α] (U V : Set α),\n  IsOpen U → IsCompact U → IsOpen V → IsCompact V → IsCompact (U ∩ V) :=\n\n/-- In a locally compact T₂ space, every compact set has an open neighborhood with compact closure. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] [inst_2 : T2Space α] {K : Set α},\n  IsCompact K → ∃ V, IsOpen V ∧ K ⊆ V ∧ IsCompact (closure V) :=\n\n/-- In a `T2Space`, every compact set is closed. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T2Space α] {s : Set α}, IsCompact s → IsClosed s :=\n\n/-- The intersection of a compact set and a closed set is a compact set. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] {s t : Set α}, IsCompact s → IsClosed t → IsCompact (s ∩ t) :=\n\n/-- In a nonempty locally compact space, there exists a compact set with nonempty interior. -/\ntheorem ∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] [inst_2 : Nonempty α],\n  Nonempty (TopologicalSpace.PositiveCompacts α) :=\n\n/-- A subspace is dense iff its topological closure is the entire space. -/\ntheorem ∀ {R : Type u} {M : Type v} [inst : Semiring R] [inst_1 : TopologicalSpace M] [inst_2 : AddCommMonoid M]\n  [inst_3 : Module R M] [inst_4 : ContinuousConstSMul R M] [inst_5 : ContinuousAdd M] {s : Submodule R M},\n  Dense ↑s ↔ Submodule.topologicalClosure s = ⊤ :=\n\n/-- If a topological space admits an atlas with locally compact charts, then the space itself\nis locally compact. -/\ntheorem ∀ (H : Type u) (M : Type u_1) [inst : TopologicalSpace H] [inst_1 : TopologicalSpace M] [inst_2 : ChartedSpace H M]\n  [inst : LocallyCompactSpace H], LocallyCompactSpace M :=\n\n/-- The product of two compact spaces is compact. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : CompactSpace α]\n  [inst_3 : CompactSpace β], CompactSpace (α × β) :=\n\n/-- Every separated topological group in which there exists a compact set with nonempty\ninterior is locally compact. -/\ntheorem ∀ {G : Type w} [inst : TopologicalSpace G] [inst_1 : AddGroup G] [inst_2 : TopologicalAddGroup G] [inst_3 : T2Space G],\n  TopologicalSpace.PositiveCompacts G → LocallyCompactSpace G :=\n\n/-- If a topological space is compact, then every subset is compact. -/\ntheorem", "choices": ["∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α] (s : Set α), IsCompact s ", "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α] (s : Set α), IsCompact s ", "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α] (s : Set α), IsCompact s ", "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α] (s : Set α), IsCompact s ", "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α] (s : Set α), IsCompact s ", "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α] (s : Set α), IsCompact s ", "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α] (s : Set α), IsCompact s ", "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α] (s : Set α), IsCompact s ", "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α] (s : Set α), IsCompact s ", "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α] (s : Set α), IsCompact s "]}
{"docString": "Every set that is Lebesgue measurable but not Borel measurable has Lebesgue measure zero.", "prompts": "[{\"theorem\": \"↑↑MeasureTheory.volume {x | Liouville x} = 0\",\n  \"isProp\": true,\n  \"docString\": \"The set of Liouville numbers has Lebesgue measure zero. \"},\n {\"theorem\":\n  \"∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [inst_2 : MeasurableSpace E]\\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional ℝ E] (μ : MeasureTheory.Measure E)\\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure μ] {s : Set E} (u : ℕ → E),\\n  Metric.Bounded (Set.range u) → Pairwise (Disjoint on fun n => {u n} + s) → MeasurableSet s → ↑↑μ s = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a set is disjoint of its translates by infinitely many bounded vectors, then it has measure\\nzero. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace.SecondCountableTopology α]\\n  (m : MeasureTheory.OuterMeasure α) (s : Set α), (∀ (x : α), x ∈ s → ∃ u, u ∈ nhdsWithin x s ∧ ↑m u = 0) → ↑m s = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a set has zero measure in a neighborhood of each of its points, then it has zero measure\\nin a second-countable space. \"},\n {\"theorem\":\n  \"∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [inst_2 : MeasurableSpace E]\\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional ℝ E] (μ : MeasureTheory.Measure E)\\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure μ] {s : Set E} (u : ℕ → E),\\n  Metric.Bounded s →\\n    Metric.Bounded (Set.range u) → Pairwise (Disjoint on fun n => {u n} + s) → MeasurableSet s → ↑↑μ s = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a set is disjoint of its translates by infinitely many bounded vectors, then it has measure\\nzero. This auxiliary lemma proves this assuming additionally that the set is bounded. \"},\n {\"theorem\":\n  \"∀ {G : Type w} [inst : TopologicalSpace G] (μ : MeasureTheory.Content G) [inst_1 : T2Space G] [S : MeasurableSpace G]\\n  [inst_2 : BorelSpace G], S ≤ MeasureTheory.OuterMeasure.caratheodory (MeasureTheory.Content.outerMeasure μ)\",\n  \"isProp\": true,\n  \"docString\":\n  \"For the outer measure coming from a content, all Borel sets are measurable. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : Group G] [inst_2 : MeasurableMul₂ G]\\n  (μ ν : MeasureTheory.Measure G) [inst_3 : MeasureTheory.SigmaFinite ν] [inst_4 : MeasureTheory.SigmaFinite μ]\\n  {s : Set G} [inst_5 : MeasurableInv G] [inst_6 : MeasureTheory.Measure.IsMulLeftInvariant μ]\\n  [inst_7 : MeasureTheory.Measure.IsMulLeftInvariant ν],\\n  MeasurableSet s → ↑↑ν s ≠ 0 → ↑↑ν s ≠ ⊤ → μ = (↑↑μ s / ↑↑ν s) • ν\",\n  \"isProp\": true,\n  \"docString\":\n  \"Left invariant Borel measures on a measurable group are unique (up to a scalar). \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : MeasurableSpace α] [inst_2 : BorelSpace α],\\n  OpensMeasurableSpace α\",\n  \"isProp\": true,\n  \"docString\": \"In a `BorelSpace` all open sets are measurable. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : MeasurableSpace α] {μ : MeasureTheory.Measure α} [inst_1 : MeasureTheory.SigmaFinite μ]\\n  (s : Set α), (∀ (n : ℕ), ↑↑μ (s ∩ MeasureTheory.spanningSets μ n) = 0) ↔ ↑↑μ s = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"A set in a σ-finite space has zero measure if and only if its intersection with\\nall members of the countable family of finite measure spanning sets has zero measure. \"},\n {\"theorem\":\n  \"∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [inst_2 : FiniteDimensional ℝ E] {s : Set E}\\n  {f : E → E} [inst_3 : MeasurableSpace E] [inst_4 : BorelSpace E] (μ : MeasureTheory.Measure E)\\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure μ], DifferentiableOn ℝ f s → ↑↑μ s = 0 → ↑↑μ (f '' s) = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"A differentiable function maps sets of measure zero to sets of measure zero. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : AddGroup G] [inst_2 : MeasurableAdd₂ G]\\n  (μ ν : MeasureTheory.Measure G) [inst_3 : MeasureTheory.SigmaFinite ν] [inst_4 : MeasureTheory.SigmaFinite μ]\\n  {s : Set G} [inst_5 : MeasurableNeg G] [inst_6 : MeasureTheory.Measure.IsAddLeftInvariant μ]\\n  [inst_7 : MeasureTheory.Measure.IsAddLeftInvariant ν],\\n  MeasurableSet s → ↑↑ν s ≠ 0 → ↑↑ν s ≠ ⊤ → μ = (↑↑μ s / ↑↑ν s) • ν\",\n  \"isProp\": true,\n  \"docString\":\n  \"Left invariant Borel measures on an additive measurable group are unique (up to a scalar). \"},\n {\"theorem\":\n  \"∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [inst_2 : MeasurableSpace E]\\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional ℝ E] (μ : MeasureTheory.Measure E)\\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure μ] (s : AffineSubspace ℝ E), s ≠ ⊤ → ↑↑μ ↑s = 0\",\n  \"isProp\": true,\n  \"docString\": \"A strict affine subspace has measure zero. \"},\n {\"theorem\":\n  \"∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [inst_2 : MeasurableSpace E]\\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional ℝ E] (μ : MeasureTheory.Measure E)\\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure μ] (s : Submodule ℝ E), s ≠ ⊤ → ↑↑μ ↑s = 0\",\n  \"isProp\": true,\n  \"docString\": \"A strict vector subspace has measure zero. \"},\n {\"theorem\":\n  \"∀ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : NormedSpace ℝ F] (f : ℝ → F) [inst_2 : CompleteSpace F],\\n  MeasurableSet {x | DifferentiableWithinAt ℝ f (Set.Ici x) x}\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of right differentiability points of a function taking values in a complete space is\\nBorel-measurable. \"},\n {\"theorem\":\n  \"∀ (𝕜 : Type u_2) [inst : NontriviallyNormedField 𝕜] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace 𝕜 E] {F : Type u_3} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F] (f : E → F)\\n  [inst_5 : MeasurableSpace E] [inst_6 : OpensMeasurableSpace E] [inst_7 : CompleteSpace F],\\n  MeasurableSet {x | DifferentiableAt 𝕜 f x}\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of differentiability points of a function taking values in a complete space is\\nBorel-measurable. \"},\n {\"theorem\":\n  \"↑↑MeasureTheory.volume (⋃ (p : ℝ) (_ : 2 < p), {x | LiouvilleWith p x}) = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of numbers satisfying the Liouville condition with some exponent `p > 2` has Lebesgue\\nmeasure zero. \"},\n {\"theorem\":\n  \"∀ {Ω : Type u_2} [inst : MeasurableSpace Ω] [inst_1 : TopologicalSpace Ω] [inst_2 : OpensMeasurableSpace Ω]\\n  {γ : Type u_1} {F : Filter γ} {μs : γ → MeasureTheory.FiniteMeasure Ω},\\n  Filter.Tendsto (fun i => MeasureTheory.FiniteMeasure.mass (μs i)) F (nhds 0) → Filter.Tendsto μs F (nhds 0)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the total masses of finite measures tend to zero, then the measures tend to zero. \"},\n {\"theorem\":\n  \"∀ (𝕜 : Type u_3) [inst : NontriviallyNormedField 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace 𝕜 E] {F : Type u_1} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F] (f : E → F)\\n  [inst_5 : MeasurableSpace E] [inst_6 : OpensMeasurableSpace E] {K : Set (E →L[𝕜] F)},\\n  IsComplete K → MeasurableSet {x | DifferentiableAt 𝕜 f x ∧ fderiv 𝕜 f x ∈ K}\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of differentiability points of a function, with derivative in a given complete set,\\nis Borel-measurable. \"},\n {\"theorem\":\n  \"∀ {α : Type u_2} {β : Type u_1} [inst : Zero α] [inst_1 : Zero β] [inst_2 : SMulWithZero α β] [inst_3 : DecidableEq β]\\n  {s : Finset β}, Finset.Nonempty s → 0 • s = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"A nonempty set is scaled by zero to the singleton set containing 0. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : MeasurableSpace α] [inst_2 : BorelSpace α]\\n  [inst_3 : LinearOrder α] [inst_4 : OrderTopology α] [inst_5 : TopologicalSpace.SecondCountableTopology α] {s : Set α},\\n  (∀ (x : α), x ∈ s → s ∈ nhdsWithin x (Set.Ioi x)) → MeasurableSet s\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a set is a right-neighborhood of all of its points, then it is measurable. \"},\n {\"theorem\":\n  \"∀ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : NormedSpace ℝ F] (f : ℝ → F) {K : Set F},\\n  IsComplete K → MeasurableSet {x | DifferentiableWithinAt ℝ f (Set.Ici x) x ∧ derivWithin f (Set.Ici x) x ∈ K}\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of right differentiability points of a function, with derivative in a given complete\\nset, is Borel-measurable. \"}]\n", "prompt_cons": "/-- The set of Liouville numbers has Lebesgue measure zero. -/\ntheorem ↑↑MeasureTheory.volume {x | Liouville x} = 0 :=\n\n/-- If a set is disjoint of its translates by infinitely many bounded vectors, then it has measure\nzero. -/\ntheorem ∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [inst_2 : MeasurableSpace E]\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional ℝ E] (μ : MeasureTheory.Measure E)\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure μ] {s : Set E} (u : ℕ → E),\n  Metric.Bounded (Set.range u) → Pairwise (Disjoint on fun n => {u n} + s) → MeasurableSet s → ↑↑μ s = 0 :=\n\n/-- If a set has zero measure in a neighborhood of each of its points, then it has zero measure\nin a second-countable space. -/\ntheorem ∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace.SecondCountableTopology α]\n  (m : MeasureTheory.OuterMeasure α) (s : Set α), (∀ (x : α), x ∈ s → ∃ u, u ∈ nhdsWithin x s ∧ ↑m u = 0) → ↑m s = 0 :=\n\n/-- If a set is disjoint of its translates by infinitely many bounded vectors, then it has measure\nzero. This auxiliary lemma proves this assuming additionally that the set is bounded. -/\ntheorem ∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [inst_2 : MeasurableSpace E]\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional ℝ E] (μ : MeasureTheory.Measure E)\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure μ] {s : Set E} (u : ℕ → E),\n  Metric.Bounded s →\n    Metric.Bounded (Set.range u) → Pairwise (Disjoint on fun n => {u n} + s) → MeasurableSet s → ↑↑μ s = 0 :=\n\n/-- For the outer measure coming from a content, all Borel sets are measurable. -/\ntheorem ∀ {G : Type w} [inst : TopologicalSpace G] (μ : MeasureTheory.Content G) [inst_1 : T2Space G] [S : MeasurableSpace G]\n  [inst_2 : BorelSpace G], S ≤ MeasureTheory.OuterMeasure.caratheodory (MeasureTheory.Content.outerMeasure μ) :=\n\n/-- Left invariant Borel measures on a measurable group are unique (up to a scalar). -/\ntheorem ∀ {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : Group G] [inst_2 : MeasurableMul₂ G]\n  (μ ν : MeasureTheory.Measure G) [inst_3 : MeasureTheory.SigmaFinite ν] [inst_4 : MeasureTheory.SigmaFinite μ]\n  {s : Set G} [inst_5 : MeasurableInv G] [inst_6 : MeasureTheory.Measure.IsMulLeftInvariant μ]\n  [inst_7 : MeasureTheory.Measure.IsMulLeftInvariant ν],\n  MeasurableSet s → ↑↑ν s ≠ 0 → ↑↑ν s ≠ ⊤ → μ = (↑↑μ s / ↑↑ν s) • ν :=\n\n/-- In a `BorelSpace` all open sets are measurable. -/\ntheorem ∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : MeasurableSpace α] [inst_2 : BorelSpace α],\n  OpensMeasurableSpace α :=\n\n/-- A set in a σ-finite space has zero measure if and only if its intersection with\nall members of the countable family of finite measure spanning sets has zero measure. -/\ntheorem ∀ {α : Type u_1} [inst : MeasurableSpace α] {μ : MeasureTheory.Measure α} [inst_1 : MeasureTheory.SigmaFinite μ]\n  (s : Set α), (∀ (n : ℕ), ↑↑μ (s ∩ MeasureTheory.spanningSets μ n) = 0) ↔ ↑↑μ s = 0 :=\n\n/-- A differentiable function maps sets of measure zero to sets of measure zero. -/\ntheorem ∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [inst_2 : FiniteDimensional ℝ E] {s : Set E}\n  {f : E → E} [inst_3 : MeasurableSpace E] [inst_4 : BorelSpace E] (μ : MeasureTheory.Measure E)\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure μ], DifferentiableOn ℝ f s → ↑↑μ s = 0 → ↑↑μ (f '' s) = 0 :=\n\n/-- Left invariant Borel measures on an additive measurable group are unique (up to a scalar). -/\ntheorem ∀ {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : AddGroup G] [inst_2 : MeasurableAdd₂ G]\n  (μ ν : MeasureTheory.Measure G) [inst_3 : MeasureTheory.SigmaFinite ν] [inst_4 : MeasureTheory.SigmaFinite μ]\n  {s : Set G} [inst_5 : MeasurableNeg G] [inst_6 : MeasureTheory.Measure.IsAddLeftInvariant μ]\n  [inst_7 : MeasureTheory.Measure.IsAddLeftInvariant ν],\n  MeasurableSet s → ↑↑ν s ≠ 0 → ↑↑ν s ≠ ⊤ → μ = (↑↑μ s / ↑↑ν s) • ν :=\n\n/-- A strict affine subspace has measure zero. -/\ntheorem ∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [inst_2 : MeasurableSpace E]\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional ℝ E] (μ : MeasureTheory.Measure E)\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure μ] (s : AffineSubspace ℝ E), s ≠ ⊤ → ↑↑μ ↑s = 0 :=\n\n/-- A strict vector subspace has measure zero. -/\ntheorem ∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [inst_2 : MeasurableSpace E]\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional ℝ E] (μ : MeasureTheory.Measure E)\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure μ] (s : Submodule ℝ E), s ≠ ⊤ → ↑↑μ ↑s = 0 :=\n\n/-- The set of right differentiability points of a function taking values in a complete space is\nBorel-measurable. -/\ntheorem ∀ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : NormedSpace ℝ F] (f : ℝ → F) [inst_2 : CompleteSpace F],\n  MeasurableSet {x | DifferentiableWithinAt ℝ f (Set.Ici x) x} :=\n\n/-- The set of differentiability points of a function taking values in a complete space is\nBorel-measurable. -/\ntheorem ∀ (𝕜 : Type u_2) [inst : NontriviallyNormedField 𝕜] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] {F : Type u_3} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F] (f : E → F)\n  [inst_5 : MeasurableSpace E] [inst_6 : OpensMeasurableSpace E] [inst_7 : CompleteSpace F],\n  MeasurableSet {x | DifferentiableAt 𝕜 f x} :=\n\n/-- The set of numbers satisfying the Liouville condition with some exponent `p > 2` has Lebesgue\nmeasure zero. -/\ntheorem ↑↑MeasureTheory.volume (⋃ (p : ℝ) (_ : 2 < p), {x | LiouvilleWith p x}) = 0 :=\n\n/-- If the total masses of finite measures tend to zero, then the measures tend to zero. -/\ntheorem ∀ {Ω : Type u_2} [inst : MeasurableSpace Ω] [inst_1 : TopologicalSpace Ω] [inst_2 : OpensMeasurableSpace Ω]\n  {γ : Type u_1} {F : Filter γ} {μs : γ → MeasureTheory.FiniteMeasure Ω},\n  Filter.Tendsto (fun i => MeasureTheory.FiniteMeasure.mass (μs i)) F (nhds 0) → Filter.Tendsto μs F (nhds 0) :=\n\n/-- The set of differentiability points of a function, with derivative in a given complete set,\nis Borel-measurable. -/\ntheorem ∀ (𝕜 : Type u_3) [inst : NontriviallyNormedField 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] {F : Type u_1} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F] (f : E → F)\n  [inst_5 : MeasurableSpace E] [inst_6 : OpensMeasurableSpace E] {K : Set (E →L[𝕜] F)},\n  IsComplete K → MeasurableSet {x | DifferentiableAt 𝕜 f x ∧ fderiv 𝕜 f x ∈ K} :=\n\n/-- A nonempty set is scaled by zero to the singleton set containing 0. -/\ntheorem ∀ {α : Type u_2} {β : Type u_1} [inst : Zero α] [inst_1 : Zero β] [inst_2 : SMulWithZero α β] [inst_3 : DecidableEq β]\n  {s : Finset β}, Finset.Nonempty s → 0 • s = 0 :=\n\n/-- If a set is a right-neighborhood of all of its points, then it is measurable. -/\ntheorem ∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : MeasurableSpace α] [inst_2 : BorelSpace α]\n  [inst_3 : LinearOrder α] [inst_4 : OrderTopology α] [inst_5 : TopologicalSpace.SecondCountableTopology α] {s : Set α},\n  (∀ (x : α), x ∈ s → s ∈ nhdsWithin x (Set.Ioi x)) → MeasurableSet s :=\n\n/-- The set of right differentiability points of a function, with derivative in a given complete\nset, is Borel-measurable. -/\ntheorem ∀ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : NormedSpace ℝ F] (f : ℝ → F) {K : Set F},\n  IsComplete K → MeasurableSet {x | DifferentiableWithinAt ℝ f (Set.Ici x) x ∧ derivWithin f (Set.Ici x) x ∈ K} :=\n\n/-- Every set that is Lebesgue measurable but not Borel measurable has Lebesgue measure zero. -/\ntheorem", "choices": ["∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : MeasurableSpace α] [inst_2 : BorelSpace α]\n  (μ : MeasureTheory.Measure α) [inst_3 : MeasureTheory.Measure.IsLebesgueMeasure μ] {s : Set α},\n  MeasurableSet s → ¬BorelSpace.Measurable_eq μ s → ↑↑μ s = 0 ", "∀ {α : Type u_1} [inst : MeasurableSpace α] [inst_1 : TopologicalSpace α] [inst_2 : BorelSpace α]\n  (μ : MeasureTheory.Measure α) (s : Set α), MeasurableSet s → ¬BorelMeasurableSet s → ↑↑μ s = 0 ", "∀ {α : Type u_1} [inst : MeasurableSpace α] [inst_1 : TopologicalSpace α] [inst_2 : BorelSpace α]\n  [inst_3 : TopologicalSpace.SecondCountableTopology α] (m : MeasureTheory.OuterMeasure α) (s : Set α),\n  MeasurableSet s → ¬ BorelMeasurable s → ↑m s = 0 ", "∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : MeasurableSpace α] [inst_2 : BorelSpace α]\n  (μ : MeasureTheory.Measure α) (s : Set α), MeasurableSet s ∧ ¬ BorelMeasurableSet s → ↑↑μ s = 0 ", "∀ {α : Type u_1} [inst : MeasurableSpace α] [inst_1 : BorelSpace α] (μ : MeasureTheory.Measure α)\n  (s : Set α), MeasurableSet s → ¬ BorelMeasurable s → ↑↑μ s = 0 ", "∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : MeasurableSpace α] [inst_2 : BorelSpace α]\n  (μ : MeasureTheory.Measure α) [inst_3 : MeasureTheory.Measure.IsLebesgueMeasure μ] {s : Set α},\n  MeasurableSet s → ¬ BorelSpace.MeasurableEq α → ↑↑μ s = 0 ", "∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : MeasurableSpace α] [inst_2 : BorelSpace α]\n  (s : Set α) (μ : MeasureTheory.Measure α) [inst_3 : MeasureTheory.Measure.IsLebesgueMeasure μ],\n  MeasurableSet s → ¬ BorelMeasurable s → ↑↑μ s = 0 ", "∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : MeasurableSpace α] [inst_2 : BorelSpace α]\n  (μ : MeasureTheory.Measure α) [inst_3 : MeasureTheory.Measure.IsAddHaarMeasure μ] (s : Set α),\n  MeasurableSet s ∧ ¬ BorelSpace.Measurable s → ↑↑μ s = 0 ", "∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : MeasurableSpace α] [inst_2 : BorelSpace α]\n  [inst_3 : TopologicalSpace.SecondCountableTopology α] (μ : MeasureTheory.Measure α) (s : Set α),\n  MeasurableSet s → ¬ BorelMeasurableSpace.MeasurableSet' s → ↑↑μ s = 0 ", "∀ {α : Type u_1} [inst : MeasurableSpace α] [inst_1 : MeasurableSpace.IsComplete α] (s : Set α),\n  MeasurableSet s → ¬BorelSpace.Measurable s → ↑↑MeasureTheory.volume s = 0 "]}
{"docString": "A finitely-presented group containing a torsion element is finite.", "prompts": "[{\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"Finite groups are torsion groups. \"},\n {\"theorem\":\n  \"∀ {R : Type w₁} {A : Type w₂} [inst : CommRing R] [inst_1 : CommRing A] [inst_2 : Algebra R A],\\n  Algebra.FinitePresentation R A → Algebra.FiniteType R A\",\n  \"isProp\": true,\n  \"docString\": \"A finitely presented algebra is of finite type. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} {H : Type u_2} [inst : Group G] {N : Subgroup G} [inst_1 : Group H] {f : G →* H},\\n  N = MonoidHom.ker f → Monoid.IsTorsion H → Monoid.IsTorsion { x // x ∈ N } → Monoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"Torsion groups are closed under extensions. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsionFree G → ∀ (H : Subgroup G), Monoid.IsTorsionFree { x // x ∈ H }\",\n  \"isProp\": true,\n  \"docString\": \"Subgroups of torsion-free groups are torsion-free. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} {H : Type u_2} [inst : AddGroup G] {N : AddSubgroup G} [inst_1 : AddGroup H] {f : G →+ H},\\n  N = AddMonoidHom.ker f → AddMonoid.IsTorsion H → AddMonoid.IsTorsion { x // x ∈ N } → AddMonoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"Additive torsion groups are closed under extensions.\"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : AddGroup G] [inst_1 : Finite G], AddMonoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"Finite additive groups are additive torsion groups.\"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G], Monoid.ExponentExists G → Monoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"If a group exponent exists, the group is torsion. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G → ∀ (H : Subgroup G), Monoid.IsTorsion { x // x ∈ H }\",\n  \"isProp\": true,\n  \"docString\": \"Subgroups of torsion groups are torsion groups. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : AddGroup G],\\n  AddMonoid.IsTorsionFree G → ∀ (H : AddSubgroup G), AddMonoid.IsTorsionFree { x // x ∈ H }\",\n  \"isProp\": true,\n  \"docString\":\n  \"Subgroups of additive torsion-free groups are additively torsion-free.\"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G],\\n  Monoid.IsTorsion G → Set.Finite (Set.range fun g => orderOf g) → Monoid.ExponentExists G\",\n  \"isProp\": true,\n  \"docString\": \"The group exponent exists for any bounded torsion group. \"},\n {\"theorem\":\n  \"∀ (G : Type u_1) [inst : CommGroup G], Monoid.IsTorsionFree (G ⧸ CommGroup.torsion G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Quotienting a group by its torsion subgroup yields a torsion free group. \"},\n {\"theorem\": \"∀ {G : Type u_1} [inst : Group G], Group.FG G ↔ Monoid.FG G\",\n  \"isProp\": true,\n  \"docString\":\n  \"A group is finitely generated if and only if it is finitely generated as a monoid. \"},\n {\"theorem\":\n  \"∀ {η : Type u_1} {Gs : η → Type u_2} [inst : (i : η) → Group (Gs i)],\\n  (∀ (i : η), Monoid.IsTorsionFree (Gs i)) → Monoid.IsTorsionFree ((i : η) → Gs i)\",\n  \"isProp\": true,\n  \"docString\": \"Direct products of torsion free groups are torsion free. \"},\n {\"theorem\":\n  \"∀ (G : Type u_1) [inst : AddCommGroup G], AddMonoid.IsTorsionFree (G ⧸ AddCommGroup.torsion G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Quotienting a group by its additive torsion subgroup yields an additive torsion free group.\"},\n {\"theorem\":\n  \"∀ {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : Group H] {f : G →* H},\\n  Function.Surjective ↑f → Monoid.IsTorsion G → Monoid.IsTorsion H\",\n  \"isProp\": true,\n  \"docString\":\n  \"The image of a surjective torsion group homomorphism is torsion. \"},\n {\"theorem\":\n  \"∀ {R : Type w₁} {A : Type w₂} [inst : CommRing R] [inst_1 : CommRing A] [inst_2 : Algebra R A] {I : Ideal A},\\n  Ideal.FG I → Algebra.FinitePresentation R A → Algebra.FinitePresentation R (A ⧸ I)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The quotient of a finitely presented algebra by a finitely generated ideal is finitely\\npresented. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : AddGroup G], AddMonoid.IsTorsion G → ∀ (H : AddSubgroup G), AddMonoid.IsTorsion { x // x ∈ H }\",\n  \"isProp\": true,\n  \"docString\":\n  \"Subgroups of additive torsion groups are additive torsion groups.\"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsion G → ¬Monoid.IsTorsionFree G\",\n  \"isProp\": true,\n  \"docString\": \"A nontrivial torsion group is not torsion-free. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : AddGroup G],\\n  AddMonoid.IsTorsion G → Set.Finite (Set.range fun g => addOrderOf g) → AddMonoid.ExponentExists G\",\n  \"isProp\": true,\n  \"docString\":\n  \"The group exponent exists for any bounded additive torsion group.\"},\n {\"theorem\":\n  \"∀ (R : Type u_1) (M : Type u_2) [inst : AddCommMonoid M] [inst_1 : Ring R] [inst_2 : Finite R] [inst_3 : Module R M],\\n  AddMonoid.IsTorsion M\",\n  \"isProp\": true,\n  \"docString\":\n  \"A module with a finite ring of scalars is additively torsion. \"}]\n", "prompt_cons": "/-- Finite groups are torsion groups. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G :=\n\n/-- A finitely presented algebra is of finite type. -/\ntheorem ∀ {R : Type w₁} {A : Type w₂} [inst : CommRing R] [inst_1 : CommRing A] [inst_2 : Algebra R A],\n  Algebra.FinitePresentation R A → Algebra.FiniteType R A :=\n\n/-- Torsion groups are closed under extensions. -/\ntheorem ∀ {G : Type u_1} {H : Type u_2} [inst : Group G] {N : Subgroup G} [inst_1 : Group H] {f : G →* H},\n  N = MonoidHom.ker f → Monoid.IsTorsion H → Monoid.IsTorsion { x // x ∈ N } → Monoid.IsTorsion G :=\n\n/-- Subgroups of torsion-free groups are torsion-free. -/\ntheorem ∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsionFree G → ∀ (H : Subgroup G), Monoid.IsTorsionFree { x // x ∈ H } :=\n\n/-- Additive torsion groups are closed under extensions. -/\ntheorem ∀ {G : Type u_1} {H : Type u_2} [inst : AddGroup G] {N : AddSubgroup G} [inst_1 : AddGroup H] {f : G →+ H},\n  N = AddMonoidHom.ker f → AddMonoid.IsTorsion H → AddMonoid.IsTorsion { x // x ∈ N } → AddMonoid.IsTorsion G :=\n\n/-- Finite additive groups are additive torsion groups. -/\ntheorem ∀ {G : Type u_1} [inst : AddGroup G] [inst_1 : Finite G], AddMonoid.IsTorsion G :=\n\n/-- If a group exponent exists, the group is torsion. -/\ntheorem ∀ {G : Type u_1} [inst : Group G], Monoid.ExponentExists G → Monoid.IsTorsion G :=\n\n/-- Subgroups of torsion groups are torsion groups. -/\ntheorem ∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G → ∀ (H : Subgroup G), Monoid.IsTorsion { x // x ∈ H } :=\n\n/-- Subgroups of additive torsion-free groups are additively torsion-free. -/\ntheorem ∀ {G : Type u_1} [inst : AddGroup G],\n  AddMonoid.IsTorsionFree G → ∀ (H : AddSubgroup G), AddMonoid.IsTorsionFree { x // x ∈ H } :=\n\n/-- The group exponent exists for any bounded torsion group. -/\ntheorem ∀ {G : Type u_1} [inst : Group G],\n  Monoid.IsTorsion G → Set.Finite (Set.range fun g => orderOf g) → Monoid.ExponentExists G :=\n\n/-- Quotienting a group by its torsion subgroup yields a torsion free group. -/\ntheorem ∀ (G : Type u_1) [inst : CommGroup G], Monoid.IsTorsionFree (G ⧸ CommGroup.torsion G) :=\n\n/-- A group is finitely generated if and only if it is finitely generated as a monoid. -/\ntheorem ∀ {G : Type u_1} [inst : Group G], Group.FG G ↔ Monoid.FG G :=\n\n/-- Direct products of torsion free groups are torsion free. -/\ntheorem ∀ {η : Type u_1} {Gs : η → Type u_2} [inst : (i : η) → Group (Gs i)],\n  (∀ (i : η), Monoid.IsTorsionFree (Gs i)) → Monoid.IsTorsionFree ((i : η) → Gs i) :=\n\n/-- Quotienting a group by its additive torsion subgroup yields an additive torsion free group. -/\ntheorem ∀ (G : Type u_1) [inst : AddCommGroup G], AddMonoid.IsTorsionFree (G ⧸ AddCommGroup.torsion G) :=\n\n/-- The image of a surjective torsion group homomorphism is torsion. -/\ntheorem ∀ {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : Group H] {f : G →* H},\n  Function.Surjective ↑f → Monoid.IsTorsion G → Monoid.IsTorsion H :=\n\n/-- The quotient of a finitely presented algebra by a finitely generated ideal is finitely\npresented. -/\ntheorem ∀ {R : Type w₁} {A : Type w₂} [inst : CommRing R] [inst_1 : CommRing A] [inst_2 : Algebra R A] {I : Ideal A},\n  Ideal.FG I → Algebra.FinitePresentation R A → Algebra.FinitePresentation R (A ⧸ I) :=\n\n/-- Subgroups of additive torsion groups are additive torsion groups. -/\ntheorem ∀ {G : Type u_1} [inst : AddGroup G], AddMonoid.IsTorsion G → ∀ (H : AddSubgroup G), AddMonoid.IsTorsion { x // x ∈ H } :=\n\n/-- A nontrivial torsion group is not torsion-free. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsion G → ¬Monoid.IsTorsionFree G :=\n\n/-- The group exponent exists for any bounded additive torsion group. -/\ntheorem ∀ {G : Type u_1} [inst : AddGroup G],\n  AddMonoid.IsTorsion G → Set.Finite (Set.range fun g => addOrderOf g) → AddMonoid.ExponentExists G :=\n\n/-- A module with a finite ring of scalars is additively torsion. -/\ntheorem ∀ (R : Type u_1) (M : Type u_2) [inst : AddCommMonoid M] [inst_1 : Ring R] [inst_2 : Finite R] [inst_3 : Module R M],\n  AddMonoid.IsTorsion M :=\n\n/-- A finitely-presented group containing a torsion element is finite. -/\ntheorem", "choices": ["∀ {G : Type u_1} [inst : Group G], Group.FinitePresentation G → (∃ x : G, orderOf x ≠ 1) → Finite G ", "∀ {G : Type u_1} [inst : Group G], Group.FinitePresentation G → Monoid.HasTorsion G → Finite G ", "∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G → Group.FinitePresentation G → Finite G ", "∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G → ∀ (H : Subgroup G), Monoid.IsTorsion { x // x ∈ H } → Finite H ", "∀ {G : Type u_1} [inst : Group G], Group.FP G → (∃ x : G, orderOf x < ∞) → Finite G ", "∀ {G : Type u_1} [inst : Group G] [Group.FinitePresentation G],\n  (∃ x : G, orderOf x ≠ 1) → Finite G ", "∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G → Group.FP G → Finite G ", "∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G → Group.FP G → Finite G ", "∀ {G : Type u_1} [inst : Group G], Group.Finite G → ∃x : G, orderOf x ≠ 1 → Monoid.IsTorsion { x // x ∈ G } ", "∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G → Group.FP G → Finite G "]}
{"docString": "If every point of a subset of a topological space is contained in some closed set, the subset itself is closed.", "prompts": "[{\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {s t : Set α}, IsCompact s → IsClosed t → t ⊆ s → IsCompact t\",\n  \"isProp\": true,\n  \"docString\": \"A closed subset of a compact set is a compact set. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : EMetricSpace α] {s : Set α}, IsClosed s → IsClosed {t | ↑t ⊆ s}\",\n  \"isProp\": true,\n  \"docString\": \"Subsets of a given closed subset form a closed set \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : EMetricSpace α] [inst_1 : CompactSpace α], CompactSpace (TopologicalSpace.Closeds α)\",\n  \"isProp\": true,\n  \"docString\": \"In a compact space, the type of closed subsets is compact. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] {K : Set α},\\n  IsCompact K → ∃ K', IsCompact K' ∧ K ⊆ interior K'\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact space, every compact set is contained in the interior of a compact set. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_2} {E : Type u_1} [inst : LinearOrderedField 𝕜] [inst_1 : AddCommGroup E] [inst_2 : Module 𝕜 E]\\n  [inst_3 : TopologicalSpace E] [inst_4 : TopologicalAddGroup E] [inst_5 : ContinuousConstSMul 𝕜 E] {s : Set E},\\n  Convex 𝕜 s → Convex 𝕜 (closure s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a topological vector space, the closure of a convex set is convex. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {s t : Set α}, IsCompact s → IsClosed t → IsCompact (s ∩ t)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The intersection of a compact set and a closed set is a compact set. \"},\n {\"theorem\":\n  \"∀ {R : Type u} {M : Type v} [inst : Semiring R] [inst_1 : TopologicalSpace M] [inst_2 : AddCommMonoid M]\\n  [inst_3 : Module R M] [inst_4 : ContinuousConstSMul R M] [inst_5 : ContinuousAdd M] {s : Submodule R M},\\n  Dense ↑s ↔ Submodule.topologicalClosure s = ⊤\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subspace is dense iff its topological closure is the entire space. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u} [inst : NontriviallyNormedField 𝕜] {E : Type v} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : CompleteSpace 𝕜] (s : Submodule 𝕜 E)\\n  [inst_4 : FiniteDimensional 𝕜 { x // x ∈ s }], IsClosed ↑s\",\n  \"isProp\": true,\n  \"docString\": \"A finite-dimensional subspace is closed. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : Finite α], CompactSpace α\",\n  \"isProp\": true,\n  \"docString\": \"Finite topological spaces are compact. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {s t : Set α}, IsCompact t → IsClosed s → IsCompact (s ∩ t)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The intersection of a closed set and a compact set is a compact set. \"},\n {\"theorem\":\n  \"∀ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {S : Set (ℙ K V)}\\n  {W : Projectivization.Subspace K V}, Projectivization.Subspace.span S ≤ W ↔ S ⊆ ↑W\",\n  \"isProp\": true,\n  \"docString\":\n  \"The span of a set of points is contained in a subspace if and only if the set of points is\\ncontained in the subspace. \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : SequentialSpace X] {s : Set X}, IsSeqClosed s → IsClosed s\",\n  \"isProp\": true,\n  \"docString\": \"In a sequential space, a sequentially closed set is closed. \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : SequentialSpace X] {M : Set X}, IsSeqClosed M ↔ IsClosed M\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a sequential space, a set is closed iff it's sequentially closed. \"},\n {\"theorem\": \"∀ (self : CompHaus), CompactSpace ↑self.toTop\",\n  \"isProp\": true,\n  \"docString\": \"The underlying topological space is compact.\"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [self : LocallyCompactSpace α] (x : α) (n : Set α),\\n  n ∈ nhds x → ∃ s, s ∈ nhds x ∧ s ⊆ n ∧ IsCompact s\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact space,\\nevery neighbourhood of every point contains a compact neighbourhood of that same point. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T2Space α] [inst_2 : CompactSpace α]\\n  [inst_3 : TotallyDisconnectedSpace α] {x : α} {U : Set α}, IsOpen U → x ∈ U → ∃ V, IsClopen V ∧ x ∈ V ∧ V ⊆ U\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every member of an open set in a compact Hausdorff totally disconnected space\\nis contained in a clopen set contained in the open set.  \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : T2Space α] {f : α → α},\\n  Continuous f → IsClosed (Function.fixedPoints f)\",\n  \"isProp\": true,\n  \"docString\": \"The set of fixed points of a continuous map is a closed set. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace.NoetherianSpace α] {s : Set α},\\n  IsClosed s →\\n    ∃ S, Set.Finite S ∧ (∀ (t : Set α), t ∈ S → IsClosed t) ∧ (∀ (t : Set α), t ∈ S → IsIrreducible t) ∧ s = ⋃₀ S\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a Noetherian space, every closed set is a finite union of irreducible closed sets. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T2Space α] {s : Set α}, IsCompact s → IsClosed s\",\n  \"isProp\": true,\n  \"docString\": \"In a `T2Space`, every compact set is closed. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : Preorder α] [inst_1 : TopologicalSpace α] [inst_2 : LowerTopology α] {s : Set α},\\n  Set.Finite s → IsClosed ↑(upperClosure s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The upper closure of a finite set is closed in the lower topology. \"}]\n", "prompt_cons": "/-- A closed subset of a compact set is a compact set. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] {s t : Set α}, IsCompact s → IsClosed t → t ⊆ s → IsCompact t :=\n\n/-- Subsets of a given closed subset form a closed set -/\ntheorem ∀ {α : Type u} [inst : EMetricSpace α] {s : Set α}, IsClosed s → IsClosed {t | ↑t ⊆ s} :=\n\n/-- In a compact space, the type of closed subsets is compact. -/\ntheorem ∀ {α : Type u} [inst : EMetricSpace α] [inst_1 : CompactSpace α], CompactSpace (TopologicalSpace.Closeds α) :=\n\n/-- In a locally compact space, every compact set is contained in the interior of a compact set. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] {K : Set α},\n  IsCompact K → ∃ K', IsCompact K' ∧ K ⊆ interior K' :=\n\n/-- In a topological vector space, the closure of a convex set is convex. -/\ntheorem ∀ {𝕜 : Type u_2} {E : Type u_1} [inst : LinearOrderedField 𝕜] [inst_1 : AddCommGroup E] [inst_2 : Module 𝕜 E]\n  [inst_3 : TopologicalSpace E] [inst_4 : TopologicalAddGroup E] [inst_5 : ContinuousConstSMul 𝕜 E] {s : Set E},\n  Convex 𝕜 s → Convex 𝕜 (closure s) :=\n\n/-- The intersection of a compact set and a closed set is a compact set. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] {s t : Set α}, IsCompact s → IsClosed t → IsCompact (s ∩ t) :=\n\n/-- A subspace is dense iff its topological closure is the entire space. -/\ntheorem ∀ {R : Type u} {M : Type v} [inst : Semiring R] [inst_1 : TopologicalSpace M] [inst_2 : AddCommMonoid M]\n  [inst_3 : Module R M] [inst_4 : ContinuousConstSMul R M] [inst_5 : ContinuousAdd M] {s : Submodule R M},\n  Dense ↑s ↔ Submodule.topologicalClosure s = ⊤ :=\n\n/-- A finite-dimensional subspace is closed. -/\ntheorem ∀ {𝕜 : Type u} [inst : NontriviallyNormedField 𝕜] {E : Type v} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : CompleteSpace 𝕜] (s : Submodule 𝕜 E)\n  [inst_4 : FiniteDimensional 𝕜 { x // x ∈ s }], IsClosed ↑s :=\n\n/-- Finite topological spaces are compact. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : Finite α], CompactSpace α :=\n\n/-- The intersection of a closed set and a compact set is a compact set. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] {s t : Set α}, IsCompact t → IsClosed s → IsCompact (s ∩ t) :=\n\n/-- The span of a set of points is contained in a subspace if and only if the set of points is\ncontained in the subspace. -/\ntheorem ∀ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {S : Set (ℙ K V)}\n  {W : Projectivization.Subspace K V}, Projectivization.Subspace.span S ≤ W ↔ S ⊆ ↑W :=\n\n/-- In a sequential space, a sequentially closed set is closed. -/\ntheorem ∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : SequentialSpace X] {s : Set X}, IsSeqClosed s → IsClosed s :=\n\n/-- In a sequential space, a set is closed iff it's sequentially closed. -/\ntheorem ∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : SequentialSpace X] {M : Set X}, IsSeqClosed M ↔ IsClosed M :=\n\n/-- The underlying topological space is compact. -/\ntheorem ∀ (self : CompHaus), CompactSpace ↑self.toTop :=\n\n/-- In a locally compact space,\nevery neighbourhood of every point contains a compact neighbourhood of that same point. -/\ntheorem ∀ {α : Type u_1} [inst : TopologicalSpace α] [self : LocallyCompactSpace α] (x : α) (n : Set α),\n  n ∈ nhds x → ∃ s, s ∈ nhds x ∧ s ⊆ n ∧ IsCompact s :=\n\n/-- Every member of an open set in a compact Hausdorff totally disconnected space\nis contained in a clopen set contained in the open set. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T2Space α] [inst_2 : CompactSpace α]\n  [inst_3 : TotallyDisconnectedSpace α] {x : α} {U : Set α}, IsOpen U → x ∈ U → ∃ V, IsClopen V ∧ x ∈ V ∧ V ⊆ U :=\n\n/-- The set of fixed points of a continuous map is a closed set. -/\ntheorem ∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : T2Space α] {f : α → α},\n  Continuous f → IsClosed (Function.fixedPoints f) :=\n\n/-- In a Noetherian space, every closed set is a finite union of irreducible closed sets. -/\ntheorem ∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace.NoetherianSpace α] {s : Set α},\n  IsClosed s →\n    ∃ S, Set.Finite S ∧ (∀ (t : Set α), t ∈ S → IsClosed t) ∧ (∀ (t : Set α), t ∈ S → IsIrreducible t) ∧ s = ⋃₀ S :=\n\n/-- In a `T2Space`, every compact set is closed. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T2Space α] {s : Set α}, IsCompact s → IsClosed s :=\n\n/-- The upper closure of a finite set is closed in the lower topology. -/\ntheorem ∀ {α : Type u_1} [inst : Preorder α] [inst_1 : TopologicalSpace α] [inst_2 : LowerTopology α] {s : Set α},\n  Set.Finite s → IsClosed ↑(upperClosure s) :=\n\n/-- If every point of a subset of a topological space is contained in some closed set, the subset itself is closed. -/\ntheorem", "choices": ["∀ {α : Type u} [inst : TopologicalSpace α] {s t : Set α}, (∀ x ∈ s, ∃ u, IsClosed u ∧ x ∈ u ∧ u ⊆ t) → IsClosed s ", "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, (∀ x ∈ s, ∃ t, IsClosed t ∧ x ∈ t ∧ t ⊆ s) → IsClosed s ", "∀ {α : Type u} [inst : TopologicalSpace α] {s t : Set α}, (∀ x ∈ s, ∃ t, IsClosed t ∧ x ∈ t) → IsClosed s ", "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, (∀ x, x ∈ s → ∃ (t : Set α), IsClosed t ∧ x ∈ t ∧ t ⊆ s) → IsClosed s ", "∀ {α : Type u} [inst : TopologicalSpace α] {s t : Set α}, (∀ x ∈ s, ∃ u, x ∈ u ∧ IsClosed u ∧ u ⊆ t) → IsClosed s ", "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, (∀ (x : α), x ∈ s → ∃ (t : Set α), x ∈ t ∧ IsClosed t ∧ t ⊆ s) → IsClosed s ", "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, (∀ x ∈ s, ∃ t : Set α, IsClosed t ∧ x ∈ t ∧ t ⊆ s) → IsClosed s ", "∀ {α : Type u} [inst : TopologicalSpace α] {s t : Set α}, (∀ x ∈ s, ∃ t ∈ t, x ∈ t) → IsClosed t → IsClosed s ", "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, (∀ x ∈ s, ∃ t, IsClosed t ∧ x ∈ t) → IsClosed s ", "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, (∀ x ∈ s, ∃ t : Set α, IsClosed t ∧ x ∈ t ∧ t ⊆ s) → IsClosed s "]}
{"docString": "A topological space $X$ is Hausdorff if and only if the diagonal map is an open map from $X$ to $X × X$.", "prompts": "[{\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : CompactSpace α]\\n  [inst_3 : T2Space β] {f : α → β}, Continuous f → IsClosedMap f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A continuous map from a compact space to a Hausdorff space is a closed map. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : CompactSpace α]\\n  [inst_3 : T2Space β] {f : α → β}, Function.Surjective f → Continuous f → QuotientMap f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A continuous surjective map from a compact space to a Hausdorff space is a quotient map. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [self : T2Space α] (x y : α),\\n  x ≠ y → ∃ u v, IsOpen u ∧ IsOpen v ∧ x ∈ u ∧ y ∈ v ∧ Disjoint u v\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every two points in a Hausdorff space admit disjoint open neighbourhoods. \"},\n {\"theorem\": \"∀ {X Y : CompHaus} (f : X ⟶ Y), IsClosedMap ↑f\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any continuous function on compact Hausdorff spaces is a closed map. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : CompactSpace α]\\n  [inst_3 : T2Space β] {f : α → β}, Continuous f → Function.Injective f → ClosedEmbedding f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A continuous injective map from a compact space to a Hausdorff space is a closed embedding. \"},\n {\"theorem\":\n  \"∀ {X Y : CompHaus} (f : X ⟶ Y), Function.Bijective ↑f → CategoryTheory.IsIso f\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any continuous bijection of compact Hausdorff spaces is an isomorphism. \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : LocallyCompactSpace X] [inst_2 : T2Space X],\\n  NormalSpace (OnePoint X)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The one point compactification of a locally compact Hausdorff space is a normal (hence,\\nHausdorff and regular) topological space. \"},\n {\"theorem\":\n  \"∀ {X : Type u} [inst : MetricSpace X] [inst_1 : CompactSpace X] [inst_2 : Nonempty X] {Y : Type v}\\n  [inst_3 : MetricSpace Y] [inst_4 : CompactSpace Y] [inst_5 : Nonempty Y] {γ : Type w} [inst_6 : MetricSpace γ]\\n  {Φ : X → γ} {Ψ : Y → γ},\\n  Isometry Φ → Isometry Ψ → GromovHausdorff.ghDist X Y ≤ Metric.hausdorffDist (Set.range Φ) (Set.range Ψ)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The Gromov-Hausdorff distance between two spaces is bounded by the Hausdorff distance\\nof isometric copies of the spaces, in any metric space. \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} [inst : LinearOrder X] [inst_1 : TopologicalSpace X] [inst : OrderTopology X], T5Space X\",\n  \"isProp\": true,\n  \"docString\":\n  \"A linear order with order topology is a completely normal Hausdorff topological space. \"},\n {\"theorem\":\n  \"∀ {H : Type u_1} [inst : TopologicalSpace H] [inst_1 : LocallyCompactSpace H] [inst_2 : T2Space H],\\n  TotallyDisconnectedSpace H ↔ TotallySeparatedSpace H\",\n  \"isProp\": true,\n  \"docString\":\n  \"A locally compact Hausdorff space is totally disconnected\\nif and only if it is totally separated. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : PseudoMetricSpace α] {s : Set α} [inst_1 : T2Space α] [inst_2 : ProperSpace α],\\n  IsCompact s ↔ IsClosed s ∧ Metric.Bounded s\",\n  \"isProp\": true,\n  \"docString\":\n  \"The **Heine–Borel theorem**:\\nIn a proper Hausdorff space, a set is compact if and only if it is closed and bounded. \"},\n {\"theorem\":\n  \"∀ {H : Type u_1} [inst : TopologicalSpace H] [inst_1 : LocallyCompactSpace H] [inst_2 : T2Space H]\\n  [inst_3 : TotallyDisconnectedSpace H], TopologicalSpace.IsTopologicalBasis {s | IsClopen s}\",\n  \"isProp\": true,\n  \"docString\":\n  \"A locally compact Hausdorff totally disconnected space has a basis with clopen elements. \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} [inst : TopologicalSpace X], CompactSpace (OnePoint X)\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any topological space `X`, its one point compactification is a compact space. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : T2Space β] {f : α → β},\\n  Function.Injective f → Continuous f → T2Space α\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the codomain of an injective continuous function is a Hausdorff space, then so is its\\ndomain. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T2Space α] [inst_2 : CompactSpace α],\\n  TotallyDisconnectedSpace α ↔ TotallySeparatedSpace α\",\n  \"isProp\": true,\n  \"docString\":\n  \"A compact Hausdorff space is totally disconnected if and only if it is totally separated, this\\nis also true for locally compact spaces. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : EMetricSpace α] [inst_1 : CompleteSpace α], CompleteSpace (TopologicalSpace.Closeds α)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a complete space, the type of closed subsets is complete for the\\nHausdorff edistance. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T2Space α],\\n  (∀ (x : α), ∃ s, s ∈ nhds x ∧ IsCompact s) → LocallyCompactSpace α\",\n  \"isProp\": true,\n  \"docString\":\n  \"If every points of a Hausdorff space admits a compact neighborhood, then this space is locally\\ncompact. \"},\n {\"theorem\":\n  \"∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [inst_2 : FiniteDimensional ℝ E]\\n  {H : Type u_2} [inst_3 : TopologicalSpace H],\\n  ModelWithCorners ℝ E H →\\n    ∀ (M : Type u_3) [inst : TopologicalSpace M] [inst_4 : ChartedSpace H M] [inst_5 : SigmaCompactSpace M]\\n      [inst_6 : T2Space M], TopologicalSpace.MetrizableSpace M\",\n  \"isProp\": true,\n  \"docString\":\n  \"A σ-compact Hausdorff topological manifold over a finite dimensional real vector space is\\nmetrizable. \"},\n {\"theorem\":\n  \"∀ {J : Type u} [inst : CategoryTheory.SmallCategory J] (F : CategoryTheory.Functor J TopCatMax)\\n  [inst_1 : CategoryTheory.IsCofilteredOrEmpty J] [inst_2 : ∀ (j : J), Nonempty ↑(F.obj j)]\\n  [inst_3 : ∀ (j : J), CompactSpace ↑(F.obj j)] [inst_4 : ∀ (j : J), T2Space ↑(F.obj j)],\\n  Nonempty ↑(TopCat.limitCone F).pt\",\n  \"isProp\": true,\n  \"docString\":\n  \"Cofiltered limits of nonempty compact Hausdorff spaces are nonempty topological spaces.\\n\"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T2Space α] [inst_2 : CompactSpace α]\\n  [inst_3 : TotallyDisconnectedSpace α] {x : α} {U : Set α}, IsOpen U → x ∈ U → ∃ V, IsClopen V ∧ x ∈ V ∧ V ⊆ U\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every member of an open set in a compact Hausdorff totally disconnected space\\nis contained in a clopen set contained in the open set.  \"}]\n", "prompt_cons": "/-- A continuous map from a compact space to a Hausdorff space is a closed map. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : CompactSpace α]\n  [inst_3 : T2Space β] {f : α → β}, Continuous f → IsClosedMap f :=\n\n/-- A continuous surjective map from a compact space to a Hausdorff space is a quotient map. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : CompactSpace α]\n  [inst_3 : T2Space β] {f : α → β}, Function.Surjective f → Continuous f → QuotientMap f :=\n\n/-- Every two points in a Hausdorff space admit disjoint open neighbourhoods. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [self : T2Space α] (x y : α),\n  x ≠ y → ∃ u v, IsOpen u ∧ IsOpen v ∧ x ∈ u ∧ y ∈ v ∧ Disjoint u v :=\n\n/-- Any continuous function on compact Hausdorff spaces is a closed map. -/\ntheorem ∀ {X Y : CompHaus} (f : X ⟶ Y), IsClosedMap ↑f :=\n\n/-- A continuous injective map from a compact space to a Hausdorff space is a closed embedding. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : CompactSpace α]\n  [inst_3 : T2Space β] {f : α → β}, Continuous f → Function.Injective f → ClosedEmbedding f :=\n\n/-- Any continuous bijection of compact Hausdorff spaces is an isomorphism. -/\ntheorem ∀ {X Y : CompHaus} (f : X ⟶ Y), Function.Bijective ↑f → CategoryTheory.IsIso f :=\n\n/-- The one point compactification of a locally compact Hausdorff space is a normal (hence,\nHausdorff and regular) topological space. -/\ntheorem ∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : LocallyCompactSpace X] [inst_2 : T2Space X],\n  NormalSpace (OnePoint X) :=\n\n/-- The Gromov-Hausdorff distance between two spaces is bounded by the Hausdorff distance\nof isometric copies of the spaces, in any metric space. -/\ntheorem ∀ {X : Type u} [inst : MetricSpace X] [inst_1 : CompactSpace X] [inst_2 : Nonempty X] {Y : Type v}\n  [inst_3 : MetricSpace Y] [inst_4 : CompactSpace Y] [inst_5 : Nonempty Y] {γ : Type w} [inst_6 : MetricSpace γ]\n  {Φ : X → γ} {Ψ : Y → γ},\n  Isometry Φ → Isometry Ψ → GromovHausdorff.ghDist X Y ≤ Metric.hausdorffDist (Set.range Φ) (Set.range Ψ) :=\n\n/-- A linear order with order topology is a completely normal Hausdorff topological space. -/\ntheorem ∀ {X : Type u_1} [inst : LinearOrder X] [inst_1 : TopologicalSpace X] [inst : OrderTopology X], T5Space X :=\n\n/-- A locally compact Hausdorff space is totally disconnected\nif and only if it is totally separated. -/\ntheorem ∀ {H : Type u_1} [inst : TopologicalSpace H] [inst_1 : LocallyCompactSpace H] [inst_2 : T2Space H],\n  TotallyDisconnectedSpace H ↔ TotallySeparatedSpace H :=\n\n/-- The **Heine–Borel theorem**:\nIn a proper Hausdorff space, a set is compact if and only if it is closed and bounded. -/\ntheorem ∀ {α : Type u} [inst : PseudoMetricSpace α] {s : Set α} [inst_1 : T2Space α] [inst_2 : ProperSpace α],\n  IsCompact s ↔ IsClosed s ∧ Metric.Bounded s :=\n\n/-- A locally compact Hausdorff totally disconnected space has a basis with clopen elements. -/\ntheorem ∀ {H : Type u_1} [inst : TopologicalSpace H] [inst_1 : LocallyCompactSpace H] [inst_2 : T2Space H]\n  [inst_3 : TotallyDisconnectedSpace H], TopologicalSpace.IsTopologicalBasis {s | IsClopen s} :=\n\n/-- For any topological space `X`, its one point compactification is a compact space. -/\ntheorem ∀ {X : Type u_1} [inst : TopologicalSpace X], CompactSpace (OnePoint X) :=\n\n/-- If the codomain of an injective continuous function is a Hausdorff space, then so is its\ndomain. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : T2Space β] {f : α → β},\n  Function.Injective f → Continuous f → T2Space α :=\n\n/-- A compact Hausdorff space is totally disconnected if and only if it is totally separated, this\nis also true for locally compact spaces. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T2Space α] [inst_2 : CompactSpace α],\n  TotallyDisconnectedSpace α ↔ TotallySeparatedSpace α :=\n\n/-- In a complete space, the type of closed subsets is complete for the\nHausdorff edistance. -/\ntheorem ∀ {α : Type u} [inst : EMetricSpace α] [inst_1 : CompleteSpace α], CompleteSpace (TopologicalSpace.Closeds α) :=\n\n/-- If every points of a Hausdorff space admits a compact neighborhood, then this space is locally\ncompact. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T2Space α],\n  (∀ (x : α), ∃ s, s ∈ nhds x ∧ IsCompact s) → LocallyCompactSpace α :=\n\n/-- A σ-compact Hausdorff topological manifold over a finite dimensional real vector space is\nmetrizable. -/\ntheorem ∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [inst_2 : FiniteDimensional ℝ E]\n  {H : Type u_2} [inst_3 : TopologicalSpace H],\n  ModelWithCorners ℝ E H →\n    ∀ (M : Type u_3) [inst : TopologicalSpace M] [inst_4 : ChartedSpace H M] [inst_5 : SigmaCompactSpace M]\n      [inst_6 : T2Space M], TopologicalSpace.MetrizableSpace M :=\n\n/-- Cofiltered limits of nonempty compact Hausdorff spaces are nonempty topological spaces. -/\ntheorem ∀ {J : Type u} [inst : CategoryTheory.SmallCategory J] (F : CategoryTheory.Functor J TopCatMax)\n  [inst_1 : CategoryTheory.IsCofilteredOrEmpty J] [inst_2 : ∀ (j : J), Nonempty ↑(F.obj j)]\n  [inst_3 : ∀ (j : J), CompactSpace ↑(F.obj j)] [inst_4 : ∀ (j : J), T2Space ↑(F.obj j)],\n  Nonempty ↑(TopCat.limitCone F).pt :=\n\n/-- Every member of an open set in a compact Hausdorff totally disconnected space\nis contained in a clopen set contained in the open set. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T2Space α] [inst_2 : CompactSpace α]\n  [inst_3 : TotallyDisconnectedSpace α] {x : α} {U : Set α}, IsOpen U → x ∈ U → ∃ V, IsClopen V ∧ x ∈ V ∧ V ⊆ U :=\n\n/-- A topological space $X$ is Hausdorff if and only if the diagonal map is an open map from $X$ to $X × X$. -/\ntheorem", "choices": ["∀ {α : Type u} [inst : TopologicalSpace α], T2Space α ↔ IsOpenMap (λ (x : α), (x, x)) ", "∀ {α : Type u} [inst : TopologicalSpace α],\n  T2Space α ↔ IsOpenMap (λ (x : α), (x, x) : α → α × α) ", "∀ {α : Type u} [inst : TopologicalSpace α], T2Space α ↔ IsOpenMap (λ x, (x, x) : α → α × α) ", "∀ {X : Type u_1} [inst : TopologicalSpace X], T2Space X ↔ IsOpenMap (λ (x : X), (x, x)) ", "∀ {α : Type u} [inst : TopologicalSpace α], T2Space α ↔ IsOpenMap (λ x : α, (x, x)) ", "∀ {α : Type u} [inst : TopologicalSpace α],\n  T2Space α ↔ IsOpenMap (λ x : α, (x, x)) ", "∀ {α : Type u} [inst : TopologicalSpace α],\n  T2Space α ↔ OpenEmbedding (λ x : α, (x, x)) ", "∀ {α : Type u} [inst : TopologicalSpace α], T2Space α ↔ IsOpenMap (λ (x : α), (x, x)) ", "∀ {α : Type u} [inst : TopologicalSpace α], T2Space α ↔ IsOpenMap (λ x : α, (x, x)) ", "∀ {α : Type u} [inst : TopologicalSpace α],\n  T2Space α ↔ IsOpenMap (λ x : α, (x, x)) "]}
{"docString": "Any finite order element in a group is equal to the identity.", "prompts": "[{\"theorem\":\n  \"∀ {α : Type u_1} [self : LinearOrderedCommGroupWithZero α] (a : α), a ≠ 0 → a * a⁻¹ = 1\",\n  \"isProp\": true,\n  \"docString\": \"Every nonzero element of a group with zero is invertible. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Monoid G] {x : G}, 0 < orderOf x ↔ IsOfFinOrder x\",\n  \"isProp\": true,\n  \"docString\": \"A group element has finite order iff its order is positive. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x⁻¹ ↔ IsOfFinOrder x\",\n  \"isProp\": true,\n  \"docString\": \"Inverses of elements of finite order have finite order. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : CommMonoid G] {x y : G}, IsOfFinOrder x → IsOfFinOrder y → IsOfFinOrder (x * y)\",\n  \"isProp\": true,\n  \"docString\": \"Elements of finite order are closed under multiplication. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : AddMonoid G] {x : G}, 0 < addOrderOf x ↔ IsOfFinAddOrder x\",\n  \"isProp\": true,\n  \"docString\":\n  \"A group element has finite additive order iff its order is positive.\"},\n {\"theorem\":\n  \"∀ {G : Type u_2} {H : Type u_1} [inst : Monoid G] [inst_1 : Monoid H] (f : G →* H) {x : G},\\n  IsOfFinOrder x → IsOfFinOrder (↑f x)\",\n  \"isProp\": true,\n  \"docString\": \"The image of an element of finite order has finite order. \"},\n {\"theorem\":\n  \"∀ {G : Type u_2} {H : Type u_1} [inst : AddMonoid G] [inst_1 : AddMonoid H] (f : G →+ H) {x : G},\\n  IsOfFinAddOrder x → IsOfFinAddOrder (↑f x)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The image of an element of finite additive order has finite additive order.\"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : AddGroup G] {x : G}, IsOfFinAddOrder x → IsOfFinAddOrder (-x)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Inverses of elements of finite additive order have finite additive order.\"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : AddMonoid G] (H : AddSubmonoid G) (x : { x // x ∈ H }), IsOfFinAddOrder x ↔ IsOfFinAddOrder ↑x\",\n  \"isProp\": true,\n  \"docString\": \"Elements of finite order are of finite order in submonoids.\"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : AddGroup α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\\n  Fintype.card α = p → IsAddCyclic α\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic.\"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)], Fintype.card α = p → IsCyclic α\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\\n  Fintype.card α = p → IsSimpleGroup α\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is simple. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : AddCommMonoid G] {x y : G}, IsOfFinAddOrder x → IsOfFinAddOrder y → IsOfFinAddOrder (x + y)\",\n  \"isProp\": true,\n  \"docString\": \"Elements of finite additive order are closed under addition.\"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : AddGroup α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\\n  Fintype.card α = p → IsSimpleAddGroup α\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is simple.\"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] {x y : G}, y ∈ Subgroup.closure {x} ↔ ∃ n, x ^ n = y\",\n  \"isProp\": true,\n  \"docString\":\n  \"The subgroup generated by an element of a group equals the set of integer number powers of\\nthe element. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : AddGroup G] {x : G}, IsOfFinAddOrder (-x) ↔ IsOfFinAddOrder x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Inverses of elements of finite additive order\\nhave finite additive order.\"},\n {\"theorem\": \"∀ {S : Type u_1} [inst : Add S] (a : S), AddCommute a a\",\n  \"isProp\": true,\n  \"docString\": \"Any element commutes with itself.\"},\n {\"theorem\": \"∀ {S : Type u_1} [inst : Mul S] (a : S), Commute a a\",\n  \"isProp\": true,\n  \"docString\": \"Any element commutes with itself. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Monoid G] {x y : G}, Commute x y → IsOfFinOrder x → IsOfFinOrder y → IsOfFinOrder (x * y)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Commuting elements of finite order are closed under multiplication. \"},\n {\"theorem\":\n  \"∀ {R : Type u_2} {G : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : Group G] [inst_3 : Finite G]\\n  (f : G →* R), Function.Injective ↑f → IsCyclic G\",\n  \"isProp\": true,\n  \"docString\":\n  \"A finite subgroup of the unit group of an integral domain is cyclic. \"}]\n", "prompt_cons": "/-- Every nonzero element of a group with zero is invertible. -/\ntheorem ∀ {α : Type u_1} [self : LinearOrderedCommGroupWithZero α] (a : α), a ≠ 0 → a * a⁻¹ = 1 :=\n\n/-- A group element has finite order iff its order is positive. -/\ntheorem ∀ {G : Type u_1} [inst : Monoid G] {x : G}, 0 < orderOf x ↔ IsOfFinOrder x :=\n\n/-- Inverses of elements of finite order have finite order. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x⁻¹ ↔ IsOfFinOrder x :=\n\n/-- Elements of finite order are closed under multiplication. -/\ntheorem ∀ {G : Type u_1} [inst : CommMonoid G] {x y : G}, IsOfFinOrder x → IsOfFinOrder y → IsOfFinOrder (x * y) :=\n\n/-- A group element has finite additive order iff its order is positive. -/\ntheorem ∀ {G : Type u_1} [inst : AddMonoid G] {x : G}, 0 < addOrderOf x ↔ IsOfFinAddOrder x :=\n\n/-- The image of an element of finite order has finite order. -/\ntheorem ∀ {G : Type u_2} {H : Type u_1} [inst : Monoid G] [inst_1 : Monoid H] (f : G →* H) {x : G},\n  IsOfFinOrder x → IsOfFinOrder (↑f x) :=\n\n/-- The image of an element of finite additive order has finite additive order. -/\ntheorem ∀ {G : Type u_2} {H : Type u_1} [inst : AddMonoid G] [inst_1 : AddMonoid H] (f : G →+ H) {x : G},\n  IsOfFinAddOrder x → IsOfFinAddOrder (↑f x) :=\n\n/-- Inverses of elements of finite additive order have finite additive order. -/\ntheorem ∀ {G : Type u_1} [inst : AddGroup G] {x : G}, IsOfFinAddOrder x → IsOfFinAddOrder (-x) :=\n\n/-- Elements of finite order are of finite order in submonoids. -/\ntheorem ∀ {G : Type u_1} [inst : AddMonoid G] (H : AddSubmonoid G) (x : { x // x ∈ H }), IsOfFinAddOrder x ↔ IsOfFinAddOrder ↑x :=\n\n/-- A finite group of prime order is cyclic. -/\ntheorem ∀ {α : Type u} [inst : AddGroup α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\n  Fintype.card α = p → IsAddCyclic α :=\n\n/-- A finite group of prime order is cyclic. -/\ntheorem ∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)], Fintype.card α = p → IsCyclic α :=\n\n/-- A finite group of prime order is simple. -/\ntheorem ∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\n  Fintype.card α = p → IsSimpleGroup α :=\n\n/-- Elements of finite additive order are closed under addition. -/\ntheorem ∀ {G : Type u_1} [inst : AddCommMonoid G] {x y : G}, IsOfFinAddOrder x → IsOfFinAddOrder y → IsOfFinAddOrder (x + y) :=\n\n/-- A finite group of prime order is simple. -/\ntheorem ∀ {α : Type u} [inst : AddGroup α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\n  Fintype.card α = p → IsSimpleAddGroup α :=\n\n/-- The subgroup generated by an element of a group equals the set of integer number powers of\nthe element. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] {x y : G}, y ∈ Subgroup.closure {x} ↔ ∃ n, x ^ n = y :=\n\n/-- Inverses of elements of finite additive order\nhave finite additive order. -/\ntheorem ∀ {G : Type u_1} [inst : AddGroup G] {x : G}, IsOfFinAddOrder (-x) ↔ IsOfFinAddOrder x :=\n\n/-- Any element commutes with itself. -/\ntheorem ∀ {S : Type u_1} [inst : Add S] (a : S), AddCommute a a :=\n\n/-- Any element commutes with itself. -/\ntheorem ∀ {S : Type u_1} [inst : Mul S] (a : S), Commute a a :=\n\n/-- Commuting elements of finite order are closed under multiplication. -/\ntheorem ∀ {G : Type u_1} [inst : Monoid G] {x y : G}, Commute x y → IsOfFinOrder x → IsOfFinOrder y → IsOfFinOrder (x * y) :=\n\n/-- A finite subgroup of the unit group of an integral domain is cyclic. -/\ntheorem ∀ {R : Type u_2} {G : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : Group G] [inst_3 : Finite G]\n  (f : G →* R), Function.Injective ↑f → IsCyclic G :=\n\n/-- Any finite order element in a group is equal to the identity. -/\ntheorem", "choices": ["∀ {G : Type u_1} [inst : Group G] {x : G}, orderOf x = 1 → x = 1 ", "∀ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x → ∃ n, x ^ n = 1 ", "∀ {G : Type u_1} [inst : Group G] {x : G}, orderOf x = 1 ↔ x = 1 ", "∀ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x → ∃ n : ℕ, x ^ n = 1 ", "∀ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x → ∃ n, 0 < n ∧ x ^ n = 1 ", "∀ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x → ∃ n, 0 < n ∧ x ^ n = 1 ", "∀ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x → ∃ n : ℕ, 0 < n ∧ x ^ n = 1 ", "∀ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x → x ^ orderOf x = 1 ", "∀ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x → x ^ orderOf x = 1 ", "∀ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x → ∃ n : ℕ, 0 < n ∧ x ^ n = 1 "]}
{"docString": "If a subgroup of a group is torsion-free, then the group itself is torsion free.", "prompts": "[{\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsionFree G → ∀ (H : Subgroup G), Monoid.IsTorsionFree { x // x ∈ H }\",\n  \"isProp\": true,\n  \"docString\": \"Subgroups of torsion-free groups are torsion-free. \"},\n {\"theorem\":\n  \"∀ (G : Type u_1) [inst : CommGroup G], Monoid.IsTorsionFree (G ⧸ CommGroup.torsion G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Quotienting a group by its torsion subgroup yields a torsion free group. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : AddGroup G],\\n  AddMonoid.IsTorsionFree G → ∀ (H : AddSubgroup G), AddMonoid.IsTorsionFree { x // x ∈ H }\",\n  \"isProp\": true,\n  \"docString\":\n  \"Subgroups of additive torsion-free groups are additively torsion-free.\"},\n {\"theorem\":\n  \"∀ {η : Type u_1} {Gs : η → Type u_2} [inst : (i : η) → Group (Gs i)],\\n  (∀ (i : η), Monoid.IsTorsionFree (Gs i)) → Monoid.IsTorsionFree ((i : η) → Gs i)\",\n  \"isProp\": true,\n  \"docString\": \"Direct products of torsion free groups are torsion free. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G → ∀ (H : Subgroup G), Monoid.IsTorsion { x // x ∈ H }\",\n  \"isProp\": true,\n  \"docString\": \"Subgroups of torsion groups are torsion groups. \"},\n {\"theorem\":\n  \"∀ (G : Type u_1) [inst : AddCommGroup G], AddMonoid.IsTorsionFree (G ⧸ AddCommGroup.torsion G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Quotienting a group by its additive torsion subgroup yields an additive torsion free group.\"},\n {\"theorem\":\n  \"∀ {η : Type u_1} {Gs : η → Type u_2} [inst : (i : η) → AddGroup (Gs i)],\\n  (∀ (i : η), AddMonoid.IsTorsionFree (Gs i)) → AddMonoid.IsTorsionFree ((i : η) → Gs i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Direct products of additive torsion free groups are torsion free.\"},\n {\"theorem\":\n  \"∀ (G : Type u_1) [inst : CommGroup G], CommMonoid.torsion G = (CommGroup.torsion G).toSubmonoid\",\n  \"isProp\": true,\n  \"docString\":\n  \"The torsion submonoid of an abelian group equals the torsion subgroup as a submonoid. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : AddGroup G], AddMonoid.IsTorsion G → ∀ (H : AddSubgroup G), AddMonoid.IsTorsion { x // x ∈ H }\",\n  \"isProp\": true,\n  \"docString\":\n  \"Subgroups of additive torsion groups are additive torsion groups.\"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"Finite groups are torsion groups. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : CommMonoid G], Monoid.IsTorsion { x // x ∈ CommMonoid.torsion G }\",\n  \"isProp\": true,\n  \"docString\": \"Torsion submonoids are torsion. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} {H : Type u_2} [inst : Group G] {N : Subgroup G} [inst_1 : Group H] {f : G →* H},\\n  N = MonoidHom.ker f → Monoid.IsTorsion H → Monoid.IsTorsion { x // x ∈ N } → Monoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"Torsion groups are closed under extensions. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G], Monoid.ExponentExists G → Monoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"If a group exponent exists, the group is torsion. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsionFree G → ¬Monoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"A nontrivial torsion-free group is not torsion. \"},\n {\"theorem\":\n  \"∀ {R : Type u_2} {M : Type u_1} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M],\\n  Submodule.torsion R (M ⧸ Submodule.torsion R M) = ⊥\",\n  \"isProp\": true,\n  \"docString\":\n  \"Quotienting by the torsion submodule gives a torsion-free module. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} {H : Type u_2} [inst : Group G] {N : Subgroup G} [inst_1 : Group H] {f : G →* H},\\n  Function.Surjective ↑f →\\n    N = MonoidHom.ker f → Monoid.IsTorsion { x // x ∈ N } → (Monoid.IsTorsion H ↔ Monoid.IsTorsion G)\",\n  \"isProp\": true,\n  \"docString\": \"The image of a quotient is torsion iff the group is torsion. \"},\n {\"theorem\":\n  \"∀ (G : Type u_1) [inst : AddCommGroup G], AddCommMonoid.addTorsion G = (AddCommGroup.torsion G).toAddSubmonoid\",\n  \"isProp\": true,\n  \"docString\":\n  \"The additive torsion submonoid of an abelian group equals the torsion\\nsubgroup as a submonoid.\"},\n {\"theorem\":\n  \"∀ {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : Group H] {f : G →* H},\\n  Function.Surjective ↑f → Monoid.IsTorsion G → Monoid.IsTorsion H\",\n  \"isProp\": true,\n  \"docString\":\n  \"The image of a surjective torsion group homomorphism is torsion. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} {H : Type u_2} [inst : AddGroup G] {N : AddSubgroup G} [inst_1 : AddGroup H] {f : G →+ H},\\n  N = AddMonoidHom.ker f → AddMonoid.IsTorsion H → AddMonoid.IsTorsion { x // x ∈ N } → AddMonoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"Additive torsion groups are closed under extensions.\"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsion G → ¬Monoid.IsTorsionFree G\",\n  \"isProp\": true,\n  \"docString\": \"A nontrivial torsion group is not torsion-free. \"}]\n", "prompt_cons": "/-- Subgroups of torsion-free groups are torsion-free. -/\ntheorem ∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsionFree G → ∀ (H : Subgroup G), Monoid.IsTorsionFree { x // x ∈ H } :=\n\n/-- Quotienting a group by its torsion subgroup yields a torsion free group. -/\ntheorem ∀ (G : Type u_1) [inst : CommGroup G], Monoid.IsTorsionFree (G ⧸ CommGroup.torsion G) :=\n\n/-- Subgroups of additive torsion-free groups are additively torsion-free. -/\ntheorem ∀ {G : Type u_1} [inst : AddGroup G],\n  AddMonoid.IsTorsionFree G → ∀ (H : AddSubgroup G), AddMonoid.IsTorsionFree { x // x ∈ H } :=\n\n/-- Direct products of torsion free groups are torsion free. -/\ntheorem ∀ {η : Type u_1} {Gs : η → Type u_2} [inst : (i : η) → Group (Gs i)],\n  (∀ (i : η), Monoid.IsTorsionFree (Gs i)) → Monoid.IsTorsionFree ((i : η) → Gs i) :=\n\n/-- Subgroups of torsion groups are torsion groups. -/\ntheorem ∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G → ∀ (H : Subgroup G), Monoid.IsTorsion { x // x ∈ H } :=\n\n/-- Quotienting a group by its additive torsion subgroup yields an additive torsion free group. -/\ntheorem ∀ (G : Type u_1) [inst : AddCommGroup G], AddMonoid.IsTorsionFree (G ⧸ AddCommGroup.torsion G) :=\n\n/-- Direct products of additive torsion free groups are torsion free. -/\ntheorem ∀ {η : Type u_1} {Gs : η → Type u_2} [inst : (i : η) → AddGroup (Gs i)],\n  (∀ (i : η), AddMonoid.IsTorsionFree (Gs i)) → AddMonoid.IsTorsionFree ((i : η) → Gs i) :=\n\n/-- The torsion submonoid of an abelian group equals the torsion subgroup as a submonoid. -/\ntheorem ∀ (G : Type u_1) [inst : CommGroup G], CommMonoid.torsion G = (CommGroup.torsion G).toSubmonoid :=\n\n/-- Subgroups of additive torsion groups are additive torsion groups. -/\ntheorem ∀ {G : Type u_1} [inst : AddGroup G], AddMonoid.IsTorsion G → ∀ (H : AddSubgroup G), AddMonoid.IsTorsion { x // x ∈ H } :=\n\n/-- Finite groups are torsion groups. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G :=\n\n/-- Torsion submonoids are torsion. -/\ntheorem ∀ {G : Type u_1} [inst : CommMonoid G], Monoid.IsTorsion { x // x ∈ CommMonoid.torsion G } :=\n\n/-- Torsion groups are closed under extensions. -/\ntheorem ∀ {G : Type u_1} {H : Type u_2} [inst : Group G] {N : Subgroup G} [inst_1 : Group H] {f : G →* H},\n  N = MonoidHom.ker f → Monoid.IsTorsion H → Monoid.IsTorsion { x // x ∈ N } → Monoid.IsTorsion G :=\n\n/-- If a group exponent exists, the group is torsion. -/\ntheorem ∀ {G : Type u_1} [inst : Group G], Monoid.ExponentExists G → Monoid.IsTorsion G :=\n\n/-- A nontrivial torsion-free group is not torsion. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsionFree G → ¬Monoid.IsTorsion G :=\n\n/-- Quotienting by the torsion submodule gives a torsion-free module. -/\ntheorem ∀ {R : Type u_2} {M : Type u_1} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M],\n  Submodule.torsion R (M ⧸ Submodule.torsion R M) = ⊥ :=\n\n/-- The image of a quotient is torsion iff the group is torsion. -/\ntheorem ∀ {G : Type u_1} {H : Type u_2} [inst : Group G] {N : Subgroup G} [inst_1 : Group H] {f : G →* H},\n  Function.Surjective ↑f →\n    N = MonoidHom.ker f → Monoid.IsTorsion { x // x ∈ N } → (Monoid.IsTorsion H ↔ Monoid.IsTorsion G) :=\n\n/-- The additive torsion submonoid of an abelian group equals the torsion\nsubgroup as a submonoid. -/\ntheorem ∀ (G : Type u_1) [inst : AddCommGroup G], AddCommMonoid.addTorsion G = (AddCommGroup.torsion G).toAddSubmonoid :=\n\n/-- The image of a surjective torsion group homomorphism is torsion. -/\ntheorem ∀ {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : Group H] {f : G →* H},\n  Function.Surjective ↑f → Monoid.IsTorsion G → Monoid.IsTorsion H :=\n\n/-- Additive torsion groups are closed under extensions. -/\ntheorem ∀ {G : Type u_1} {H : Type u_2} [inst : AddGroup G] {N : AddSubgroup G} [inst_1 : AddGroup H] {f : G →+ H},\n  N = AddMonoidHom.ker f → AddMonoid.IsTorsion H → AddMonoid.IsTorsion { x // x ∈ N } → AddMonoid.IsTorsion G :=\n\n/-- A nontrivial torsion group is not torsion-free. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsion G → ¬Monoid.IsTorsionFree G :=\n\n/-- If a subgroup of a group is torsion-free, then the group itself is torsion free. -/\ntheorem", "choices": ["∀ {G : Type u_1} [inst : Group G], (∀ (H : Subgroup G), Monoid.IsTorsionFree { x // x ∈ H }) → Monoid.IsTorsionFree G ", "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Monoid.IsTorsionFree { x // x ∈ H } → Monoid.IsTorsionFree G ", "forall {G : Type u_1} [inst : Group G], Monoid.IsTorsionFree { x // x ∈ Subgroup.top G } → Monoid.IsTorsionFree G ", "∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsionFree { x // x ∈ Subgroup G } → Monoid.IsTorsionFree G ", "∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsionFree { x // x ∈ Subgroup.univ } → Monoid.IsTorsionFree G ", "∀ {G : Type u_1} [inst : Group G], (∀ (H : Subgroup G), Monoid.IsTorsionFree { x // x ∈ H }) → Monoid.IsTorsionFree G ", "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Monoid.IsTorsionFree { x // x ∈ H } → Monoid.IsTorsionFree G ", "∀ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsionFree { x // x ∈ Subgroup G } → Monoid.IsTorsionFree G ", "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G),\n  Monoid.IsTorsionFree { x // x ∈ H } → Monoid.IsTorsionFree G ", "∀ {G : Type u_1} [inst : Group G] [hN : Monoid.IsTorsionFree { x // x ∈ Subgroup.univ }], Monoid.IsTorsionFree G "]}
{"docString": "Every injective homomorphism from a finitely generated free group to itself is surjective.", "prompts": "[{\"theorem\":\n  \"∀ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  [inst_3 : IsArtinian R M] (f : M →ₗ[R] M), Function.Injective ↑f → Function.Surjective ↑f\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any injective endomorphism of an Artinian module is surjective. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : Group α] [inst_1 : Group β] {f : α → β},\\n  IsGroupHom f → (Function.Injective f ↔ ∀ (a : α), f a = 1 → a = 1)\",\n  \"isProp\": true,\n  \"docString\": \"A group homomorphism is injective iff its kernel is trivial. \"},\n {\"theorem\":\n  \"∀ {ι : Type u_1} {K : Type u_2} {R : Type u_3} [inst : Field K] [inst_1 : Finite K] [inst_2 : CommRing R]\\n  [inst_3 : Finite ι] [inst_4 : Algebra K R],\\n  Algebra.IsAlgebraic K R →\\n    ∀ (ps : ι → MvPolynomial ι R),\\n      (Function.Injective fun v i => ↑(MvPolynomial.eval v) (ps i)) →\\n        Function.Surjective fun v i => ↑(MvPolynomial.eval v) (ps i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any injective polynomial map over an algebraic extension of a finite field is surjective. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  [inst_3 : IsNoetherian R M] (f : M →ₗ[R] M), Function.Surjective ↑f → Function.Injective ↑f\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any surjective endomorphism of a Noetherian module is injective. \"},\n {\"theorem\":\n  \"∀ {V : Type u} {W : Type v} {G' : SimpleGraph W} (f : ⊤ →g G'), Function.Injective ↑f\",\n  \"isProp\": true,\n  \"docString\": \"Every graph homomorphism from a complete graph is injective. \"},\n {\"theorem\":\n  \"∀ {R₁ : Type u_1} {R₂ : Type u_2} [inst : Semiring R₁] [inst_1 : Semiring R₂] {σ : R₁ →+* R₂}\\n  [self : RingHomSurjective σ], Function.Surjective ↑σ\",\n  \"isProp\": true,\n  \"docString\": \"The ring homomorphism is surjective \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : AddGroup α] [inst_1 : AddGroup β] {f : α → β},\\n  IsAddGroupHom f → (Function.Injective f ↔ ∀ (a : α), f a = 0 → a = 0)\",\n  \"isProp\": true,\n  \"docString\":\n  \"An additive group homomorphism is injective if its kernel is trivial.\"},\n {\"theorem\":\n  \"∀ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  [inst_3 : IsArtinian R M] (f : M →ₗ[R] M), Function.Injective ↑f → Function.Bijective ↑f\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any injective endomorphism of an Artinian module is bijective. \"},\n {\"theorem\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  [inst_3 : FiniteDimensional K V] {f : V →ₗ[K] V}, Function.Injective ↑f → Function.Surjective ↑f\",\n  \"isProp\": true,\n  \"docString\":\n  \"On a finite-dimensional space, an injective linear map is surjective. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} {H : Type u_2} {F : Type u_3} [inst : Group G] [inst_1 : DivisionMonoid H]\\n  [inst_2 : MonoidHomClass F G H] (f : F) (a : G), ↑f a⁻¹ = (↑f a)⁻¹\",\n  \"isProp\": true,\n  \"docString\": \"Group homomorphisms preserve inverse. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  [inst_3 : IsNoetherian R M] (f : M →ₗ[R] M), Function.Surjective ↑f → Function.Bijective ↑f\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any surjective endomorphism of a Noetherian module is bijective. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : Group H] {f : G →* H},\\n  Function.Surjective ↑f → Monoid.IsTorsion G → Monoid.IsTorsion H\",\n  \"isProp\": true,\n  \"docString\":\n  \"The image of a surjective torsion group homomorphism is torsion. \"},\n {\"theorem\":\n  \"∀ {M : Type u_1} [inst : MulOneClass M] {c : Con M}, Function.Surjective ↑(Con.mk' c)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The natural homomorphism from a monoid to its quotient by a congruence relation is\\nsurjective. \"},\n {\"theorem\":\n  \"∀ {R₁ : Type u_1} {A : Type u_2} {B : Type u_3} [inst : CommSemiring R₁] [inst_1 : CommRing A] [inst_2 : CommRing B]\\n  [inst_3 : Algebra R₁ A] [inst_4 : Algebra R₁ B] (f : A →ₐ[R₁] B), Function.Injective ↑(Ideal.kerLiftAlg f)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The induced algebra morphism from the quotient by the kernel is injective. \"},\n {\"theorem\": \"∀ {α : Type u}, Function.Injective FreeGroup.of\",\n  \"isProp\": true,\n  \"docString\":\n  \"The canonical map from the type to the free group is an injection. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : Group α] [inst_1 : Group β] {f : α → β}, IsGroupHom f → ∀ (a : α), f a⁻¹ = (f a)⁻¹\",\n  \"isProp\": true,\n  \"docString\": \"A group homomorphism sends inverses to inverses. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : Group α] [inst_1 : Group β] {f : α → β}, IsGroupHom f → IsMonoidHom f\",\n  \"isProp\": true,\n  \"docString\": \"A group homomorphism is a monoid homomorphism. \"},\n {\"theorem\":\n  \"∀ {M : Type u_1} {P : Type u_2} [inst : MulOneClass M] [inst_1 : MulOneClass P] (f : M →* P),\\n  Function.Injective ↑(Con.kerLift f)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A monoid homomorphism `f` induces an injective homomorphism on the quotient by `f`'s kernel. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : Group α] [inst_1 : Group β] {f : α → β}, IsGroupHom f → f 1 = 1\",\n  \"isProp\": true,\n  \"docString\": \"A group homomorphism sends 1 to 1. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} {M : Type u_3} {R₂ : Type u_2} {M₂ : Type u_4} [inst : Ring R] [inst_1 : Ring R₂]\\n  [inst_2 : AddCommMonoid M] [inst_3 : AddCommGroup M₂] [inst_4 : Module R M] [inst_5 : Module R₂ M₂] {τ₁₂ : R →+* R₂}\\n  [inst_6 : RingHomSurjective τ₁₂] {f : M →ₛₗ[τ₁₂] M₂},\\n  (∀ (u v : M₂ →ₗ[R₂] M₂ ⧸ LinearMap.range f), LinearMap.comp u f = LinearMap.comp v f → u = v) → LinearMap.range f = ⊤\",\n  \"isProp\": true,\n  \"docString\": \"An epimorphism is surjective. \"}]\n", "prompt_cons": "/-- Any injective endomorphism of an Artinian module is surjective. -/\ntheorem ∀ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  [inst_3 : IsArtinian R M] (f : M →ₗ[R] M), Function.Injective ↑f → Function.Surjective ↑f :=\n\n/-- A group homomorphism is injective iff its kernel is trivial. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : Group α] [inst_1 : Group β] {f : α → β},\n  IsGroupHom f → (Function.Injective f ↔ ∀ (a : α), f a = 1 → a = 1) :=\n\n/-- Any injective polynomial map over an algebraic extension of a finite field is surjective. -/\ntheorem ∀ {ι : Type u_1} {K : Type u_2} {R : Type u_3} [inst : Field K] [inst_1 : Finite K] [inst_2 : CommRing R]\n  [inst_3 : Finite ι] [inst_4 : Algebra K R],\n  Algebra.IsAlgebraic K R →\n    ∀ (ps : ι → MvPolynomial ι R),\n      (Function.Injective fun v i => ↑(MvPolynomial.eval v) (ps i)) →\n        Function.Surjective fun v i => ↑(MvPolynomial.eval v) (ps i) :=\n\n/-- Any surjective endomorphism of a Noetherian module is injective. -/\ntheorem ∀ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  [inst_3 : IsNoetherian R M] (f : M →ₗ[R] M), Function.Surjective ↑f → Function.Injective ↑f :=\n\n/-- Every graph homomorphism from a complete graph is injective. -/\ntheorem ∀ {V : Type u} {W : Type v} {G' : SimpleGraph W} (f : ⊤ →g G'), Function.Injective ↑f :=\n\n/-- The ring homomorphism is surjective -/\ntheorem ∀ {R₁ : Type u_1} {R₂ : Type u_2} [inst : Semiring R₁] [inst_1 : Semiring R₂] {σ : R₁ →+* R₂}\n  [self : RingHomSurjective σ], Function.Surjective ↑σ :=\n\n/-- An additive group homomorphism is injective if its kernel is trivial. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : AddGroup α] [inst_1 : AddGroup β] {f : α → β},\n  IsAddGroupHom f → (Function.Injective f ↔ ∀ (a : α), f a = 0 → a = 0) :=\n\n/-- Any injective endomorphism of an Artinian module is bijective. -/\ntheorem ∀ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  [inst_3 : IsArtinian R M] (f : M →ₗ[R] M), Function.Injective ↑f → Function.Bijective ↑f :=\n\n/-- On a finite-dimensional space, an injective linear map is surjective. -/\ntheorem ∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V] {f : V →ₗ[K] V}, Function.Injective ↑f → Function.Surjective ↑f :=\n\n/-- Group homomorphisms preserve inverse. -/\ntheorem ∀ {G : Type u_1} {H : Type u_2} {F : Type u_3} [inst : Group G] [inst_1 : DivisionMonoid H]\n  [inst_2 : MonoidHomClass F G H] (f : F) (a : G), ↑f a⁻¹ = (↑f a)⁻¹ :=\n\n/-- Any surjective endomorphism of a Noetherian module is bijective. -/\ntheorem ∀ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  [inst_3 : IsNoetherian R M] (f : M →ₗ[R] M), Function.Surjective ↑f → Function.Bijective ↑f :=\n\n/-- The image of a surjective torsion group homomorphism is torsion. -/\ntheorem ∀ {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : Group H] {f : G →* H},\n  Function.Surjective ↑f → Monoid.IsTorsion G → Monoid.IsTorsion H :=\n\n/-- The natural homomorphism from a monoid to its quotient by a congruence relation is\nsurjective. -/\ntheorem ∀ {M : Type u_1} [inst : MulOneClass M] {c : Con M}, Function.Surjective ↑(Con.mk' c) :=\n\n/-- The induced algebra morphism from the quotient by the kernel is injective. -/\ntheorem ∀ {R₁ : Type u_1} {A : Type u_2} {B : Type u_3} [inst : CommSemiring R₁] [inst_1 : CommRing A] [inst_2 : CommRing B]\n  [inst_3 : Algebra R₁ A] [inst_4 : Algebra R₁ B] (f : A →ₐ[R₁] B), Function.Injective ↑(Ideal.kerLiftAlg f) :=\n\n/-- The canonical map from the type to the free group is an injection. -/\ntheorem ∀ {α : Type u}, Function.Injective FreeGroup.of :=\n\n/-- A group homomorphism sends inverses to inverses. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : Group α] [inst_1 : Group β] {f : α → β}, IsGroupHom f → ∀ (a : α), f a⁻¹ = (f a)⁻¹ :=\n\n/-- A group homomorphism is a monoid homomorphism. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : Group α] [inst_1 : Group β] {f : α → β}, IsGroupHom f → IsMonoidHom f :=\n\n/-- A monoid homomorphism `f` induces an injective homomorphism on the quotient by `f`'s kernel. -/\ntheorem ∀ {M : Type u_1} {P : Type u_2} [inst : MulOneClass M] [inst_1 : MulOneClass P] (f : M →* P),\n  Function.Injective ↑(Con.kerLift f) :=\n\n/-- A group homomorphism sends 1 to 1. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : Group α] [inst_1 : Group β] {f : α → β}, IsGroupHom f → f 1 = 1 :=\n\n/-- An epimorphism is surjective. -/\ntheorem ∀ {R : Type u_1} {M : Type u_3} {R₂ : Type u_2} {M₂ : Type u_4} [inst : Ring R] [inst_1 : Ring R₂]\n  [inst_2 : AddCommMonoid M] [inst_3 : AddCommGroup M₂] [inst_4 : Module R M] [inst_5 : Module R₂ M₂] {τ₁₂ : R →+* R₂}\n  [inst_6 : RingHomSurjective τ₁₂] {f : M →ₛₗ[τ₁₂] M₂},\n  (∀ (u v : M₂ →ₗ[R₂] M₂ ⧸ LinearMap.range f), LinearMap.comp u f = LinearMap.comp v f → u = v) → LinearMap.range f = ⊤ :=\n\n/-- Every injective homomorphism from a finitely generated free group to itself is surjective. -/\ntheorem", "choices": ["∀ {α : Type u} [inst : Fintype α] (f : FreeGroup α →* FreeGroup α), Function.Injective ↑f → Function.Surjective ↑f ", "∀ {α : Type u} [inst : Fintype α] (f : FreeGroup α →* FreeGroup α), Function.Injective ↑f → Function.Surjective ↑f ", "∀ {α : Type u} [inst : Fintype α] {f : FreeGroup α → FreeGroup α},\n  (Function.Injective f) → (Function.Surjective f) ", "∀ {α : Type u} [inst : Fintype α] {f : FreeGroup α → FreeGroup α},\n  Function.Injective f → Function.Surjective f ", "∀ {α : Type u} [inst : Fintype α] {G : FreeGroup α} (f : G →* G), Function.Injective ↑f → Function.Surjective ↑f ", "∀ {ι : Type u_1} [inst : Fintype ι] {f : FreeGroup ι →* FreeGroup ι},\n  Function.Injective ↑f → Function.Surjective ↑f ", "∀ {α : Type u} [inst : Fintype α] (f : FreeGroup α →* FreeGroup α), Function.Injective ↑f → Function.Surjective ↑f ", "∀ {α : Type u} [inst : Fintype α] {f : FreeGroup α →* FreeGroup α}, Function.Injective ↑f → Function.Surjective ↑f ", "∀ {α : Type u} [inst : Fintype α] (f : FreeGroup α →* FreeGroup α), Function.Injective ↑f → Function.Surjective ↑f ", "∀ {α : Type u} [inst : Fintype α] (f : FreeGroup α → FreeGroup α), Function.Injective ↑f → Function.Surjective ↑f "]}
{"docString": "Every division ring is either a field or finite.", "prompts": "[{\"theorem\":\n  \"∀ {K : Type u_1} [inst : DivisionRing K] {Γ₀ : Type u_2} [inst_1 : LinearOrderedCommGroupWithZero Γ₀]\\n  [inst_2 : Valued K Γ₀], SeparatedSpace K\",\n  \"isProp\": true,\n  \"docString\": \"A valued division ring is separated. \"},\n {\"theorem\": \"∀ (K : Type u) [inst : Field K], ValuationRing K\",\n  \"isProp\": true,\n  \"docString\": \"A field is a valuation ring. \"},\n {\"theorem\":\n  \"∀ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L)\\n  {x y : L}, x ∈ S → y ∈ S → x / y ∈ S\",\n  \"isProp\": true,\n  \"docString\": \"An intermediate field is closed under division. \"},\n {\"theorem\":\n  \"∀ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L),\\n  1 ∈ S\",\n  \"isProp\": true,\n  \"docString\": \"An intermediate field contains the ring's 1. \"},\n {\"theorem\":\n  \"∀ (K : Type u_1) (L : Type u_2) [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L]\\n  [inst_3 : FiniteDimensional K L], Algebra.IsIntegral K L\",\n  \"isProp\": true,\n  \"docString\": \"A field extension is integral if it is finite. \"},\n {\"theorem\":\n  \"∀ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L),\\n  0 ∈ S\",\n  \"isProp\": true,\n  \"docString\": \"An intermediate field contains the ring's 0. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : LinearOrderedSemifield α] [inst_1 : FloorSemiring α] (m n : ℕ), ⌊↑m / ↑n⌋₊ = m / n\",\n  \"isProp\": true,\n  \"docString\": \"Natural division is the floor of field division. \"},\n {\"theorem\":\n  \"CategoryTheory.Limits.HasLimitsOfSize.{v, v, max u v, max (u + 1) (v + 1)} CommSemiRingCatMax\",\n  \"isProp\": true,\n  \"docString\": \"The category of rings has all limits. \"},\n {\"theorem\":\n  \"∀ {K : Type u} [inst : DivisionSemiring K] (I : Ideal K), I = ⊥ ∨ I = ⊤\",\n  \"isProp\": true,\n  \"docString\": \"All ideals in a division (semi)ring are trivial. \"},\n {\"theorem\": \"∀ {R : Type u} [inst : Semiring R], IsField R → ∃ x y, x ≠ y\",\n  \"isProp\": true,\n  \"docString\":\n  \"For a semiring to be a field, it must have two distinct elements. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : LinearOrderedSemifield α] {m n : ℕ}, ↑(m / n) ≤ ↑m / ↑n\",\n  \"isProp\": true,\n  \"docString\": \"Natural division is always less than division in the field. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : Fintype α] [inst_1 : Field α], IsPrimePow (Fintype.card α)\",\n  \"isProp\": true,\n  \"docString\": \"A finite field has prime power cardinality. \"},\n {\"theorem\":\n  \"∀ (R : Type u_1) [inst : NonAssocRing R] (p : ℕ) [inst : CharP R p] [inst : Finite R], p ≠ 0\",\n  \"isProp\": true,\n  \"docString\": \"The characteristic of a finite ring cannot be zero. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : NormedDivisionRing α], TopologicalDivisionRing α\",\n  \"isProp\": true,\n  \"docString\": \"A normed division ring is a topological division ring. \"},\n {\"theorem\":\n  \"∀ (α : Type u_1) [inst : LinearOrderedField α] [inst_1 : FloorRing α], Archimedean α\",\n  \"isProp\": true,\n  \"docString\": \"A linear ordered field that is a floor ring is archimedean. \"},\n {\"theorem\":\n  \"∀ (K : Type u_1) (L : Type u_2) [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L]\\n  [inst_3 : FiniteDimensional K L], Algebra.IsAlgebraic K L\",\n  \"isProp\": true,\n  \"docString\": \"A field extension is algebraic if it is finite. \"},\n {\"theorem\":\n  \"∀ {K : Type u} [inst : Field K] (s : Subfield K) {x y : K}, x ∈ s → y ∈ s → x / y ∈ s\",\n  \"isProp\": true,\n  \"docString\": \"A subfield is closed under division. \"},\n {\"theorem\":\n  \"∀ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L)\\n  {x y : L}, x ∈ S → y ∈ S → x * y ∈ S\",\n  \"isProp\": true,\n  \"docString\": \"An intermediate field is closed under multiplication. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : ConditionallyCompleteLinearOrderedField α], Archimedean α\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any conditionally complete linearly ordered field is archimedean. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : PseudoMetricSpace α] {s : Set α}, Set.Finite s → Metric.Bounded s\",\n  \"isProp\": true,\n  \"docString\": \"A finite set is bounded \"}]\n", "prompt_cons": "/-- A valued division ring is separated. -/\ntheorem ∀ {K : Type u_1} [inst : DivisionRing K] {Γ₀ : Type u_2} [inst_1 : LinearOrderedCommGroupWithZero Γ₀]\n  [inst_2 : Valued K Γ₀], SeparatedSpace K :=\n\n/-- A field is a valuation ring. -/\ntheorem ∀ (K : Type u) [inst : Field K], ValuationRing K :=\n\n/-- An intermediate field is closed under division. -/\ntheorem ∀ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L)\n  {x y : L}, x ∈ S → y ∈ S → x / y ∈ S :=\n\n/-- An intermediate field contains the ring's 1. -/\ntheorem ∀ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L),\n  1 ∈ S :=\n\n/-- A field extension is integral if it is finite. -/\ntheorem ∀ (K : Type u_1) (L : Type u_2) [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L]\n  [inst_3 : FiniteDimensional K L], Algebra.IsIntegral K L :=\n\n/-- An intermediate field contains the ring's 0. -/\ntheorem ∀ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L),\n  0 ∈ S :=\n\n/-- Natural division is the floor of field division. -/\ntheorem ∀ {α : Type u_1} [inst : LinearOrderedSemifield α] [inst_1 : FloorSemiring α] (m n : ℕ), ⌊↑m / ↑n⌋₊ = m / n :=\n\n/-- The category of rings has all limits. -/\ntheorem CategoryTheory.Limits.HasLimitsOfSize.{v, v, max u v, max (u + 1) (v + 1)} CommSemiRingCatMax :=\n\n/-- All ideals in a division (semi)ring are trivial. -/\ntheorem ∀ {K : Type u} [inst : DivisionSemiring K] (I : Ideal K), I = ⊥ ∨ I = ⊤ :=\n\n/-- For a semiring to be a field, it must have two distinct elements. -/\ntheorem ∀ {R : Type u} [inst : Semiring R], IsField R → ∃ x y, x ≠ y :=\n\n/-- Natural division is always less than division in the field. -/\ntheorem ∀ {α : Type u_1} [inst : LinearOrderedSemifield α] {m n : ℕ}, ↑(m / n) ≤ ↑m / ↑n :=\n\n/-- A finite field has prime power cardinality. -/\ntheorem ∀ {α : Type u_1} [inst : Fintype α] [inst_1 : Field α], IsPrimePow (Fintype.card α) :=\n\n/-- The characteristic of a finite ring cannot be zero. -/\ntheorem ∀ (R : Type u_1) [inst : NonAssocRing R] (p : ℕ) [inst : CharP R p] [inst : Finite R], p ≠ 0 :=\n\n/-- A normed division ring is a topological division ring. -/\ntheorem ∀ {α : Type u_1} [inst : NormedDivisionRing α], TopologicalDivisionRing α :=\n\n/-- A linear ordered field that is a floor ring is archimedean. -/\ntheorem ∀ (α : Type u_1) [inst : LinearOrderedField α] [inst_1 : FloorRing α], Archimedean α :=\n\n/-- A field extension is algebraic if it is finite. -/\ntheorem ∀ (K : Type u_1) (L : Type u_2) [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L]\n  [inst_3 : FiniteDimensional K L], Algebra.IsAlgebraic K L :=\n\n/-- A subfield is closed under division. -/\ntheorem ∀ {K : Type u} [inst : Field K] (s : Subfield K) {x y : K}, x ∈ s → y ∈ s → x / y ∈ s :=\n\n/-- An intermediate field is closed under multiplication. -/\ntheorem ∀ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L)\n  {x y : L}, x ∈ S → y ∈ S → x * y ∈ S :=\n\n/-- Any conditionally complete linearly ordered field is archimedean. -/\ntheorem ∀ {α : Type u_1} [inst : ConditionallyCompleteLinearOrderedField α], Archimedean α :=\n\n/-- A finite set is bounded -/\ntheorem ∀ {α : Type u} [inst : PseudoMetricSpace α] {s : Set α}, Set.Finite s → Metric.Bounded s :=\n\n/-- Every division ring is either a field or finite. -/\ntheorem", "choices": ["∀ {K : Type u} [inst : DivisionRing K], IsField K ∨ Fintype K ", "∀ (K : Type u_1) [inst : DivisionRing K], IsField K ∨ Fintype K ", "∀ {R : Type u} [inst : DivisionRing R], IsField R ∨ Fintype R ", "∀ (K : Type u_1) [inst : DivisionRing K], IsField K ∨ Finite K ", "∀ {K : Type u_1} [inst : DivisionRing K], IsField K ∨ Finite K ", "∀ {K : Type u} [inst : DivisionRing K], IsField K ∨ Fintype K ", "∀ (K : Type u_1) [inst : DivisionRing K], (IsField K) ∨ Finite K ", "∀ (K : Type u_1) [inst : DivisionRing K], IsField K ∨ Nonempty (Fintype K) ", "∀ {R : Type u} [inst : DivisionRing R], IsField R ∨ Fintype R ", "∀ (K : Type u_1) [inst : DivisionRing K], IsField K ∨ Fintype K "]}
{"docString": "Every natural number is the product of two primes.", "prompts": "[{\"theorem\": \"Set.InjOn Nat.factorization {x | x ≠ 0}\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every nonzero natural number has a unique prime factorization \"},\n {\"theorem\":\n  \"∀ {a b x y u v : ℕ}, a = x ^ 2 + y ^ 2 → b = u ^ 2 + v ^ 2 → ∃ r s, a * b = r ^ 2 + s ^ 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of natural numbers that are sums of two squares is closed under multiplication. \"},\n {\"theorem\": \"∀ {m n : ℕ}, (∀ (a : ℕ), a ∣ m ↔ a ∣ n) ↔ m = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two natural numbers are equal if and only if they have the same divisors. \"},\n {\"theorem\": \"∀ {m n : ℕ}, (∀ (a : ℕ), m ∣ a ↔ n ∣ a) ↔ m = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two natural numbers are equal if and only if they have the same multiples. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : CancelCommMonoidWithZero α] [dec_irr : (p : Associates α) → Decidable (Irreducible p)]\\n  [inst_1 : UniqueFactorizationMonoid α] [dec : DecidableEq α] [dec' : DecidableEq (Associates α)] {a p : Associates α},\\n  Irreducible p →\\n    ∀ [inst_2 : (n : ℕ) → Decidable (a ∣ p ^ n)] {n : ℕ} (h : a ∣ p ^ n),\\n      a = p ^ Nat.find (_ : ∃ n, (fun n => a ∣ p ^ n) n)\",\n  \"isProp\": true,\n  \"docString\": \"The only divisors of prime powers are prime powers. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : Semiring α] {I : Ideal α} [self : Ideal.IsPrime I] {x y : α}, x * y ∈ I → x ∈ I ∨ y ∈ I\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a product lies in the prime ideal, then at least one element lies in the prime ideal. \"},\n {\"theorem\":\n  \"∀ (a b : ℕ), a ≠ 0 → b ≠ 0 → (a = b ↔ ∀ (p : ℕ), Nat.Prime p → padicValNat p a = padicValNat p b)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two positive naturals are equal if their prime padic valuations are equal \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : LinearOrderedRing α] [inst_1 : Archimedean α] {x y : α},\\n  1 ≤ x → 1 < y → ∃ n, y ^ n ≤ x ∧ x < y ^ (n + 1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every x greater than or equal to 1 is between two successive\\nnatural-number powers of every y greater than one. \"},\n {\"theorem\": \"∀ (p : ℕ) [inst : Fact (Nat.Prime p)], Prime ↑p ↔ p % 4 = 3\",\n  \"isProp\": true,\n  \"docString\":\n  \"A prime natural number is prime in `ℤ[i]` if and only if it is `3` mod `4` \"},\n {\"theorem\":\n  \"∀ {R : Type u_2} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R] {ι : Type u_1} (s : Finset ι)\\n  (f : ι → Ideal R) (e : ι → ℕ),\\n  (∀ (i : ι), i ∈ s → Prime (f i)) →\\n    (∀ (i : ι), i ∈ s → ∀ (j : ι), j ∈ s → i ≠ j → f i ≠ f j) →\\n      (Finset.inf s fun i => f i ^ e i) = Finset.prod s fun i => f i ^ e i\",\n  \"isProp\": true,\n  \"docString\":\n  \"The intersection of distinct prime powers in a Dedekind domain is the product of these\\nprime powers. \"},\n {\"theorem\": \"∀ {n : ℕ}, 1 < n → ¬Nat.Prime n → FermatPsp n 1\",\n  \"isProp\": true,\n  \"docString\": \"All composite numbers are Fermat pseudoprimes to base 1.\\n\"},\n {\"theorem\":\n  \"∀ {A : Type u_1} {B : Type u_2} [inst : Field A] [inst_1 : Ring B] [inst_2 : IsDomain B] [inst_3 : Algebra A B] {x : B},\\n  IsIntegral A x → Prime (minpoly A x)\",\n  \"isProp\": true,\n  \"docString\": \"A minimal polynomial is prime. \"},\n {\"theorem\": \"∀ (n : ℕ), Nat.factorization n = 0 ↔ n = 0 ∨ n = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The only numbers with empty prime factorization are `0` and `1` \"},\n {\"theorem\":\n  \"∀ (R : Type u) [inst : Semiring R] (q : ℕ) [hq : ExpChar R q], Nat.Prime q ∨ q = 1\",\n  \"isProp\": true,\n  \"docString\": \"The exponential characteristic is a prime number or one. \"},\n {\"theorem\": \"∀ {m n : ℕ}, Odd n → m ∣ n → m ≠ 2\",\n  \"isProp\": true,\n  \"docString\": \"`2` is not a factor of an odd natural number. \"},\n {\"theorem\": \"∀ (self : ℚ), Nat.coprime (Int.natAbs self.num) self.den\",\n  \"isProp\": true,\n  \"docString\":\n  \"The numerator and denominator are coprime: it is in \\\"reduced form\\\". \"},\n {\"theorem\":\n  \"∀ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F = 2 → ∀ (a : F), IsSquare a\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a finite field of characteristic `2`, all elements are squares. \"},\n {\"theorem\": \"∀ (n : ℕ), n ≠ 0 → ∃ p, Nat.Prime p ∧ n < p ∧ p ≤ 2 * n\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Bertrand's Postulate**: For any positive natural number, there is a prime which is greater than\\nit, but no more than twice as large.\\n\"},\n {\"theorem\": \"∀ {p q : ℕ}, Nat.Prime p → ↑(Nat.factorization p) q ≠ 0 → p = q\",\n  \"isProp\": true,\n  \"docString\": \"The only prime factor of prime `p` is `p` itself. \"},\n {\"theorem\":\n  \"∀ (n k : ℕ),\\n  k ≤ n → (Finset.prod (Finset.range (n + 1)) fun p => p ^ ↑(Nat.factorization (Nat.choose n k)) p) = Nat.choose n k\",\n  \"isProp\": true,\n  \"docString\":\n  \"A binomial coefficient is the product of its prime factors, which are at most `n`. \"}]\n", "prompt_cons": "/-- Every nonzero natural number has a unique prime factorization -/\ntheorem Set.InjOn Nat.factorization {x | x ≠ 0} :=\n\n/-- The set of natural numbers that are sums of two squares is closed under multiplication. -/\ntheorem ∀ {a b x y u v : ℕ}, a = x ^ 2 + y ^ 2 → b = u ^ 2 + v ^ 2 → ∃ r s, a * b = r ^ 2 + s ^ 2 :=\n\n/-- Two natural numbers are equal if and only if they have the same divisors. -/\ntheorem ∀ {m n : ℕ}, (∀ (a : ℕ), a ∣ m ↔ a ∣ n) ↔ m = n :=\n\n/-- Two natural numbers are equal if and only if they have the same multiples. -/\ntheorem ∀ {m n : ℕ}, (∀ (a : ℕ), m ∣ a ↔ n ∣ a) ↔ m = n :=\n\n/-- The only divisors of prime powers are prime powers. -/\ntheorem ∀ {α : Type u_1} [inst : CancelCommMonoidWithZero α] [dec_irr : (p : Associates α) → Decidable (Irreducible p)]\n  [inst_1 : UniqueFactorizationMonoid α] [dec : DecidableEq α] [dec' : DecidableEq (Associates α)] {a p : Associates α},\n  Irreducible p →\n    ∀ [inst_2 : (n : ℕ) → Decidable (a ∣ p ^ n)] {n : ℕ} (h : a ∣ p ^ n),\n      a = p ^ Nat.find (_ : ∃ n, (fun n => a ∣ p ^ n) n) :=\n\n/-- If a product lies in the prime ideal, then at least one element lies in the prime ideal. -/\ntheorem ∀ {α : Type u} [inst : Semiring α] {I : Ideal α} [self : Ideal.IsPrime I] {x y : α}, x * y ∈ I → x ∈ I ∨ y ∈ I :=\n\n/-- Two positive naturals are equal if their prime padic valuations are equal -/\ntheorem ∀ (a b : ℕ), a ≠ 0 → b ≠ 0 → (a = b ↔ ∀ (p : ℕ), Nat.Prime p → padicValNat p a = padicValNat p b) :=\n\n/-- Every x greater than or equal to 1 is between two successive\nnatural-number powers of every y greater than one. -/\ntheorem ∀ {α : Type u_1} [inst : LinearOrderedRing α] [inst_1 : Archimedean α] {x y : α},\n  1 ≤ x → 1 < y → ∃ n, y ^ n ≤ x ∧ x < y ^ (n + 1) :=\n\n/-- A prime natural number is prime in `ℤ[i]` if and only if it is `3` mod `4` -/\ntheorem ∀ (p : ℕ) [inst : Fact (Nat.Prime p)], Prime ↑p ↔ p % 4 = 3 :=\n\n/-- The intersection of distinct prime powers in a Dedekind domain is the product of these\nprime powers. -/\ntheorem ∀ {R : Type u_2} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R] {ι : Type u_1} (s : Finset ι)\n  (f : ι → Ideal R) (e : ι → ℕ),\n  (∀ (i : ι), i ∈ s → Prime (f i)) →\n    (∀ (i : ι), i ∈ s → ∀ (j : ι), j ∈ s → i ≠ j → f i ≠ f j) →\n      (Finset.inf s fun i => f i ^ e i) = Finset.prod s fun i => f i ^ e i :=\n\n/-- All composite numbers are Fermat pseudoprimes to base 1. -/\ntheorem ∀ {n : ℕ}, 1 < n → ¬Nat.Prime n → FermatPsp n 1 :=\n\n/-- A minimal polynomial is prime. -/\ntheorem ∀ {A : Type u_1} {B : Type u_2} [inst : Field A] [inst_1 : Ring B] [inst_2 : IsDomain B] [inst_3 : Algebra A B] {x : B},\n  IsIntegral A x → Prime (minpoly A x) :=\n\n/-- The only numbers with empty prime factorization are `0` and `1` -/\ntheorem ∀ (n : ℕ), Nat.factorization n = 0 ↔ n = 0 ∨ n = 1 :=\n\n/-- The exponential characteristic is a prime number or one. -/\ntheorem ∀ (R : Type u) [inst : Semiring R] (q : ℕ) [hq : ExpChar R q], Nat.Prime q ∨ q = 1 :=\n\n/-- `2` is not a factor of an odd natural number. -/\ntheorem ∀ {m n : ℕ}, Odd n → m ∣ n → m ≠ 2 :=\n\n/-- The numerator and denominator are coprime: it is in \"reduced form\". -/\ntheorem ∀ (self : ℚ), Nat.coprime (Int.natAbs self.num) self.den :=\n\n/-- In a finite field of characteristic `2`, all elements are squares. -/\ntheorem ∀ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F = 2 → ∀ (a : F), IsSquare a :=\n\n/-- **Bertrand's Postulate**: For any positive natural number, there is a prime which is greater than\nit, but no more than twice as large. -/\ntheorem ∀ (n : ℕ), n ≠ 0 → ∃ p, Nat.Prime p ∧ n < p ∧ p ≤ 2 * n :=\n\n/-- The only prime factor of prime `p` is `p` itself. -/\ntheorem ∀ {p q : ℕ}, Nat.Prime p → ↑(Nat.factorization p) q ≠ 0 → p = q :=\n\n/-- A binomial coefficient is the product of its prime factors, which are at most `n`. -/\ntheorem ∀ (n k : ℕ),\n  k ≤ n → (Finset.prod (Finset.range (n + 1)) fun p => p ^ ↑(Nat.factorization (Nat.choose n k)) p) = Nat.choose n k :=\n\n/-- Every natural number is the product of two primes. -/\ntheorem", "choices": ["∀ (n : ℕ), n ≠ 0 → ∃ (p q : ℕ), Nat.Prime p ∧ Nat.Prime q ∧ n = p * q ", "∀ (n : ℕ), n ≠ 0 → n ≠ 1 → ∃ p q, Nat.Prime p ∧ Nat.Prime q ∧ n = p * q ", "∀ (n : ℕ), n ≠ 0 → n ≠ 1 → ∃ (p q : ℕ), Nat.Prime p ∧ Nat.Prime q ∧ n = p * q ", "∀ (n : ℕ), n > 1 → ∃ p q, Nat.Prime p ∧ Nat.Prime q ∧ n = p * q ", "∀ (n : ℕ), n > 1 → ∃ p q : ℕ, Nat.Prime p ∧ Nat.Prime q ∧ n = p * q ", "∀ (n : ℕ), n ≠ 0 → ∃ p q : ℕ, Nat.Prime p ∧ Nat.Prime q ∧ n = p * q ", "∀ (n : ℕ), n ≠ 0 → ∃ p q, Nat.Prime p ∧ Nat.Prime q ∧ n = p * q ", "∀ (n : ℕ), n ≠ 0 → ∃ p q, Nat.Prime p ∧ Nat.Prime q ∧ n = p * q ", "∀ (n : ℕ), n ≠ 0 → ∃ (p q : ℕ), Nat.Prime p ∧ Nat.Prime q ∧ n = p * q ", "∀ (n : ℕ), n ≠ 0 → ∃ (p q : ℕ), Nat.Prime p ∧ Nat.Prime q ∧ n = p * q "]}
{"docString": "Every even number is the square of a natural number.", "prompts": "[{\"theorem\":\n  \"∀ {a b x y u v : ℕ}, a = x ^ 2 + y ^ 2 → b = u ^ 2 + v ^ 2 → ∃ r s, a * b = r ^ 2 + s ^ 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of natural numbers that are sums of two squares is closed under multiplication. \"},\n {\"theorem\": \"∀ {m n : ℕ}, (∀ (a : ℕ), m ∣ a ↔ n ∣ a) ↔ m = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two natural numbers are equal if and only if they have the same multiples. \"},\n {\"theorem\":\n  \"∀ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F = 2 → ∀ (a : F), IsSquare a\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a finite field of characteristic `2`, all elements are squares. \"},\n {\"theorem\":\n  \"∀ (a b c d x y z w : ℕ),\\n  Int.natAbs (↑a * ↑x - ↑b * ↑y - ↑c * ↑z - ↑d * ↑w) ^ 2 + Int.natAbs (↑a * ↑y + ↑b * ↑x + ↑c * ↑w - ↑d * ↑z) ^ 2 +\\n        Int.natAbs (↑a * ↑z - ↑b * ↑w + ↑c * ↑x + ↑d * ↑y) ^ 2 +\\n      Int.natAbs (↑a * ↑w + ↑b * ↑z - ↑c * ↑y + ↑d * ↑x) ^ 2 =\\n    (a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2) * (x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2)\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Euler's four-square identity**, a version for natural numbers. \"},\n {\"theorem\": \"Set.InjOn Nat.factorization {x | x ≠ 0}\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every nonzero natural number has a unique prime factorization \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u𝕜} {G : Type uG} {E : Type uE} {E' : Type uE'} {F : Type uF} [inst : NormedAddCommGroup E]\\n  [inst_1 : NormedAddCommGroup E'] [inst_2 : NormedAddCommGroup F] {f : G → E} {g : G → E'} {x : G}\\n  [inst_3 : NontriviallyNormedField 𝕜] [inst_4 : NormedSpace 𝕜 E] [inst_5 : NormedSpace 𝕜 E'] [inst_6 : NormedSpace 𝕜 F]\\n  (L : E →L[𝕜] E' →L[𝕜] F) [inst_7 : MeasurableSpace G] {μ : MeasureTheory.Measure G} [inst_8 : NormedSpace ℝ F]\\n  [inst_9 : AddCommGroup G] [inst_10 : MeasureTheory.Measure.IsAddLeftInvariant μ]\\n  [inst_11 : MeasureTheory.Measure.IsNegInvariant μ] [inst_12 : MeasurableNeg G] [inst_13 : MeasurableAdd G],\\n  (∀ᵐ (x : G) ∂μ, f (-x) = f x) → (∀ᵐ (x : G) ∂μ, g (-x) = g x) → convolution f g L (-x) = convolution f g L x\",\n  \"isProp\": true,\n  \"docString\": \"The convolution of two even functions is also even. \"},\n {\"theorem\": \"∀ {n : ℕ}, IsSquare (-1) → ∃ x y, n = x ^ 2 + y ^ 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `-1` is a square modulo the natural number `n`, then `n` is a sum of two squares. \"},\n {\"theorem\": \"∀ {m n : ℕ}, (∀ (a : ℕ), a ∣ m ↔ a ∣ n) ↔ m = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two natural numbers are equal if and only if they have the same divisors. \"},\n {\"theorem\":\n  \"∀ {n : ℕ}, (∃ x y, n = x ^ 2 + y ^ 2) ↔ ∀ {q : ℕ}, Nat.Prime q → q % 4 = 3 → Even (padicValNat q n)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A (positive) natural number `n` is a sum of two squares if and only if the exponent of\\nevery prime `q` such that `q % 4 = 3` in the prime factorization of `n` is even.\\n(The assumption `0 < n` is not present, since for `n = 0`, both sides are satisfied;\\nthe right hand side holds, since `padicValNat q 0 = 0` by definition.) \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : LinearOrderedRing α] [inst_1 : Archimedean α] {x y : α},\\n  1 ≤ x → 1 < y → ∃ n, y ^ n ≤ x ∧ x < y ^ (n + 1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every x greater than or equal to 1 is between two successive\\nnatural-number powers of every y greater than one. \"},\n {\"theorem\": \"∀ {a : ℕ}, ↑(Nat.sqrt a) ≤ Real.sqrt ↑a\",\n  \"isProp\": true,\n  \"docString\": \"The natural square root is at most the real square root \"},\n {\"theorem\": \"∀ {n : ℕ}, n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3\",\n  \"isProp\": true,\n  \"docString\": \"A natural number is odd iff it has residue `1` or `3` mod `4`\"},\n {\"theorem\":\n  \"∀ {n : ℕ}, (∃ x y, n = x ^ 2 + y ^ 2) ↔ ∃ a b, n = a ^ 2 * b ∧ IsSquare (-1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A natural number `n` is a sum of two squares if and only if `n = a^2 * b` with natural\\nnumbers `a` and `b` such that `-1` is a square modulo `b`. \"},\n {\"theorem\":\n  \"∀ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F ≠ 2 → ∃ a, ¬IsSquare a\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a finite field of odd characteristic, not every element is a square. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : LinearOrderedRing α] {x y : α}, x * x + y * y = 0 ↔ x = 0 ∧ y = 0\",\n  \"isProp\": true,\n  \"docString\": \"The sum of two squares is zero iff both elements are zero. \"},\n {\"theorem\": \"∀ {m n : ℕ}, Odd n → m ∣ n → m ≠ 2\",\n  \"isProp\": true,\n  \"docString\": \"`2` is not a factor of an odd natural number. \"},\n {\"theorem\": \"∀ {a : ℕ}, Real.sqrt ↑a ≤ ↑(Nat.sqrt a) + 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The real square root is at most the natural square root plus one \"},\n {\"theorem\":\n  \"∀ {n x y : ℕ}, n = x ^ 2 + y ^ 2 → Nat.coprime x y → IsSquare (-1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the natural number `n` is a sum of two squares of coprime natural numbers, then\\n`-1` is a square modulo `n`. \"},\n {\"theorem\":\n  \"∀ (a b : ℕ), a ≠ 0 → b ≠ 0 → (a = b ↔ ∀ (p : ℕ), Nat.Prime p → padicValNat p a = padicValNat p b)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two positive naturals are equal if their prime padic valuations are equal \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : CommRing R] {R' : Type v} [inst_1 : CommRing R'] {χ : MulChar R R'},\\n  MulChar.IsQuadratic χ → ∀ {n : ℕ}, Odd n → χ ^ n = χ\",\n  \"isProp\": true,\n  \"docString\":\n  \"The `n`th power of a quadratic character is itself, when `n` is odd. \"}]\n", "prompt_cons": "/-- The set of natural numbers that are sums of two squares is closed under multiplication. -/\ntheorem ∀ {a b x y u v : ℕ}, a = x ^ 2 + y ^ 2 → b = u ^ 2 + v ^ 2 → ∃ r s, a * b = r ^ 2 + s ^ 2 :=\n\n/-- Two natural numbers are equal if and only if they have the same multiples. -/\ntheorem ∀ {m n : ℕ}, (∀ (a : ℕ), m ∣ a ↔ n ∣ a) ↔ m = n :=\n\n/-- In a finite field of characteristic `2`, all elements are squares. -/\ntheorem ∀ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F = 2 → ∀ (a : F), IsSquare a :=\n\n/-- **Euler's four-square identity**, a version for natural numbers. -/\ntheorem ∀ (a b c d x y z w : ℕ),\n  Int.natAbs (↑a * ↑x - ↑b * ↑y - ↑c * ↑z - ↑d * ↑w) ^ 2 + Int.natAbs (↑a * ↑y + ↑b * ↑x + ↑c * ↑w - ↑d * ↑z) ^ 2 +\n        Int.natAbs (↑a * ↑z - ↑b * ↑w + ↑c * ↑x + ↑d * ↑y) ^ 2 +\n      Int.natAbs (↑a * ↑w + ↑b * ↑z - ↑c * ↑y + ↑d * ↑x) ^ 2 =\n    (a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2) * (x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2) :=\n\n/-- Every nonzero natural number has a unique prime factorization -/\ntheorem Set.InjOn Nat.factorization {x | x ≠ 0} :=\n\n/-- The convolution of two even functions is also even. -/\ntheorem ∀ {𝕜 : Type u𝕜} {G : Type uG} {E : Type uE} {E' : Type uE'} {F : Type uF} [inst : NormedAddCommGroup E]\n  [inst_1 : NormedAddCommGroup E'] [inst_2 : NormedAddCommGroup F] {f : G → E} {g : G → E'} {x : G}\n  [inst_3 : NontriviallyNormedField 𝕜] [inst_4 : NormedSpace 𝕜 E] [inst_5 : NormedSpace 𝕜 E'] [inst_6 : NormedSpace 𝕜 F]\n  (L : E →L[𝕜] E' →L[𝕜] F) [inst_7 : MeasurableSpace G] {μ : MeasureTheory.Measure G} [inst_8 : NormedSpace ℝ F]\n  [inst_9 : AddCommGroup G] [inst_10 : MeasureTheory.Measure.IsAddLeftInvariant μ]\n  [inst_11 : MeasureTheory.Measure.IsNegInvariant μ] [inst_12 : MeasurableNeg G] [inst_13 : MeasurableAdd G],\n  (∀ᵐ (x : G) ∂μ, f (-x) = f x) → (∀ᵐ (x : G) ∂μ, g (-x) = g x) → convolution f g L (-x) = convolution f g L x :=\n\n/-- If `-1` is a square modulo the natural number `n`, then `n` is a sum of two squares. -/\ntheorem ∀ {n : ℕ}, IsSquare (-1) → ∃ x y, n = x ^ 2 + y ^ 2 :=\n\n/-- Two natural numbers are equal if and only if they have the same divisors. -/\ntheorem ∀ {m n : ℕ}, (∀ (a : ℕ), a ∣ m ↔ a ∣ n) ↔ m = n :=\n\n/-- A (positive) natural number `n` is a sum of two squares if and only if the exponent of\nevery prime `q` such that `q % 4 = 3` in the prime factorization of `n` is even.\n(The assumption `0 < n` is not present, since for `n = 0`, both sides are satisfied;\nthe right hand side holds, since `padicValNat q 0 = 0` by definition.) -/\ntheorem ∀ {n : ℕ}, (∃ x y, n = x ^ 2 + y ^ 2) ↔ ∀ {q : ℕ}, Nat.Prime q → q % 4 = 3 → Even (padicValNat q n) :=\n\n/-- Every x greater than or equal to 1 is between two successive\nnatural-number powers of every y greater than one. -/\ntheorem ∀ {α : Type u_1} [inst : LinearOrderedRing α] [inst_1 : Archimedean α] {x y : α},\n  1 ≤ x → 1 < y → ∃ n, y ^ n ≤ x ∧ x < y ^ (n + 1) :=\n\n/-- The natural square root is at most the real square root -/\ntheorem ∀ {a : ℕ}, ↑(Nat.sqrt a) ≤ Real.sqrt ↑a :=\n\n/-- A natural number is odd iff it has residue `1` or `3` mod `4` -/\ntheorem ∀ {n : ℕ}, n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3 :=\n\n/-- A natural number `n` is a sum of two squares if and only if `n = a^2 * b` with natural\nnumbers `a` and `b` such that `-1` is a square modulo `b`. -/\ntheorem ∀ {n : ℕ}, (∃ x y, n = x ^ 2 + y ^ 2) ↔ ∃ a b, n = a ^ 2 * b ∧ IsSquare (-1) :=\n\n/-- In a finite field of odd characteristic, not every element is a square. -/\ntheorem ∀ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F ≠ 2 → ∃ a, ¬IsSquare a :=\n\n/-- The sum of two squares is zero iff both elements are zero. -/\ntheorem ∀ {α : Type u} [inst : LinearOrderedRing α] {x y : α}, x * x + y * y = 0 ↔ x = 0 ∧ y = 0 :=\n\n/-- `2` is not a factor of an odd natural number. -/\ntheorem ∀ {m n : ℕ}, Odd n → m ∣ n → m ≠ 2 :=\n\n/-- The real square root is at most the natural square root plus one -/\ntheorem ∀ {a : ℕ}, Real.sqrt ↑a ≤ ↑(Nat.sqrt a) + 1 :=\n\n/-- If the natural number `n` is a sum of two squares of coprime natural numbers, then\n`-1` is a square modulo `n`. -/\ntheorem ∀ {n x y : ℕ}, n = x ^ 2 + y ^ 2 → Nat.coprime x y → IsSquare (-1) :=\n\n/-- Two positive naturals are equal if their prime padic valuations are equal -/\ntheorem ∀ (a b : ℕ), a ≠ 0 → b ≠ 0 → (a = b ↔ ∀ (p : ℕ), Nat.Prime p → padicValNat p a = padicValNat p b) :=\n\n/-- The `n`th power of a quadratic character is itself, when `n` is odd. -/\ntheorem ∀ {R : Type u} [inst : CommRing R] {R' : Type v} [inst_1 : CommRing R'] {χ : MulChar R R'},\n  MulChar.IsQuadratic χ → ∀ {n : ℕ}, Odd n → χ ^ n = χ :=\n\n/-- Every even number is the square of a natural number. -/\ntheorem", "choices": ["∀ {n : ℕ}, Even n → ∃ m, n = m ^ 2 ", "∀ {n : ℕ}, Even n → ∃ a, n = a ^ 2 ", "∀ {n : ℕ}, Even n → ∃ x, n = x ^ 2 ", "∀ {n : ℕ}, Even n → ∃ x, n = 2 * x ^ 2 ", "∀ {n : ℕ}, Even n → ∃ m, n = m ^ 2 ", "∀ {n : ℕ}, Even n → ∃ x, n = x ^ 2 ", "∀ {n : ℕ}, Even n → ∃ k, n = 2 * k ^ 2 ", "∀ {n : ℕ}, Even n → ∃ m, n = m ^ 2 ", "∀ {n : ℕ}, Even n → ∃ m, n = m ^ 2 ", "∀ {n : ℕ}, Even n → ∃ x : ℕ, n = x ^ 2 "]}
{"docString": "Every normal subgroup of a group has finite index.", "prompts": "[{\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] {H : Subgroup G} [self : Subgroup.FiniteIndex H], Subgroup.index H ≠ 0\",\n  \"isProp\": true,\n  \"docString\": \"The subgroup has finite index \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : AddGroup G] {H : AddSubgroup G} [self : AddSubgroup.FiniteIndex H], AddSubgroup.index H ≠ 0\",\n  \"isProp\": true,\n  \"docString\": \"The additive subgroup has finite index \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] (H : Subgroup G) [hG : Group.FG G] [inst_1 : Subgroup.FiniteIndex H],\\n  Group.FG { x // x ∈ H }\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Schreier's Lemma**: A finite index subgroup of a finitely generated\\ngroup is finitely generated. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] (P : Subgroup G), Subgroup.FG P ↔ Submonoid.FG P.toSubmonoid\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subgroup is finitely generated if and only if it is finitely generated as a submonoid. \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : Ring R] [inst_1 : StrongRankCondition R] {M : Type v} [inst_2 : AddCommGroup M]\\n  [inst_3 : Module R M] {ι : Type u_1} {s : Set ι}, Basis (↑s) R M → Module.rank R M < Cardinal.aleph0 → Set.Finite s\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a module has a finite dimension, all bases are indexed by a finite set. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\\n  Fintype.card α = p → IsSimpleGroup α\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is simple. \"},\n {\"theorem\":\n  \"∀ (K : Type u) {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {A : Set V},\\n  Set.Finite A → FiniteDimensional K { x // x ∈ Submodule.span K A }\",\n  \"isProp\": true,\n  \"docString\":\n  \"The submodule generated by a finite set is finite-dimensional. \"},\n {\"theorem\":\n  \"{G : Type u_1} → [inst : Group G] → (H : Subgroup G) → [inst_1 : Subgroup.FiniteIndex H] → Fintype (G ⧸ H)\",\n  \"isProp\": false,\n  \"docString\": \"A finite index subgroup has finite quotient. \"},\n {\"theorem\":\n  \"∀ {R : Type u_2} {G : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : Group G] [inst_3 : Finite G]\\n  (f : G →* R), Function.Injective ↑f → IsCyclic G\",\n  \"isProp\": true,\n  \"docString\":\n  \"A finite subgroup of the unit group of an integral domain is cyclic. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] (H₁ H₂ : Subgroup G),\\n  Subgroup.Normal H₁ → Subgroup.Normal H₂ → Disjoint H₁ H₂ → ∀ (x y : G), x ∈ H₁ → y ∈ H₂ → Commute x y\",\n  \"isProp\": true,\n  \"docString\": \"Elements of disjoint, normal subgroups commute. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)], Fintype.card α = p → IsCyclic α\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] (H : Subgroup G) {x y : G}, x ∈ H → y ∈ H → x * y ∈ H\",\n  \"isProp\": true,\n  \"docString\": \"A subgroup is closed under multiplication. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G] (N : Subgroup G)\\n  [inst_3 : Subgroup.Normal N], Subgroup.Normal (Subgroup.topologicalClosure N)\",\n  \"isProp\": true,\n  \"docString\": \"The topological closure of a normal subgroup is normal.\"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : AddGroup G] (H₁ H₂ : AddSubgroup G),\\n  AddSubgroup.Normal H₁ → AddSubgroup.Normal H₂ → Disjoint H₁ H₂ → ∀ (x y : G), x ∈ H₁ → y ∈ H₂ → AddCommute x y\",\n  \"isProp\": true,\n  \"docString\": \"Elements of disjoint, normal subgroups commute.\"},\n {\"theorem\":\n  \"∀ (G : Type u_1) [inst : Group G] [inst_1 : Finite ↑(commutatorSet G)], Finite { x // x ∈ commutator G }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A theorem of Schur: A group with finitely many commutators has finite commutator subgroup. \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : Ring R] [inst_1 : StrongRankCondition R] {M : Type v} [inst_2 : AddCommGroup M]\\n  [inst_3 : Module R M] {ι : Type u_1}, Basis ι R M → Module.rank R M < Cardinal.aleph0 → Nonempty (Fintype ι)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a module has a finite dimension, all bases are indexed by a finite type. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : AddMonoid G] (H : AddSubmonoid G) (x : { x // x ∈ H }), IsOfFinAddOrder x ↔ IsOfFinAddOrder ↑x\",\n  \"isProp\": true,\n  \"docString\": \"Elements of finite order are of finite order in submonoids.\"},\n {\"theorem\":\n  \"∀ {M : Type u_1} {S : Type u_2} [inst : DivInvMonoid M] [inst_1 : SetLike S M] [hSM : SubgroupClass S M] {H : S}\\n  {x y : M}, x ∈ H → y ∈ H → x / y ∈ H\",\n  \"isProp\": true,\n  \"docString\": \"A subgroup is closed under division. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x⁻¹ ↔ IsOfFinOrder x\",\n  \"isProp\": true,\n  \"docString\": \"Inverses of elements of finite order have finite order. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : AddGroup α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\\n  Fintype.card α = p → IsAddCyclic α\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic.\"}]\n", "prompt_cons": "/-- The subgroup has finite index -/\ntheorem ∀ {G : Type u_1} [inst : Group G] {H : Subgroup G} [self : Subgroup.FiniteIndex H], Subgroup.index H ≠ 0 :=\n\n/-- The additive subgroup has finite index -/\ntheorem ∀ {G : Type u_1} [inst : AddGroup G] {H : AddSubgroup G} [self : AddSubgroup.FiniteIndex H], AddSubgroup.index H ≠ 0 :=\n\n/-- **Schreier's Lemma**: A finite index subgroup of a finitely generated\ngroup is finitely generated. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] (H : Subgroup G) [hG : Group.FG G] [inst_1 : Subgroup.FiniteIndex H],\n  Group.FG { x // x ∈ H } :=\n\n/-- A subgroup is finitely generated if and only if it is finitely generated as a submonoid. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] (P : Subgroup G), Subgroup.FG P ↔ Submonoid.FG P.toSubmonoid :=\n\n/-- If a module has a finite dimension, all bases are indexed by a finite set. -/\ntheorem ∀ {R : Type u} [inst : Ring R] [inst_1 : StrongRankCondition R] {M : Type v} [inst_2 : AddCommGroup M]\n  [inst_3 : Module R M] {ι : Type u_1} {s : Set ι}, Basis (↑s) R M → Module.rank R M < Cardinal.aleph0 → Set.Finite s :=\n\n/-- A finite group of prime order is simple. -/\ntheorem ∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\n  Fintype.card α = p → IsSimpleGroup α :=\n\n/-- The submodule generated by a finite set is finite-dimensional. -/\ntheorem ∀ (K : Type u) {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {A : Set V},\n  Set.Finite A → FiniteDimensional K { x // x ∈ Submodule.span K A } :=\n\n/-- A finite index subgroup has finite quotient. -/\ntheorem {G : Type u_1} → [inst : Group G] → (H : Subgroup G) → [inst_1 : Subgroup.FiniteIndex H] → Fintype (G ⧸ H) :=\n\n/-- A finite subgroup of the unit group of an integral domain is cyclic. -/\ntheorem ∀ {R : Type u_2} {G : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : Group G] [inst_3 : Finite G]\n  (f : G →* R), Function.Injective ↑f → IsCyclic G :=\n\n/-- Elements of disjoint, normal subgroups commute. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] (H₁ H₂ : Subgroup G),\n  Subgroup.Normal H₁ → Subgroup.Normal H₂ → Disjoint H₁ H₂ → ∀ (x y : G), x ∈ H₁ → y ∈ H₂ → Commute x y :=\n\n/-- A finite group of prime order is cyclic. -/\ntheorem ∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)], Fintype.card α = p → IsCyclic α :=\n\n/-- A subgroup is closed under multiplication. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] (H : Subgroup G) {x y : G}, x ∈ H → y ∈ H → x * y ∈ H :=\n\n/-- The topological closure of a normal subgroup is normal. -/\ntheorem ∀ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G] (N : Subgroup G)\n  [inst_3 : Subgroup.Normal N], Subgroup.Normal (Subgroup.topologicalClosure N) :=\n\n/-- Elements of disjoint, normal subgroups commute. -/\ntheorem ∀ {G : Type u_1} [inst : AddGroup G] (H₁ H₂ : AddSubgroup G),\n  AddSubgroup.Normal H₁ → AddSubgroup.Normal H₂ → Disjoint H₁ H₂ → ∀ (x y : G), x ∈ H₁ → y ∈ H₂ → AddCommute x y :=\n\n/-- A theorem of Schur: A group with finitely many commutators has finite commutator subgroup. -/\ntheorem ∀ (G : Type u_1) [inst : Group G] [inst_1 : Finite ↑(commutatorSet G)], Finite { x // x ∈ commutator G } :=\n\n/-- If a module has a finite dimension, all bases are indexed by a finite type. -/\ntheorem ∀ {R : Type u} [inst : Ring R] [inst_1 : StrongRankCondition R] {M : Type v} [inst_2 : AddCommGroup M]\n  [inst_3 : Module R M] {ι : Type u_1}, Basis ι R M → Module.rank R M < Cardinal.aleph0 → Nonempty (Fintype ι) :=\n\n/-- Elements of finite order are of finite order in submonoids. -/\ntheorem ∀ {G : Type u_1} [inst : AddMonoid G] (H : AddSubmonoid G) (x : { x // x ∈ H }), IsOfFinAddOrder x ↔ IsOfFinAddOrder ↑x :=\n\n/-- A subgroup is closed under division. -/\ntheorem ∀ {M : Type u_1} {S : Type u_2} [inst : DivInvMonoid M] [inst_1 : SetLike S M] [hSM : SubgroupClass S M] {H : S}\n  {x y : M}, x ∈ H → y ∈ H → x / y ∈ H :=\n\n/-- Inverses of elements of finite order have finite order. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x⁻¹ ↔ IsOfFinOrder x :=\n\n/-- A finite group of prime order is cyclic. -/\ntheorem ∀ {α : Type u} [inst : AddGroup α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\n  Fintype.card α = p → IsAddCyclic α :=\n\n/-- Every normal subgroup of a group has finite index. -/\ntheorem", "choices": ["∀ {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Subgroup.Normal H], Subgroup.FiniteIndex H → Fintype (G ⧸ H) ", "∀ {G : Type u_1} [inst : Group G] (N : Subgroup.Normal G), Subgroup.FiniteIndex N ", "∀ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.Normal H → Subgroup.FiniteIndex H ", "∀ {G : Type u_1} [inst : Group G] {H : Subgroup G} [self : Subgroup.Normal H], Subgroup.index H ≠ 0 ", "∀ {G : Type u_1} [inst : Group G] {H : Subgroup G} [self : Subgroup.Normal H], Subgroup.index H ≠ 0 ", "∀ {G : Type u_1} [inst : Group G] {N : Subgroup G} [self : Subgroup.Normal N], Subgroup.index N ≠ 0 ", "∀ {G : Type u_1} [inst : Group G] (N : Subgroup G) [inst_1 : Subgroup.Normal N], Subgroup.index N ≠ 0 ", "∀ {G : Type u_1} [inst : Group G] {N : Subgroup G} [hN : Subgroup.Normal N], Subgroup.FiniteIndex N ", "∀ {G : Type u_1} [inst : Group G] {N : Subgroup G} [hN : Subgroup.Normal N], Subgroup.FiniteIndex N → Subgroup.index N ≠ 0 ", "∀ {G : Type u_1} [inst : Group G] {H : Subgroup G} [self : Subgroup.Normal H], Subgroup.index H ≠ 0 "]}
{"docString": "The characteristic polynomial of every matrix has real roots.", "prompts": "[{\"theorem\":\n  \"∀ {α : Type u_2} {n : Type u_1} [inst : IsROrC α] {A : Matrix n n α},\\n  Matrix.IsHermitian A → (fun i => ↑(↑IsROrC.re (Matrix.diag A i))) = Matrix.diag A\",\n  \"isProp\": true,\n  \"docString\":\n  \"The diagonal elements of a complex hermitian matrix are real. \"},\n {\"theorem\":\n  \"∀ {f : Polynomial ℂ}, 0 < Polynomial.degree f → ∃ z, Polynomial.IsRoot f z\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Fundamental theorem of algebra**: every non constant complex polynomial\\nhas a root \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} [inst : IsROrC 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\\n  {T : E →ₗ[𝕜] E}, LinearMap.IsSymmetric T → ∀ {μ : 𝕜}, Module.End.HasEigenvalue T μ → ↑(starRingEnd 𝕜) μ = μ\",\n  \"isProp\": true,\n  \"docString\": \"The eigenvalues of a self-adjoint operator are real. \"},\n {\"theorem\":\n  \"∀ (p : Polynomial ℝ),\\n  Finset.card (Multiset.toFinset (Polynomial.roots p)) ≤\\n    Finset.card (Multiset.toFinset (Polynomial.roots (↑Polynomial.derivative p))) + 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The number of roots of a real polynomial is at most the number of roots of its derivative plus\\none. \"},\n {\"theorem\":\n  \"∀ {A : Type u_1} {B : Type u_2} [inst : Field A] [inst_1 : Ring B] [inst_2 : IsDomain B] [inst_3 : Algebra A B] {x : B},\\n  IsIntegral A x → x ≠ 0 → Polynomial.coeff (minpoly A x) 0 ≠ 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"The minimal polynomial of a nonzero element has nonzero constant coefficient. \"},\n {\"theorem\":\n  \"∀ {F : Type u_1} [inst : CommRing F] [inst_1 : Algebra F ℝ] (p : Polynomial F),\\n  Fintype.card ↑(Polynomial.rootSet p ℝ) ≤ Fintype.card ↑(Polynomial.rootSet (↑Polynomial.derivative p) ℝ) + 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The number of real roots of a polynomial is at most the number of roots of its derivative plus\\none. \"},\n {\"theorem\":\n  \"∀ {A : Type u_1} [inst : NormedRing A] [inst_1 : NormedAlgebra ℂ A] [inst_2 : CompleteSpace A] [inst_3 : StarRing A]\\n  [inst_4 : CstarRing A] [inst_5 : StarModule ℂ A] (a : { x // x ∈ selfAdjoint A }) {z : ℂ},\\n  z ∈ spectrum ℂ ↑a → z = ↑z.re\",\n  \"isProp\": true,\n  \"docString\": \"Any element of the spectrum of a selfadjoint is real. \"},\n {\"theorem\":\n  \"∀ {σ : Type u_1} {R : Type u_2} [inst : CommSemiring R] (p : MvPolynomial σ R),\\n  ∃ n f _hf q, p = ↑(MvPolynomial.rename f) q\",\n  \"isProp\": true,\n  \"docString\": \"Every polynomial is a polynomial in finitely many variables. \"},\n {\"theorem\":\n  \"∀ {A : Type u_2} {B : Type u_1} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\\n  [inst_3 : Nontrivial B], IsIntegral A x → 0 < Polynomial.degree (minpoly A x)\",\n  \"isProp\": true,\n  \"docString\": \"The degree of a minimal polynomial is positive. \"},\n {\"theorem\":\n  \"∀ {α : Type u_2} {n : Type u_1} [inst : DecidableEq n] [inst_1 : Zero α] [inst_2 : One α], Matrix.IsDiag 1\",\n  \"isProp\": true,\n  \"docString\": \"Every identity matrix is diagonal. \"},\n {\"theorem\":\n  \"∀ (K : Type u_1) [inst : Field K] [inst_1 : NumberField K] (A : Type u_2) [inst_2 : NormedField A]\\n  [inst_3 : IsAlgClosed A] [inst_4 : NormedAlgebra ℚ A] {x : K},\\n  IsIntegral ℤ x → (∀ (φ : K →+* A), ‖↑φ x‖ = 1) → ∃ n x_1, x ^ n = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"An algebraic integer whose conjugates are all of norm one is a root of unity. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} {S : Type u_2} [inst : Semiring R] [inst_1 : CommRing S] [inst_2 : IsDomain S] [inst_3 : DecidableEq S]\\n  (m : R →+* S) (d : ℕ) {U : Set R},\\n  Set.Finite U →\\n    Set.Finite\\n      (⋃ (f : Polynomial R) (_ : Polynomial.natDegree f ≤ d ∧ ∀ (i : ℕ), Polynomial.coeff f i ∈ U),\\n        ↑(Multiset.toFinset (Polynomial.roots (Polynomial.map m f))))\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of roots of all polynomials of bounded degree and having coefficients in a finite set\\nis finite. \"},\n {\"theorem\":\n  \"∀ {F : Type u_1} {K : Type u_2} [inst : CommRing F] [inst_1 : NormedField K] {B : ℝ} {d : ℕ} (f : F →+* K)\\n  {p : Polynomial F},\\n  Polynomial.Monic p →\\n    Polynomial.Splits f p →\\n      Polynomial.natDegree p ≤ d →\\n        (∀ (z : K), z ∈ Polynomial.roots (Polynomial.map f p) → ‖z‖ ≤ B) →\\n          ∀ (i : ℕ), ‖Polynomial.coeff (Polynomial.map f p) i‖ ≤ max B 1 ^ d * ↑(Nat.choose d (d / 2))\",\n  \"isProp\": true,\n  \"docString\":\n  \"The coefficients of the monic polynomials of bounded degree with bounded roots are\\nuniformly bounded. \"},\n {\"theorem\":\n  \"∀ (p : Polynomial ℝ),\\n  ↑Multiset.card (Polynomial.roots p) ≤ ↑Multiset.card (Polynomial.roots (↑Polynomial.derivative p)) + 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The number of roots of a real polynomial (counted with multiplicities) is at most the number of\\nroots of its derivative (counted with multiplicities) plus one. \"},\n {\"theorem\":\n  \"∀ {p : Polynomial ℚ},\\n  Irreducible p →\\n    Nat.Prime (Polynomial.natDegree p) →\\n      Fintype.card ↑(Polynomial.rootSet p ℂ) = Fintype.card ↑(Polynomial.rootSet p ℝ) + 2 →\\n        Function.Bijective ↑(Polynomial.Gal.galActionHom p ℂ)\",\n  \"isProp\": true,\n  \"docString\":\n  \"An irreducible polynomial of prime degree with two non-real roots has full Galois group. \"},\n {\"theorem\":\n  \"∀ (A : Type u_2) {B : Type u_1} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] (x : B),\\n  ↑(Polynomial.aeval x) (minpoly A x) = 0\",\n  \"isProp\": true,\n  \"docString\": \"An element is a root of its minimal polynomial. \"},\n {\"theorem\":\n  \"∀ {p : Polynomial ℚ},\\n  Irreducible p →\\n    Nat.Prime (Polynomial.natDegree p) →\\n      Fintype.card ↑(Polynomial.rootSet p ℝ) + 1 ≤ Fintype.card ↑(Polynomial.rootSet p ℂ) →\\n        Fintype.card ↑(Polynomial.rootSet p ℂ) ≤ Fintype.card ↑(Polynomial.rootSet p ℝ) + 3 →\\n          Function.Bijective ↑(Polynomial.Gal.galActionHom p ℂ)\",\n  \"isProp\": true,\n  \"docString\":\n  \"An irreducible polynomial of prime degree with 1-3 non-real roots has full Galois group. \"},\n {\"theorem\":\n  \"∀ {K : Type v} [inst : Field K] {p : Polynomial K},\\n  Polynomial.Splits (RingHom.id K) p ↔ ↑Multiset.card (Polynomial.roots p) = Polynomial.natDegree p\",\n  \"isProp\": true,\n  \"docString\":\n  \"A polynomial splits if and only if it has as many roots as its degree. \"},\n {\"theorem\":\n  \"∀ {A : Type u_2} {B : Type u_1} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\\n  [inst_3 : Nontrivial B], IsIntegral A x → 0 < Polynomial.natDegree (minpoly A x)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The degree of a minimal polynomial, as a natural number, is positive. \"},\n {\"theorem\":\n  \"∀ {R : Type v} {M : Type w} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M] {f : Module.End R M}\\n  {μ : R} {k : ℕ}, Module.End.HasGeneralizedEigenvalue f μ k → Module.End.HasEigenvalue f μ\",\n  \"isProp\": true,\n  \"docString\": \"All generalized eigenvalues are eigenvalues. \"}]\n", "prompt_cons": "/-- The diagonal elements of a complex hermitian matrix are real. -/\ntheorem ∀ {α : Type u_2} {n : Type u_1} [inst : IsROrC α] {A : Matrix n n α},\n  Matrix.IsHermitian A → (fun i => ↑(↑IsROrC.re (Matrix.diag A i))) = Matrix.diag A :=\n\n/-- **Fundamental theorem of algebra**: every non constant complex polynomial\nhas a root -/\ntheorem ∀ {f : Polynomial ℂ}, 0 < Polynomial.degree f → ∃ z, Polynomial.IsRoot f z :=\n\n/-- The eigenvalues of a self-adjoint operator are real. -/\ntheorem ∀ {𝕜 : Type u_1} [inst : IsROrC 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {T : E →ₗ[𝕜] E}, LinearMap.IsSymmetric T → ∀ {μ : 𝕜}, Module.End.HasEigenvalue T μ → ↑(starRingEnd 𝕜) μ = μ :=\n\n/-- The number of roots of a real polynomial is at most the number of roots of its derivative plus\none. -/\ntheorem ∀ (p : Polynomial ℝ),\n  Finset.card (Multiset.toFinset (Polynomial.roots p)) ≤\n    Finset.card (Multiset.toFinset (Polynomial.roots (↑Polynomial.derivative p))) + 1 :=\n\n/-- The minimal polynomial of a nonzero element has nonzero constant coefficient. -/\ntheorem ∀ {A : Type u_1} {B : Type u_2} [inst : Field A] [inst_1 : Ring B] [inst_2 : IsDomain B] [inst_3 : Algebra A B] {x : B},\n  IsIntegral A x → x ≠ 0 → Polynomial.coeff (minpoly A x) 0 ≠ 0 :=\n\n/-- The number of real roots of a polynomial is at most the number of roots of its derivative plus\none. -/\ntheorem ∀ {F : Type u_1} [inst : CommRing F] [inst_1 : Algebra F ℝ] (p : Polynomial F),\n  Fintype.card ↑(Polynomial.rootSet p ℝ) ≤ Fintype.card ↑(Polynomial.rootSet (↑Polynomial.derivative p) ℝ) + 1 :=\n\n/-- Any element of the spectrum of a selfadjoint is real. -/\ntheorem ∀ {A : Type u_1} [inst : NormedRing A] [inst_1 : NormedAlgebra ℂ A] [inst_2 : CompleteSpace A] [inst_3 : StarRing A]\n  [inst_4 : CstarRing A] [inst_5 : StarModule ℂ A] (a : { x // x ∈ selfAdjoint A }) {z : ℂ},\n  z ∈ spectrum ℂ ↑a → z = ↑z.re :=\n\n/-- Every polynomial is a polynomial in finitely many variables. -/\ntheorem ∀ {σ : Type u_1} {R : Type u_2} [inst : CommSemiring R] (p : MvPolynomial σ R),\n  ∃ n f _hf q, p = ↑(MvPolynomial.rename f) q :=\n\n/-- The degree of a minimal polynomial is positive. -/\ntheorem ∀ {A : Type u_2} {B : Type u_1} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\n  [inst_3 : Nontrivial B], IsIntegral A x → 0 < Polynomial.degree (minpoly A x) :=\n\n/-- Every identity matrix is diagonal. -/\ntheorem ∀ {α : Type u_2} {n : Type u_1} [inst : DecidableEq n] [inst_1 : Zero α] [inst_2 : One α], Matrix.IsDiag 1 :=\n\n/-- An algebraic integer whose conjugates are all of norm one is a root of unity. -/\ntheorem ∀ (K : Type u_1) [inst : Field K] [inst_1 : NumberField K] (A : Type u_2) [inst_2 : NormedField A]\n  [inst_3 : IsAlgClosed A] [inst_4 : NormedAlgebra ℚ A] {x : K},\n  IsIntegral ℤ x → (∀ (φ : K →+* A), ‖↑φ x‖ = 1) → ∃ n x_1, x ^ n = 1 :=\n\n/-- The set of roots of all polynomials of bounded degree and having coefficients in a finite set\nis finite. -/\ntheorem ∀ {R : Type u_1} {S : Type u_2} [inst : Semiring R] [inst_1 : CommRing S] [inst_2 : IsDomain S] [inst_3 : DecidableEq S]\n  (m : R →+* S) (d : ℕ) {U : Set R},\n  Set.Finite U →\n    Set.Finite\n      (⋃ (f : Polynomial R) (_ : Polynomial.natDegree f ≤ d ∧ ∀ (i : ℕ), Polynomial.coeff f i ∈ U),\n        ↑(Multiset.toFinset (Polynomial.roots (Polynomial.map m f)))) :=\n\n/-- The coefficients of the monic polynomials of bounded degree with bounded roots are\nuniformly bounded. -/\ntheorem ∀ {F : Type u_1} {K : Type u_2} [inst : CommRing F] [inst_1 : NormedField K] {B : ℝ} {d : ℕ} (f : F →+* K)\n  {p : Polynomial F},\n  Polynomial.Monic p →\n    Polynomial.Splits f p →\n      Polynomial.natDegree p ≤ d →\n        (∀ (z : K), z ∈ Polynomial.roots (Polynomial.map f p) → ‖z‖ ≤ B) →\n          ∀ (i : ℕ), ‖Polynomial.coeff (Polynomial.map f p) i‖ ≤ max B 1 ^ d * ↑(Nat.choose d (d / 2)) :=\n\n/-- The number of roots of a real polynomial (counted with multiplicities) is at most the number of\nroots of its derivative (counted with multiplicities) plus one. -/\ntheorem ∀ (p : Polynomial ℝ),\n  ↑Multiset.card (Polynomial.roots p) ≤ ↑Multiset.card (Polynomial.roots (↑Polynomial.derivative p)) + 1 :=\n\n/-- An irreducible polynomial of prime degree with two non-real roots has full Galois group. -/\ntheorem ∀ {p : Polynomial ℚ},\n  Irreducible p →\n    Nat.Prime (Polynomial.natDegree p) →\n      Fintype.card ↑(Polynomial.rootSet p ℂ) = Fintype.card ↑(Polynomial.rootSet p ℝ) + 2 →\n        Function.Bijective ↑(Polynomial.Gal.galActionHom p ℂ) :=\n\n/-- An element is a root of its minimal polynomial. -/\ntheorem ∀ (A : Type u_2) {B : Type u_1} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] (x : B),\n  ↑(Polynomial.aeval x) (minpoly A x) = 0 :=\n\n/-- An irreducible polynomial of prime degree with 1-3 non-real roots has full Galois group. -/\ntheorem ∀ {p : Polynomial ℚ},\n  Irreducible p →\n    Nat.Prime (Polynomial.natDegree p) →\n      Fintype.card ↑(Polynomial.rootSet p ℝ) + 1 ≤ Fintype.card ↑(Polynomial.rootSet p ℂ) →\n        Fintype.card ↑(Polynomial.rootSet p ℂ) ≤ Fintype.card ↑(Polynomial.rootSet p ℝ) + 3 →\n          Function.Bijective ↑(Polynomial.Gal.galActionHom p ℂ) :=\n\n/-- A polynomial splits if and only if it has as many roots as its degree. -/\ntheorem ∀ {K : Type v} [inst : Field K] {p : Polynomial K},\n  Polynomial.Splits (RingHom.id K) p ↔ ↑Multiset.card (Polynomial.roots p) = Polynomial.natDegree p :=\n\n/-- The degree of a minimal polynomial, as a natural number, is positive. -/\ntheorem ∀ {A : Type u_2} {B : Type u_1} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\n  [inst_3 : Nontrivial B], IsIntegral A x → 0 < Polynomial.natDegree (minpoly A x) :=\n\n/-- All generalized eigenvalues are eigenvalues. -/\ntheorem ∀ {R : Type v} {M : Type w} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M] {f : Module.End R M}\n  {μ : R} {k : ℕ}, Module.End.HasGeneralizedEigenvalue f μ k → Module.End.HasEigenvalue f μ :=\n\n/-- The characteristic polynomial of every matrix has real roots. -/\ntheorem", "choices": ["∀ {A : Type u_2} {n : Type u_1} [inst : CommRing A] [inst_1 : IsDomain A] [inst_2 : DecidableEq n] [inst_3 : Fintype n] {M : Matrix n n A},\n  ∃ p : Polynomial ℝ, Polynomial.Monic p ∧ ∀ (root : ℝ), Polynomial.IsRoot p root → ∃ k, coeFn (Matrix.evalCpGen M) (algebraMap ℝ A root) = 0 ", "∀ {n : Type u_1} {R : Type u_2} [inst : DecidableEq n] [inst_1 : Fintype n] [inst_2 : CommRing R] (M : Matrix n n R),\n  ∃ p : Polynomial ℝ, Polynomial.map (RingHom.id R) p = Matrix.charPoly M ", "∀ {α : Type u_2} {n : Type u_1} [inst : DecidableEq n] [inst_1 : Fintype n] [inst_2 : CommRing α] [inst_3 : Algebra α ℝ]\n  {A : Matrix n n α},\n  ∃ p _h, Polynomial.Monic p ∧ Polynomial.map (algebraMap α ℝ) p = Matrix.charpoly A ", "∀ {α : Type u_2} {n : Type u_1} [inst : DecidableEq n] [inst_1 : Fintype n] [inst_2 : Ring α] [inst_3 : Algebra ℝ α] (A : Matrix n n α),\n  ∃ p : Polynomial ℝ, (Polynomial.mapMatrix (algebraMap ℝ α) p).natDegree = Polynomial.natDegree p ∧\n    ∀ (x : ℝ), Polynomial.IsRoot p x → ∃ μ, μ ∈ Matrix.eigenvalues A ", "∀ {α : Type u_2} {n : Type u_1} [inst : CommRing α] [inst_1 : IsDomain α] [inst_2 : Module α (Matrix n n α)]\n  {M : Matrix n n α}, ∃ a, HasSubset.Subset (Polynomial.roots (Matrix.charpoly M)) a ", "∀ {n : Type u_1} {α : Type u_2} [inst : DecidableEq n] [inst_1 : Fintype n] [inst_2 : CommRing α] {A : Matrix n n α}\n  [inst_3 : Algebra α ℝ], ∃ p, Polynomial.RealRoots p = Multiset.toFinset (Polynomial.roots (Matrix.charpoly A)) ", "∀ {n : Type u_1} [Fintype n] {R : Type u_2} [inst : CommRing R] [inst_1 : Algebra R ℝ] (A : Matrix n n R),\n  ∃ p, Polynomial.map (algebraMap R ℝ) (Matrix.charpoly A) = p ", "∀ {n : Type u_1} [inst : Fintype n] [inst_1 : DecidableEq n] {R : Type u_2} [inst_2 : CommRing R] (A : Matrix n n R),\n  ∃ (p : Polynomial ℝ), Polynomial.map (algebraMap R ℝ) (Matrix.charpoly A) = p ", "∀ {n : Type u_1} [inst : DecidableEq n] [inst_1 : Fintype n] {R : Type u_2} [inst_2 : CommRing R] [inst_3 : Algebra R ℝ]\n  (A : Matrix n n R), ∃ p, Polynomial.Monic p ∧ Polynomial.IsRoot p = Multiset.toFinset (Polynomial.roots (charpoly A)) ", "∀ {n : Type u_1} {R : Type u_2} [inst : DecidableEq n] [inst_1 : Fintype n] [inst_2 : CommRing R] [inst_3 : Algebra R ℝ] (A : Matrix n n R),\n  ∃ L : List ℝ, Multiset.map coe L = Polynomial.roots (Matrix.charpoly A) "]}
{"docString": "In a commutative ring, every prime ideal is contained in a unique maximal ideal.", "prompts": "[{\"theorem\":\n  \"∀ {R : Type u} [inst : CommRing R],\\n  (∀ (P : Ideal R), Ideal.IsPrime P → Submodule.IsPrincipal P) → IsPrincipalIdealRing R\",\n  \"isProp\": true,\n  \"docString\":\n  \"If all prime ideals in a commutative ring are principal, so are all other ideals. \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : CommRing R] (I : Ideal R), Ideal.IsMaximal I ↔ IsField (R ⧸ I)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The quotient of a ring by an ideal is a field iff the ideal is maximal. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : CommRing R],\\n  Set.Finite {I | Ideal.IsMaximal I} → ∀ {I : Ideal R}, IsUnit ↑I → Submodule.IsPrincipal I\",\n  \"isProp\": true,\n  \"docString\":\n  \"An invertible ideal in a commutative ring with finitely many maximal ideals is principal.\\n\\nhttps://math.stackexchange.com/a/95857 \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : CommRing R] (I : Ideal R), IsField (R ⧸ I) → Ideal.IsMaximal I\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the quotient by an ideal is a field, then the ideal is maximal. \"},\n {\"theorem\":\n  \"∀ (α : Type u) [inst : Semiring α] [inst_1 : Nontrivial α], ∃ M, Ideal.IsMaximal M\",\n  \"isProp\": true,\n  \"docString\": \"Krull's theorem: a nontrivial ring has a maximal ideal. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : CommSemiring R] {I : Ideal R} [hI : Ideal.IsPrime I],\\n  Ideal.comap (algebraMap R (Localization.AtPrime I)) (LocalRing.maximalIdeal (Localization (Ideal.primeCompl I))) = I\",\n  \"isProp\": true,\n  \"docString\":\n  \"The unique maximal ideal of the localization at `I.prime_compl` lies over the ideal `I`. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : Semiring α] {I : Ideal α} [self : Ideal.IsMaximal I], IsCoatom I\",\n  \"isProp\": true,\n  \"docString\":\n  \"The maximal ideal is a coatom in the ordering on ideals; that is, it is not the entire ring,\\nand there are no other proper ideals strictly containing it. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : NormedRing R] [inst_1 : CompleteSpace R] {I : Ideal R} [hI : Ideal.IsMaximal I], IsClosed ↑I\",\n  \"isProp\": true,\n  \"docString\": \"Maximal ideals in complete normed rings are closed. \"},\n {\"theorem\":\n  \"∀ {R : Type u_2} [inst : CommRing R] {A : Type u_1} [inst_1 : CommRing A] [inst_2 : Algebra R A] {S : Submonoid R}\\n  [inst_3 : IsLocalization S A],\\n  S ≤ nonZeroDivisors R →\\n    Set.Finite {I | Ideal.IsMaximal I} → ∀ (I I' : FractionalIdeal S A), I * I' = 1 → Submodule.IsPrincipal ↑I\",\n  \"isProp\": true,\n  \"docString\":\n  \"An invertible fractional ideal of a commutative ring with finitely many maximal ideals is principal.\\n\\nhttps://math.stackexchange.com/a/95857 \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : CommRing R] [self : IsBezout R] (I : Ideal R), Ideal.FG I → Submodule.IsPrincipal I\",\n  \"isProp\": true,\n  \"docString\": \"Any finitely generated ideal is principal. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : NormedRing R] [inst_1 : CompleteSpace R] {I : Ideal R}, Ideal.IsMaximal I → Ideal.closure I = I\",\n  \"isProp\": true,\n  \"docString\":\n  \"The `Ideal.closure` of a maximal ideal in a complete normed ring is the ideal itself. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : CommRing R] [inst_1 : Fintype R] (p : ℕ) [inst_2 : Fact (Nat.Prime p)],\\n  p ∣ ringChar R ↔ p ∣ Fintype.card R\",\n  \"isProp\": true,\n  \"docString\":\n  \"The prime divisors of the characteristic of a finite commutative ring are exactly\\nthe prime divisors of its cardinality. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : Semiring α] {I : Ideal α} [self : Ideal.IsPrime I] {x y : α}, x * y ∈ I → x ∈ I ∨ y ∈ I\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a product lies in the prime ideal, then at least one element lies in the prime ideal. \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : CommRing R], CompactSpace (PrimeSpectrum R)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The prime spectrum of a commutative ring is a compact topological space. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} {K : Type u_2} {F : Type u_3} [inst : Ring R] [inst_1 : Field K] [inst_2 : RingHomClass F R K] (f : F),\\n  Function.Surjective ↑f → Ideal.IsMaximal (RingHom.ker f)\",\n  \"isProp\": true,\n  \"docString\": \"The kernel of a homomorphism to a field is a maximal ideal. \"},\n {\"theorem\":\n  \"∀ (R : Type u) [inst : CommRing R] [inst_1 : IsNoetherianRing R] (I : Ideal R),\\n  ∃ Z, Multiset.prod (Multiset.map PrimeSpectrum.asIdeal Z) ≤ I\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a noetherian ring, every ideal contains a product of prime ideals\\n([samuel, § 3.3, Lemma 3])\"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : CommSemiring R] [inst_1 : Nontrivial R] {M : Ideal R}, Ideal.IsMaximal M → ¬IsField R → M ≠ ⊥\",\n  \"isProp\": true,\n  \"docString\":\n  \"When a ring is not a field, the maximal ideals are nontrivial. \"},\n {\"theorem\":\n  \"∀ {P : Type u_1} [inst : LE P] {I : Order.Ideal P} [self : Order.Ideal.IsMaximal I] ⦃J : Order.Ideal P⦄,\\n  I < J → ↑J = Set.univ\",\n  \"isProp\": true,\n  \"docString\": \"This ideal is maximal in the collection of proper ideals. \"},\n {\"theorem\":\n  \"∀ {R : Type u} {S : Type u_1} [inst : Ring R] [inst_1 : Ring S] [inst_2 : IsPrincipalIdealRing R] (f : R →+* S),\\n  Function.Surjective ↑f → IsPrincipalIdealRing S\",\n  \"isProp\": true,\n  \"docString\":\n  \"The surjective image of a principal ideal ring is again a principal ideal ring. \"},\n {\"theorem\":\n  \"∀ {R : Type u} {S : Type v} {F : Type u_1} [inst : Ring R] [inst_1 : Ring S] [inst_2 : IsDomain S]\\n  [inst_3 : RingHomClass F R S] (f : F), Ideal.IsPrime (RingHom.ker f)\",\n  \"isProp\": true,\n  \"docString\": \"The kernel of a homomorphism to a domain is a prime ideal. \"}]\n", "prompt_cons": "/-- If all prime ideals in a commutative ring are principal, so are all other ideals. -/\ntheorem ∀ {R : Type u} [inst : CommRing R],\n  (∀ (P : Ideal R), Ideal.IsPrime P → Submodule.IsPrincipal P) → IsPrincipalIdealRing R :=\n\n/-- The quotient of a ring by an ideal is a field iff the ideal is maximal. -/\ntheorem ∀ {R : Type u} [inst : CommRing R] (I : Ideal R), Ideal.IsMaximal I ↔ IsField (R ⧸ I) :=\n\n/-- An invertible ideal in a commutative ring with finitely many maximal ideals is principal.\n\nhttps://math.stackexchange.com/a/95857 -/\ntheorem ∀ {R : Type u_1} [inst : CommRing R],\n  Set.Finite {I | Ideal.IsMaximal I} → ∀ {I : Ideal R}, IsUnit ↑I → Submodule.IsPrincipal I :=\n\n/-- If the quotient by an ideal is a field, then the ideal is maximal. -/\ntheorem ∀ {R : Type u} [inst : CommRing R] (I : Ideal R), IsField (R ⧸ I) → Ideal.IsMaximal I :=\n\n/-- Krull's theorem: a nontrivial ring has a maximal ideal. -/\ntheorem ∀ (α : Type u) [inst : Semiring α] [inst_1 : Nontrivial α], ∃ M, Ideal.IsMaximal M :=\n\n/-- The unique maximal ideal of the localization at `I.prime_compl` lies over the ideal `I`. -/\ntheorem ∀ {R : Type u_1} [inst : CommSemiring R] {I : Ideal R} [hI : Ideal.IsPrime I],\n  Ideal.comap (algebraMap R (Localization.AtPrime I)) (LocalRing.maximalIdeal (Localization (Ideal.primeCompl I))) = I :=\n\n/-- The maximal ideal is a coatom in the ordering on ideals; that is, it is not the entire ring,\nand there are no other proper ideals strictly containing it. -/\ntheorem ∀ {α : Type u} [inst : Semiring α] {I : Ideal α} [self : Ideal.IsMaximal I], IsCoatom I :=\n\n/-- Maximal ideals in complete normed rings are closed. -/\ntheorem ∀ {R : Type u_1} [inst : NormedRing R] [inst_1 : CompleteSpace R] {I : Ideal R} [hI : Ideal.IsMaximal I], IsClosed ↑I :=\n\n/-- An invertible fractional ideal of a commutative ring with finitely many maximal ideals is principal.\n\nhttps://math.stackexchange.com/a/95857 -/\ntheorem ∀ {R : Type u_2} [inst : CommRing R] {A : Type u_1} [inst_1 : CommRing A] [inst_2 : Algebra R A] {S : Submonoid R}\n  [inst_3 : IsLocalization S A],\n  S ≤ nonZeroDivisors R →\n    Set.Finite {I | Ideal.IsMaximal I} → ∀ (I I' : FractionalIdeal S A), I * I' = 1 → Submodule.IsPrincipal ↑I :=\n\n/-- Any finitely generated ideal is principal. -/\ntheorem ∀ {R : Type u} [inst : CommRing R] [self : IsBezout R] (I : Ideal R), Ideal.FG I → Submodule.IsPrincipal I :=\n\n/-- The `Ideal.closure` of a maximal ideal in a complete normed ring is the ideal itself. -/\ntheorem ∀ {R : Type u_1} [inst : NormedRing R] [inst_1 : CompleteSpace R] {I : Ideal R}, Ideal.IsMaximal I → Ideal.closure I = I :=\n\n/-- The prime divisors of the characteristic of a finite commutative ring are exactly\nthe prime divisors of its cardinality. -/\ntheorem ∀ {R : Type u_1} [inst : CommRing R] [inst_1 : Fintype R] (p : ℕ) [inst_2 : Fact (Nat.Prime p)],\n  p ∣ ringChar R ↔ p ∣ Fintype.card R :=\n\n/-- If a product lies in the prime ideal, then at least one element lies in the prime ideal. -/\ntheorem ∀ {α : Type u} [inst : Semiring α] {I : Ideal α} [self : Ideal.IsPrime I] {x y : α}, x * y ∈ I → x ∈ I ∨ y ∈ I :=\n\n/-- The prime spectrum of a commutative ring is a compact topological space. -/\ntheorem ∀ {R : Type u} [inst : CommRing R], CompactSpace (PrimeSpectrum R) :=\n\n/-- The kernel of a homomorphism to a field is a maximal ideal. -/\ntheorem ∀ {R : Type u_1} {K : Type u_2} {F : Type u_3} [inst : Ring R] [inst_1 : Field K] [inst_2 : RingHomClass F R K] (f : F),\n  Function.Surjective ↑f → Ideal.IsMaximal (RingHom.ker f) :=\n\n/-- In a noetherian ring, every ideal contains a product of prime ideals\n([samuel, § 3.3, Lemma 3]) -/\ntheorem ∀ (R : Type u) [inst : CommRing R] [inst_1 : IsNoetherianRing R] (I : Ideal R),\n  ∃ Z, Multiset.prod (Multiset.map PrimeSpectrum.asIdeal Z) ≤ I :=\n\n/-- When a ring is not a field, the maximal ideals are nontrivial. -/\ntheorem ∀ {R : Type u_1} [inst : CommSemiring R] [inst_1 : Nontrivial R] {M : Ideal R}, Ideal.IsMaximal M → ¬IsField R → M ≠ ⊥ :=\n\n/-- This ideal is maximal in the collection of proper ideals. -/\ntheorem ∀ {P : Type u_1} [inst : LE P] {I : Order.Ideal P} [self : Order.Ideal.IsMaximal I] ⦃J : Order.Ideal P⦄,\n  I < J → ↑J = Set.univ :=\n\n/-- The surjective image of a principal ideal ring is again a principal ideal ring. -/\ntheorem ∀ {R : Type u} {S : Type u_1} [inst : Ring R] [inst_1 : Ring S] [inst_2 : IsPrincipalIdealRing R] (f : R →+* S),\n  Function.Surjective ↑f → IsPrincipalIdealRing S :=\n\n/-- The kernel of a homomorphism to a domain is a prime ideal. -/\ntheorem ∀ {R : Type u} {S : Type v} {F : Type u_1} [inst : Ring R] [inst_1 : Ring S] [inst_2 : IsDomain S]\n  [inst_3 : RingHomClass F R S] (f : F), Ideal.IsPrime (RingHom.ker f) :=\n\n/-- In a commutative ring, every prime ideal is contained in a unique maximal ideal. -/\ntheorem", "choices": ["∀ {R : Type u} [inst : CommRing R] (P : Ideal R) [Ideal.IsPrime P], ∃! M, Ideal.IsMaximal M ∧ P ≤ M ", "∀ {R : Type u} [inst : CommRing R] (P : Ideal R) [Ideal.IsPrime P], ∃! M, Ideal.IsMaximal M ∧ P ≤ M ", "∀ {R : Type u} [inst : CommRing R] (P : Ideal R), Ideal.IsPrime P → ∃! M, Ideal.IsMaximal M ∧ P ≤ M ", "∀ {R : Type u} [inst : CommRing R] (P : Ideal R) [Ideal.IsPrime P],\n  ∃! M, Ideal.IsMaximal M ∧ P ≤ M ", "∀ {R : Type u} [inst : CommRing R] (P : Ideal R) [Ideal.IsPrime P], ∃! M, Ideal.IsMaximal M ∧ P ≤ M ", "∀ {R : Type u} [inst : CommRing R] {P : Ideal R} [hP : Ideal.IsPrime P], ∃! M, Ideal.IsMaximal M ∧ P ≤ M ", "∀ (R : Type u) [inst : CommRing R] {P : Ideal R} [hP : Ideal.IsPrime P], ∃! (M : Ideal R), Ideal.IsMaximal M ∧ P ≤ M ", "∀ {R : Type u} [inst : CommRing R] (P : Ideal R) [hP : Ideal.IsPrime P], ∃! M, Ideal.IsMaximal M ∧ P ≤ M ", "∀ {R : Type u} [inst : CommRing R] (P : Ideal R) [Ideal.IsPrime P], ∃! M, Ideal.IsMaximal M ∧ P ≤ M ", "∀ {R : Type u} [inst : CommRing R] [hR : Nontrivial R] (P : Ideal R), Ideal.IsPrime P → ∃! (M : Submodule R R), Ideal.IsMaximal M ∧ P ≤ M "]}
{"docString": "Every continuous function is uniformly continuous.", "prompts": "[{\"theorem\":\n  \"∀ {ι : Type u_1} {α : Type u_2} {β : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β] {F : ι → β → α},\\n  UniformEquicontinuous F → ∀ (i : ι), UniformContinuous (F i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Each function of a uniformly equicontinuous family is uniformly continuous. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {p : Filter ι}\\n  [inst_1 : TopologicalSpace α],\\n  TendstoUniformly F f p → (∀ᶠ (n : ι) in p, Continuous (F n)) → ∀ [inst_2 : Filter.NeBot p], Continuous f\",\n  \"isProp\": true,\n  \"docString\": \"A uniform limit of continuous functions is continuous. \"},\n {\"theorem\":\n  \"∀ {α : Type u_2} {β : Type u_1} {ι : Type u_3} {m : MeasurableSpace α} (μ : MeasureTheory.Measure α)\\n  [inst : NormedAddCommGroup β] {p : ENNReal} {g : α → β},\\n  1 ≤ p → p ≠ ⊤ → MeasureTheory.Memℒp g p → MeasureTheory.UnifIntegrable (fun x => g) p μ\",\n  \"isProp\": true,\n  \"docString\": \"A constant function is uniformly integrable. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : UniformSpace β] {f : α → β} [inst_1 : TopologicalSpace α],\\n  (∀ (u : Set (β × β)), u ∈ uniformity β → ∃ F, Continuous F ∧ ∀ (y : α), (f y, F y) ∈ u) → Continuous f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be uniformly approximated by continuous functions is continuous. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {p : Filter ι}\\n  [inst_1 : TopologicalSpace α],\\n  TendstoLocallyUniformly F f p → (∀ᶠ (n : ι) in p, Continuous (F n)) → ∀ [inst_2 : Filter.NeBot p], Continuous f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A locally uniform limit of continuous functions is continuous. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : UniformSpace β] {f : α → β} [inst_1 : TopologicalSpace α],\\n  (∀ (x : α) (u : Set (β × β)),\\n      u ∈ uniformity β → ∃ t, t ∈ nhds x ∧ ∃ F, ContinuousAt F x ∧ ∀ (y : α), y ∈ t → (f y, F y) ∈ u) →\\n    Continuous f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be locally uniformly approximated by continuous functions is continuous. \"},\n {\"theorem\":\n  \"∀ {α : Type u_2} {β : Type u_1} {ι : Type u_3} {m : MeasurableSpace α} {μ : MeasureTheory.Measure α}\\n  [inst : NormedAddCommGroup β] {p : ENNReal} {g : α → β},\\n  1 ≤ p → p ≠ ⊤ → MeasureTheory.Memℒp g p → MeasureTheory.UniformIntegrable (fun x => g) p μ\",\n  \"isProp\": true,\n  \"docString\":\n  \"A constant sequence of functions is uniformly integrable in the probability sense. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] (self : α ≃ᵤ β),\\n  UniformContinuous self.toFun\",\n  \"isProp\": true,\n  \"docString\": \"Uniform continuity of the function \"},\n {\"theorem\":\n  \"∀ {ι : Type u_1} {X : Type u_2} {α : Type u_3} [inst : TopologicalSpace X] [inst_1 : UniformSpace α] {F : ι → X → α},\\n  Equicontinuous F → ∀ (i : ι), Continuous (F i)\",\n  \"isProp\": true,\n  \"docString\": \"Each function of an equicontinuous family is continuous. \"},\n {\"theorem\":\n  \"∀ {α : Type u_3} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] {ι : Type u_1} {F : ι → β → α}\\n  [inst_2 : CompactSpace β], Equicontinuous F → UniformEquicontinuous F\",\n  \"isProp\": true,\n  \"docString\":\n  \"An equicontinuous family of functions defined on a compact uniform space is automatically\\nuniformly equicontinuous. \"},\n {\"theorem\":\n  \"∀ {α : Type u_3} {β : Type u_2} {ι : Type u_1} {m : MeasurableSpace α} (μ : MeasureTheory.Measure α)\\n  [inst : NormedAddCommGroup β] {p : ENNReal} [inst_1 : Subsingleton ι],\\n  1 ≤ p → p ≠ ⊤ → ∀ {f : ι → α → β}, (∀ (i : ι), MeasureTheory.Memℒp (f i) p) → MeasureTheory.UnifIntegrable f p μ\",\n  \"isProp\": true,\n  \"docString\": \"A single function is uniformly integrable. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : UniformSpace β] {f : α → β} {x : α} [inst_1 : TopologicalSpace α],\\n  (∀ (u : Set (β × β)),\\n      u ∈ uniformity β → ∃ t, t ∈ nhds x ∧ ∃ F, ContinuousAt F x ∧ ∀ (y : α), y ∈ t → (f y, F y) ∈ u) →\\n    ContinuousAt f x\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be locally uniformly approximated by functions which are continuous at\\na point is continuous at this point. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderClosedTopology α]\\n  [inst_3 : TopologicalSpace β] [inst_4 : Nonempty α] {f : β → α} {K : Set β},\\n  IsCompact K → ContinuousOn f K → BddAbove (f '' K)\",\n  \"isProp\": true,\n  \"docString\": \"A continuous function is bounded above on a compact set. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : UniformSpace β] {f : α → β} {s : Set α} [inst_1 : TopologicalSpace α],\\n  (∀ (u : Set (β × β)), u ∈ uniformity β → ∃ F, ContinuousOn F s ∧ ∀ (y : α), y ∈ s → (f y, F y) ∈ u) → ContinuousOn f s\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be uniformly approximated by functions which are continuous on a set\\nis continuous on this set. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : UniformSpace β] {f : α → β} {s : Set α} [inst_1 : TopologicalSpace α],\\n  (∀ (x : α),\\n      x ∈ s →\\n        ∀ (u : Set (β × β)),\\n          u ∈ uniformity β →\\n            ∃ t, t ∈ nhdsWithin x s ∧ ∃ F, ContinuousWithinAt F s x ∧ ∀ (y : α), y ∈ t → (f y, F y) ∈ u) →\\n    ContinuousOn f s\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be locally uniformly approximated by functions which are continuous\\non a set is continuous on this set. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {s : Set α} {p : Filter ι}\\n  [inst_1 : TopologicalSpace α],\\n  TendstoUniformlyOn F f p s → (∀ᶠ (n : ι) in p, ContinuousOn (F n) s) → ∀ [inst_2 : Filter.NeBot p], ContinuousOn f s\",\n  \"isProp\": true,\n  \"docString\":\n  \"A uniform limit on a set of functions which are continuous on this set is itself continuous\\non this set. \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : SequentialSpace X]\\n  {f : X → Y}, SeqContinuous f → Continuous f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A sequentially continuous function defined on a sequential space is continuous. \"},\n {\"theorem\":\n  \"∀ {ι : Type u_1} {α : Type u_2} {β : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β] {F : ι → β → α},\\n  UniformEquicontinuous F → Equicontinuous F\",\n  \"isProp\": true,\n  \"docString\": \"Uniform equicontinuity implies equicontinuity. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {s : Set α} {p : Filter ι}\\n  [inst_1 : TopologicalSpace α],\\n  TendstoLocallyUniformlyOn F f p s →\\n    (∀ᶠ (n : ι) in p, ContinuousOn (F n) s) → ∀ [inst_2 : Filter.NeBot p], ContinuousOn f s\",\n  \"isProp\": true,\n  \"docString\":\n  \"A locally uniform limit on a set of functions which are continuous on this set is itself\\ncontinuous on this set. \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] {m : MeasurableSpace X} [inst_1 : TopologicalSpace Y]\\n  [inst_2 : T2Space Y] {μ : MeasureTheory.Measure X} [inst_3 : MeasureTheory.Measure.IsOpenPosMeasure μ] {f g : X → Y},\\n  f =ᶠ[MeasureTheory.Measure.ae μ] g → Continuous f → Continuous g → f = g\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two continuous functions are a.e. equal, then they are equal. \"}]\n", "prompt_cons": "/-- Each function of a uniformly equicontinuous family is uniformly continuous. -/\ntheorem ∀ {ι : Type u_1} {α : Type u_2} {β : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β] {F : ι → β → α},\n  UniformEquicontinuous F → ∀ (i : ι), UniformContinuous (F i) :=\n\n/-- A uniform limit of continuous functions is continuous. -/\ntheorem ∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {p : Filter ι}\n  [inst_1 : TopologicalSpace α],\n  TendstoUniformly F f p → (∀ᶠ (n : ι) in p, Continuous (F n)) → ∀ [inst_2 : Filter.NeBot p], Continuous f :=\n\n/-- A constant function is uniformly integrable. -/\ntheorem ∀ {α : Type u_2} {β : Type u_1} {ι : Type u_3} {m : MeasurableSpace α} (μ : MeasureTheory.Measure α)\n  [inst : NormedAddCommGroup β] {p : ENNReal} {g : α → β},\n  1 ≤ p → p ≠ ⊤ → MeasureTheory.Memℒp g p → MeasureTheory.UnifIntegrable (fun x => g) p μ :=\n\n/-- A function which can be uniformly approximated by continuous functions is continuous. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : UniformSpace β] {f : α → β} [inst_1 : TopologicalSpace α],\n  (∀ (u : Set (β × β)), u ∈ uniformity β → ∃ F, Continuous F ∧ ∀ (y : α), (f y, F y) ∈ u) → Continuous f :=\n\n/-- A locally uniform limit of continuous functions is continuous. -/\ntheorem ∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {p : Filter ι}\n  [inst_1 : TopologicalSpace α],\n  TendstoLocallyUniformly F f p → (∀ᶠ (n : ι) in p, Continuous (F n)) → ∀ [inst_2 : Filter.NeBot p], Continuous f :=\n\n/-- A function which can be locally uniformly approximated by continuous functions is continuous. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : UniformSpace β] {f : α → β} [inst_1 : TopologicalSpace α],\n  (∀ (x : α) (u : Set (β × β)),\n      u ∈ uniformity β → ∃ t, t ∈ nhds x ∧ ∃ F, ContinuousAt F x ∧ ∀ (y : α), y ∈ t → (f y, F y) ∈ u) →\n    Continuous f :=\n\n/-- A constant sequence of functions is uniformly integrable in the probability sense. -/\ntheorem ∀ {α : Type u_2} {β : Type u_1} {ι : Type u_3} {m : MeasurableSpace α} {μ : MeasureTheory.Measure α}\n  [inst : NormedAddCommGroup β] {p : ENNReal} {g : α → β},\n  1 ≤ p → p ≠ ⊤ → MeasureTheory.Memℒp g p → MeasureTheory.UniformIntegrable (fun x => g) p μ :=\n\n/-- Uniform continuity of the function -/\ntheorem ∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] (self : α ≃ᵤ β),\n  UniformContinuous self.toFun :=\n\n/-- Each function of an equicontinuous family is continuous. -/\ntheorem ∀ {ι : Type u_1} {X : Type u_2} {α : Type u_3} [inst : TopologicalSpace X] [inst_1 : UniformSpace α] {F : ι → X → α},\n  Equicontinuous F → ∀ (i : ι), Continuous (F i) :=\n\n/-- An equicontinuous family of functions defined on a compact uniform space is automatically\nuniformly equicontinuous. -/\ntheorem ∀ {α : Type u_3} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] {ι : Type u_1} {F : ι → β → α}\n  [inst_2 : CompactSpace β], Equicontinuous F → UniformEquicontinuous F :=\n\n/-- A single function is uniformly integrable. -/\ntheorem ∀ {α : Type u_3} {β : Type u_2} {ι : Type u_1} {m : MeasurableSpace α} (μ : MeasureTheory.Measure α)\n  [inst : NormedAddCommGroup β] {p : ENNReal} [inst_1 : Subsingleton ι],\n  1 ≤ p → p ≠ ⊤ → ∀ {f : ι → α → β}, (∀ (i : ι), MeasureTheory.Memℒp (f i) p) → MeasureTheory.UnifIntegrable f p μ :=\n\n/-- A function which can be locally uniformly approximated by functions which are continuous at\na point is continuous at this point. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : UniformSpace β] {f : α → β} {x : α} [inst_1 : TopologicalSpace α],\n  (∀ (u : Set (β × β)),\n      u ∈ uniformity β → ∃ t, t ∈ nhds x ∧ ∃ F, ContinuousAt F x ∧ ∀ (y : α), y ∈ t → (f y, F y) ∈ u) →\n    ContinuousAt f x :=\n\n/-- A continuous function is bounded above on a compact set. -/\ntheorem ∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderClosedTopology α]\n  [inst_3 : TopologicalSpace β] [inst_4 : Nonempty α] {f : β → α} {K : Set β},\n  IsCompact K → ContinuousOn f K → BddAbove (f '' K) :=\n\n/-- A function which can be uniformly approximated by functions which are continuous on a set\nis continuous on this set. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : UniformSpace β] {f : α → β} {s : Set α} [inst_1 : TopologicalSpace α],\n  (∀ (u : Set (β × β)), u ∈ uniformity β → ∃ F, ContinuousOn F s ∧ ∀ (y : α), y ∈ s → (f y, F y) ∈ u) → ContinuousOn f s :=\n\n/-- A function which can be locally uniformly approximated by functions which are continuous\non a set is continuous on this set. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : UniformSpace β] {f : α → β} {s : Set α} [inst_1 : TopologicalSpace α],\n  (∀ (x : α),\n      x ∈ s →\n        ∀ (u : Set (β × β)),\n          u ∈ uniformity β →\n            ∃ t, t ∈ nhdsWithin x s ∧ ∃ F, ContinuousWithinAt F s x ∧ ∀ (y : α), y ∈ t → (f y, F y) ∈ u) →\n    ContinuousOn f s :=\n\n/-- A uniform limit on a set of functions which are continuous on this set is itself continuous\non this set. -/\ntheorem ∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {s : Set α} {p : Filter ι}\n  [inst_1 : TopologicalSpace α],\n  TendstoUniformlyOn F f p s → (∀ᶠ (n : ι) in p, ContinuousOn (F n) s) → ∀ [inst_2 : Filter.NeBot p], ContinuousOn f s :=\n\n/-- A sequentially continuous function defined on a sequential space is continuous. -/\ntheorem ∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : SequentialSpace X]\n  {f : X → Y}, SeqContinuous f → Continuous f :=\n\n/-- Uniform equicontinuity implies equicontinuity. -/\ntheorem ∀ {ι : Type u_1} {α : Type u_2} {β : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β] {F : ι → β → α},\n  UniformEquicontinuous F → Equicontinuous F :=\n\n/-- A locally uniform limit on a set of functions which are continuous on this set is itself\ncontinuous on this set. -/\ntheorem ∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {s : Set α} {p : Filter ι}\n  [inst_1 : TopologicalSpace α],\n  TendstoLocallyUniformlyOn F f p s →\n    (∀ᶠ (n : ι) in p, ContinuousOn (F n) s) → ∀ [inst_2 : Filter.NeBot p], ContinuousOn f s :=\n\n/-- If two continuous functions are a.e. equal, then they are equal. -/\ntheorem ∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] {m : MeasurableSpace X} [inst_1 : TopologicalSpace Y]\n  [inst_2 : T2Space Y] {μ : MeasureTheory.Measure X} [inst_3 : MeasureTheory.Measure.IsOpenPosMeasure μ] {f g : X → Y},\n  f =ᶠ[MeasureTheory.Measure.ae μ] g → Continuous f → Continuous g → f = g :=\n\n/-- Every continuous function is uniformly continuous. -/\ntheorem", "choices": ["forall {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] [CompactSpace α] (f : α → β),\n  Continuous f → UniformContinuous f ", "∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] (self : α ≃ᵤ β),\n  UniformContinuous self.toFun ", "∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : CompactSpace α] (f : α → β),\n  Continuous f → UniformContinuous f ", "∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] {f : α → β},\n  Continuous f → UniformContinuous f ", "∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : CompactSpace α] {f : α → β},\n  Continuous f → UniformContinuous f ", "∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : UniformSpace β] {f : α → β},\n  Continuous f → UniformContinuous f ", "forall {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : CompactSpace α] (f : α → β),\n  Continuous f → UniformContinuous f ", "∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : CompactSpace α]\n  (f : α → β), Continuous f → UniformContinuous f ", "∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : CompactSpace α] (f : α → β),\n  Continuous f → UniformContinuous f ", "∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : UniformSpace β] {f : α → β}, Continuous f → UniformContinuous f "]}
{"docString": "Every uniformly continuous function is bounded above.", "prompts": "[{\"theorem\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderClosedTopology α]\\n  [inst_3 : TopologicalSpace β] [inst_4 : Nonempty α] {f : β → α} {K : Set β},\\n  IsCompact K → ContinuousOn f K → BddAbove (f '' K)\",\n  \"isProp\": true,\n  \"docString\": \"A continuous function is bounded above on a compact set. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderClosedTopology α]\\n  [inst_3 : TopologicalSpace β] [inst_4 : Zero α] {f : β → α},\\n  Continuous f → HasCompactSupport f → BddAbove (Set.range f)\",\n  \"isProp\": true,\n  \"docString\": \"A continuous function with compact support is bounded above. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {p : Filter ι}\\n  [inst_1 : TopologicalSpace α],\\n  TendstoUniformly F f p → (∀ᶠ (n : ι) in p, Continuous (F n)) → ∀ [inst_2 : Filter.NeBot p], Continuous f\",\n  \"isProp\": true,\n  \"docString\": \"A uniform limit of continuous functions is continuous. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderClosedTopology α]\\n  [inst_3 : TopologicalSpace β] [inst_4 : Nonempty α] {f : β → α} {K : Set β},\\n  IsCompact K → ContinuousOn f K → BddBelow (f '' K)\",\n  \"isProp\": true,\n  \"docString\": \"A continuous function is bounded below on a compact set. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {p : Filter ι}\\n  [inst_1 : TopologicalSpace α],\\n  TendstoLocallyUniformly F f p → (∀ᶠ (n : ι) in p, Continuous (F n)) → ∀ [inst_2 : Filter.NeBot p], Continuous f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A locally uniform limit of continuous functions is continuous. \"},\n {\"theorem\":\n  \"∀ {α : Type u_2} {ι : Sort u_1} [inst : ConditionallyCompleteLattice α] [inst_1 : Nonempty ι] {f : ι → α} {c : α},\\n  (∀ (x : ι), f x ≤ c) → iSup f ≤ c\",\n  \"isProp\": true,\n  \"docString\":\n  \"The indexed supremum of a function is bounded above by a uniform bound\"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : SemilatticeSup α] [inst_1 : Nonempty α] {s : Set α}, Set.Finite s → BddAbove s\",\n  \"isProp\": true,\n  \"docString\": \"A finite set is bounded above.\"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderClosedTopology α]\\n  [inst_3 : TopologicalSpace β] [inst_4 : Zero α] {f : β → α},\\n  Continuous f → HasCompactSupport f → BddBelow (Set.range f)\",\n  \"isProp\": true,\n  \"docString\": \"A continuous function with compact support is bounded below. \"},\n {\"theorem\":\n  \"∀ {ι : Type u_1} {α : Type u_2} {β : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β] {F : ι → β → α},\\n  UniformEquicontinuous F → ∀ (i : ι), UniformContinuous (F i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Each function of a uniformly equicontinuous family is uniformly continuous. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : PseudoMetricSpace α] {f : ℝ → α} {c : ℝ},\\n  Function.Periodic f c → c ≠ 0 → Continuous f → Metric.Bounded (Set.range f)\",\n  \"isProp\": true,\n  \"docString\": \"A continuous, periodic function is bounded. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : SemilatticeSup α] [inst_1 : Nonempty α] {I : Set β} {S : β → Set α},\\n  Set.Finite I → (BddAbove (⋃ (i : β) (_ : i ∈ I), S i) ↔ ∀ (i : β), i ∈ I → BddAbove (S i))\",\n  \"isProp\": true,\n  \"docString\":\n  \"A finite union of sets which are all bounded above is still bounded above.\"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : UniformSpace β] {f : α → β} [inst_1 : TopologicalSpace α],\\n  (∀ (u : Set (β × β)), u ∈ uniformity β → ∃ F, Continuous F ∧ ∀ (y : α), (f y, F y) ∈ u) → Continuous f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be uniformly approximated by continuous functions is continuous. \"},\n {\"theorem\":\n  \"∀ {α : Type u_2} {β : Type u_1} {ι : Type u_3} {m : MeasurableSpace α} (μ : MeasureTheory.Measure α)\\n  [inst : NormedAddCommGroup β] {p : ENNReal} {g : α → β},\\n  1 ≤ p → p ≠ ⊤ → MeasureTheory.Memℒp g p → MeasureTheory.UnifIntegrable (fun x => g) p μ\",\n  \"isProp\": true,\n  \"docString\": \"A constant function is uniformly integrable. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : UniformSpace α] [inst_1 : UniformSpace β] {f : α → β} {s : Set α},\\n  TotallyBounded s → UniformContinuous f → TotallyBounded (f '' s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The image of a totally bounded set under a uniformly continuous map is totally bounded. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : UniformSpace β] {f : α → β} [inst_1 : TopologicalSpace α],\\n  (∀ (x : α) (u : Set (β × β)),\\n      u ∈ uniformity β → ∃ t, t ∈ nhds x ∧ ∃ F, ContinuousAt F x ∧ ∀ (y : α), y ∈ t → (f y, F y) ∈ u) →\\n    Continuous f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be locally uniformly approximated by continuous functions is continuous. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {s : Set α} {p : Filter ι}\\n  [inst_1 : TopologicalSpace α],\\n  TendstoUniformlyOn F f p s → (∀ᶠ (n : ι) in p, ContinuousOn (F n) s) → ∀ [inst_2 : Filter.NeBot p], ContinuousOn f s\",\n  \"isProp\": true,\n  \"docString\":\n  \"A uniform limit on a set of functions which are continuous on this set is itself continuous\\non this set. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {s : Set α} {p : Filter ι}\\n  [inst_1 : TopologicalSpace α],\\n  TendstoLocallyUniformlyOn F f p s →\\n    (∀ᶠ (n : ι) in p, ContinuousOn (F n) s) → ∀ [inst_2 : Filter.NeBot p], ContinuousOn f s\",\n  \"isProp\": true,\n  \"docString\":\n  \"A locally uniform limit on a set of functions which are continuous on this set is itself\\ncontinuous on this set. \"},\n {\"theorem\":\n  \"∀ {γ : Type w} [inst : SemilatticeInf γ] {s t : Set γ}, BddBelow (s ∪ t) ↔ BddBelow s ∧ BddBelow t\",\n  \"isProp\": true,\n  \"docString\":\n  \"The union of two sets is bounded above if and only if each of the sets is.\"},\n {\"theorem\":\n  \"∀ {α : Type u_2} {β : Type u_1} {ι : Type u_3} {m : MeasurableSpace α} {μ : MeasureTheory.Measure α}\\n  [inst : NormedAddCommGroup β] {p : ENNReal} {g : α → β},\\n  1 ≤ p → p ≠ ⊤ → MeasureTheory.Memℒp g p → MeasureTheory.UniformIntegrable (fun x => g) p μ\",\n  \"isProp\": true,\n  \"docString\":\n  \"A constant sequence of functions is uniformly integrable in the probability sense. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {ι : Sort u_2} [inst : ConditionallyCompleteLattice α] {f : ι → α},\\n  BddBelow (Set.range f) → ∀ (c : ι), iInf f ≤ f c\",\n  \"isProp\": true,\n  \"docString\":\n  \"The indexed infimum of a function is bounded above by the value taken at one point\"}]\n", "prompt_cons": "/-- A continuous function is bounded above on a compact set. -/\ntheorem ∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderClosedTopology α]\n  [inst_3 : TopologicalSpace β] [inst_4 : Nonempty α] {f : β → α} {K : Set β},\n  IsCompact K → ContinuousOn f K → BddAbove (f '' K) :=\n\n/-- A continuous function with compact support is bounded above. -/\ntheorem ∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderClosedTopology α]\n  [inst_3 : TopologicalSpace β] [inst_4 : Zero α] {f : β → α},\n  Continuous f → HasCompactSupport f → BddAbove (Set.range f) :=\n\n/-- A uniform limit of continuous functions is continuous. -/\ntheorem ∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {p : Filter ι}\n  [inst_1 : TopologicalSpace α],\n  TendstoUniformly F f p → (∀ᶠ (n : ι) in p, Continuous (F n)) → ∀ [inst_2 : Filter.NeBot p], Continuous f :=\n\n/-- A continuous function is bounded below on a compact set. -/\ntheorem ∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderClosedTopology α]\n  [inst_3 : TopologicalSpace β] [inst_4 : Nonempty α] {f : β → α} {K : Set β},\n  IsCompact K → ContinuousOn f K → BddBelow (f '' K) :=\n\n/-- A locally uniform limit of continuous functions is continuous. -/\ntheorem ∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {p : Filter ι}\n  [inst_1 : TopologicalSpace α],\n  TendstoLocallyUniformly F f p → (∀ᶠ (n : ι) in p, Continuous (F n)) → ∀ [inst_2 : Filter.NeBot p], Continuous f :=\n\n/-- The indexed supremum of a function is bounded above by a uniform bound -/\ntheorem ∀ {α : Type u_2} {ι : Sort u_1} [inst : ConditionallyCompleteLattice α] [inst_1 : Nonempty ι] {f : ι → α} {c : α},\n  (∀ (x : ι), f x ≤ c) → iSup f ≤ c :=\n\n/-- A finite set is bounded above. -/\ntheorem ∀ {α : Type u} [inst : SemilatticeSup α] [inst_1 : Nonempty α] {s : Set α}, Set.Finite s → BddAbove s :=\n\n/-- A continuous function with compact support is bounded below. -/\ntheorem ∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderClosedTopology α]\n  [inst_3 : TopologicalSpace β] [inst_4 : Zero α] {f : β → α},\n  Continuous f → HasCompactSupport f → BddBelow (Set.range f) :=\n\n/-- Each function of a uniformly equicontinuous family is uniformly continuous. -/\ntheorem ∀ {ι : Type u_1} {α : Type u_2} {β : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β] {F : ι → β → α},\n  UniformEquicontinuous F → ∀ (i : ι), UniformContinuous (F i) :=\n\n/-- A continuous, periodic function is bounded. -/\ntheorem ∀ {α : Type u} [inst : PseudoMetricSpace α] {f : ℝ → α} {c : ℝ},\n  Function.Periodic f c → c ≠ 0 → Continuous f → Metric.Bounded (Set.range f) :=\n\n/-- A finite union of sets which are all bounded above is still bounded above. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : SemilatticeSup α] [inst_1 : Nonempty α] {I : Set β} {S : β → Set α},\n  Set.Finite I → (BddAbove (⋃ (i : β) (_ : i ∈ I), S i) ↔ ∀ (i : β), i ∈ I → BddAbove (S i)) :=\n\n/-- A function which can be uniformly approximated by continuous functions is continuous. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : UniformSpace β] {f : α → β} [inst_1 : TopologicalSpace α],\n  (∀ (u : Set (β × β)), u ∈ uniformity β → ∃ F, Continuous F ∧ ∀ (y : α), (f y, F y) ∈ u) → Continuous f :=\n\n/-- A constant function is uniformly integrable. -/\ntheorem ∀ {α : Type u_2} {β : Type u_1} {ι : Type u_3} {m : MeasurableSpace α} (μ : MeasureTheory.Measure α)\n  [inst : NormedAddCommGroup β] {p : ENNReal} {g : α → β},\n  1 ≤ p → p ≠ ⊤ → MeasureTheory.Memℒp g p → MeasureTheory.UnifIntegrable (fun x => g) p μ :=\n\n/-- The image of a totally bounded set under a uniformly continuous map is totally bounded. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : UniformSpace α] [inst_1 : UniformSpace β] {f : α → β} {s : Set α},\n  TotallyBounded s → UniformContinuous f → TotallyBounded (f '' s) :=\n\n/-- A function which can be locally uniformly approximated by continuous functions is continuous. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : UniformSpace β] {f : α → β} [inst_1 : TopologicalSpace α],\n  (∀ (x : α) (u : Set (β × β)),\n      u ∈ uniformity β → ∃ t, t ∈ nhds x ∧ ∃ F, ContinuousAt F x ∧ ∀ (y : α), y ∈ t → (f y, F y) ∈ u) →\n    Continuous f :=\n\n/-- A uniform limit on a set of functions which are continuous on this set is itself continuous\non this set. -/\ntheorem ∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {s : Set α} {p : Filter ι}\n  [inst_1 : TopologicalSpace α],\n  TendstoUniformlyOn F f p s → (∀ᶠ (n : ι) in p, ContinuousOn (F n) s) → ∀ [inst_2 : Filter.NeBot p], ContinuousOn f s :=\n\n/-- A locally uniform limit on a set of functions which are continuous on this set is itself\ncontinuous on this set. -/\ntheorem ∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {s : Set α} {p : Filter ι}\n  [inst_1 : TopologicalSpace α],\n  TendstoLocallyUniformlyOn F f p s →\n    (∀ᶠ (n : ι) in p, ContinuousOn (F n) s) → ∀ [inst_2 : Filter.NeBot p], ContinuousOn f s :=\n\n/-- The union of two sets is bounded above if and only if each of the sets is. -/\ntheorem ∀ {γ : Type w} [inst : SemilatticeInf γ] {s t : Set γ}, BddBelow (s ∪ t) ↔ BddBelow s ∧ BddBelow t :=\n\n/-- A constant sequence of functions is uniformly integrable in the probability sense. -/\ntheorem ∀ {α : Type u_2} {β : Type u_1} {ι : Type u_3} {m : MeasurableSpace α} {μ : MeasureTheory.Measure α}\n  [inst : NormedAddCommGroup β] {p : ENNReal} {g : α → β},\n  1 ≤ p → p ≠ ⊤ → MeasureTheory.Memℒp g p → MeasureTheory.UniformIntegrable (fun x => g) p μ :=\n\n/-- The indexed infimum of a function is bounded above by the value taken at one point -/\ntheorem ∀ {α : Type u_1} {ι : Sort u_2} [inst : ConditionallyCompleteLattice α] {f : ι → α},\n  BddBelow (Set.range f) → ∀ (c : ι), iInf f ≤ f c :=\n\n/-- Every uniformly continuous function is bounded above. -/\ntheorem", "choices": ["∀ {α : Type u} {β : Type v} [inst : PseudoMetricSpace α] [inst_1 : PseudoMetricSpace β] {f : α → β},\n  UniformContinuous f → Metric.Bounded (Set.range f) ", "∀ {α : Type u} {β : Type v} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : Nonempty α] [inst_3 : BoundedOrder β]\n  {f : α → β}, UniformContinuous f → BddAbove (Set.range f) ", "∀ {α : Type u} {β : Type v} [inst : UniformSpace α] [inst_1 : UniformSpace β] {f : α → β} [inst_2 : BoundedOrder β],\n  UniformContinuous f → BddAbove (Set.range f) ", "∀ {α : Type u_1} {β : Type u_2} [inst : PseudoMetricSpace α] [inst_1 : PseudoMetricSpace β] {f : α → β},\n  UniformContinuous f → Metric.Bounded (Set.range f) ", "∀ {α : Type u} {β : Type v} [inst : PseudoMetricSpace α] [inst_1 : PseudoMetricSpace β] {f : α → β},\n  UniformContinuous f → Metric.Bounded (Set.range f) ", "∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : LinearOrder β] [inst_2 : TopologicalSpace β]\n  [inst_3 : OrderClosedTopology β] [inst_4 : Nonempty α] {f : α → β},\n  UniformContinuous f → BddAbove (Set.range f) ", "∀ {α : Type u} {β : Type v} [inst : PseudoMetricSpace α] [inst_1 : PseudoMetricSpace β] {f : α → β},\n  UniformContinuous f → Metric.Bounded (Set.range f) ", "∀ {α : Type u} {β : Type v} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : BoundedSpace α] [inst_3 : Nonempty α] {f : α → β},\n  UniformContinuous f → BddAbove (Set.range f) ", "∀ {α : Type u} {β : Type v} [inst : UniformSpace α] [inst_1 : PseudoMetricSpace β] [inst_2 : Nonempty α] {f : α → β},\n  UniformContinuous f → BddAbove (Set.range f) ", "∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : Nonempty α] [inst_2 : SemilatticeSup α] [inst_3 : TopologicalSpace β]\n  {f : β → α}, UniformContinuous f → BddAbove (Set.range f) "]}
{"docString": "If every compact subset of a topological space is closed, then the space is compact.", "prompts": "[{\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : Finite α], CompactSpace α\",\n  \"isProp\": true,\n  \"docString\": \"Finite topological spaces are compact. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : EMetricSpace α] [inst_1 : CompactSpace α], CompactSpace (TopologicalSpace.Closeds α)\",\n  \"isProp\": true,\n  \"docString\": \"In a compact space, the type of closed subsets is compact. \"},\n {\"theorem\": \"∀ (self : CompHaus), CompactSpace ↑self.toTop\",\n  \"isProp\": true,\n  \"docString\": \"The underlying topological space is compact.\"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {s t : Set α}, IsCompact s → IsClosed t → t ⊆ s → IsCompact t\",\n  \"isProp\": true,\n  \"docString\": \"A closed subset of a compact set is a compact set. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] {K : Set α},\\n  IsCompact K → ∃ K', IsCompact K' ∧ K ⊆ interior K'\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact space, every compact set is contained in the interior of a compact set. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T2Space α] {s : Set α}, IsCompact s → IsClosed s\",\n  \"isProp\": true,\n  \"docString\": \"In a `T2Space`, every compact set is closed. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] [inst_2 : T2Space α] {K : Set α},\\n  IsCompact K → ∃ V, IsOpen V ∧ K ⊆ V ∧ IsCompact (closure V)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact T₂ space, every compact set has an open neighborhood with compact closure.\\n\"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {s t : Set α}, IsCompact t → IsClosed s → IsCompact (s ∩ t)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The intersection of a closed set and a compact set is a compact set. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {s t : Set α}, IsCompact s → IsClosed t → IsCompact (s ∩ t)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The intersection of a compact set and a closed set is a compact set. \"},\n {\"theorem\":\n  \"∀ {R : Type u} {M : Type v} [inst : Semiring R] [inst_1 : TopologicalSpace M] [inst_2 : AddCommMonoid M]\\n  [inst_3 : Module R M] [inst_4 : ContinuousConstSMul R M] [inst_5 : ContinuousAdd M] {s : Submodule R M},\\n  Dense ↑s ↔ Submodule.topologicalClosure s = ⊤\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subspace is dense iff its topological closure is the entire space. \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} [inst : TopologicalSpace X], CompactSpace (OnePoint X)\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any topological space `X`, its one point compactification is a compact space. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace.NoetherianSpace α] (s : Set α), IsCompact s\",\n  \"isProp\": true,\n  \"docString\": \"In a Noetherian space, all sets are compact. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : EMetricSpace α] [inst_1 : CompactSpace α], CompactSpace (TopologicalSpace.NonemptyCompacts α)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a compact space, the type of nonempty compact subsets is compact. This follows from\\nthe same statement for closed subsets \"},\n {\"theorem\":\n  \"∀ {𝕜₁ : Type u_1} {𝕜₂ : Type u_2} [inst : NontriviallyNormedField 𝕜₁] [inst_1 : NormedField 𝕜₂] {σ₁₂ : 𝕜₁ →+* 𝕜₂}\\n  {M₁ : Type u_3} {M₂ : Type u_4} [inst_2 : SeminormedAddCommGroup M₁] [inst_3 : AddCommGroup M₂]\\n  [inst_4 : NormedSpace 𝕜₁ M₁] [inst_5 : Module 𝕜₂ M₂] [inst_6 : UniformSpace M₂] [inst_7 : UniformAddGroup M₂]\\n  [inst_8 : ContinuousConstSMul 𝕜₂ M₂] [inst_9 : T2Space M₂] [inst_10 : CompleteSpace M₂],\\n  IsClosed {f | IsCompactOperator ↑f}\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of compact operators from a normed space to a complete topological vector space is\\nclosed. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [self : LocallyCompactSpace α] (x : α) (n : Set α),\\n  n ∈ nhds x → ∃ s, s ∈ nhds x ∧ s ⊆ n ∧ IsCompact s\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact space,\\nevery neighbourhood of every point contains a compact neighbourhood of that same point. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] (x : α), ∃ K, IsCompact K ∧ K ∈ nhds x\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact space every point has a compact neighborhood. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_2} {E : Type u_1} [inst : LinearOrderedField 𝕜] [inst_1 : AddCommGroup E] [inst_2 : Module 𝕜 E]\\n  [inst_3 : TopologicalSpace E] [inst_4 : TopologicalAddGroup E] [inst_5 : ContinuousConstSMul 𝕜 E] {s : Set E},\\n  Convex 𝕜 s → Convex 𝕜 (closure s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a topological vector space, the closure of a convex set is convex. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T2Space α],\\n  (∀ (x : α), ∃ s, s ∈ nhds x ∧ IsCompact s) → LocallyCompactSpace α\",\n  \"isProp\": true,\n  \"docString\":\n  \"If every points of a Hausdorff space admits a compact neighborhood, then this space is locally\\ncompact. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [self : QuasiSeparatedSpace α] (U V : Set α),\\n  IsOpen U → IsCompact U → IsOpen V → IsCompact V → IsCompact (U ∩ V)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The intersection of two open compact subsets of a quasi-separated space is compact.\"},\n {\"theorem\": \"∀ {X Y : CompHaus} (f : X ⟶ Y), IsClosedMap ↑f\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any continuous function on compact Hausdorff spaces is a closed map. \"}]\n", "prompt_cons": "/-- Finite topological spaces are compact. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : Finite α], CompactSpace α :=\n\n/-- In a compact space, the type of closed subsets is compact. -/\ntheorem ∀ {α : Type u} [inst : EMetricSpace α] [inst_1 : CompactSpace α], CompactSpace (TopologicalSpace.Closeds α) :=\n\n/-- The underlying topological space is compact. -/\ntheorem ∀ (self : CompHaus), CompactSpace ↑self.toTop :=\n\n/-- A closed subset of a compact set is a compact set. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] {s t : Set α}, IsCompact s → IsClosed t → t ⊆ s → IsCompact t :=\n\n/-- In a locally compact space, every compact set is contained in the interior of a compact set. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] {K : Set α},\n  IsCompact K → ∃ K', IsCompact K' ∧ K ⊆ interior K' :=\n\n/-- In a `T2Space`, every compact set is closed. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T2Space α] {s : Set α}, IsCompact s → IsClosed s :=\n\n/-- In a locally compact T₂ space, every compact set has an open neighborhood with compact closure. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] [inst_2 : T2Space α] {K : Set α},\n  IsCompact K → ∃ V, IsOpen V ∧ K ⊆ V ∧ IsCompact (closure V) :=\n\n/-- The intersection of a closed set and a compact set is a compact set. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] {s t : Set α}, IsCompact t → IsClosed s → IsCompact (s ∩ t) :=\n\n/-- The intersection of a compact set and a closed set is a compact set. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] {s t : Set α}, IsCompact s → IsClosed t → IsCompact (s ∩ t) :=\n\n/-- A subspace is dense iff its topological closure is the entire space. -/\ntheorem ∀ {R : Type u} {M : Type v} [inst : Semiring R] [inst_1 : TopologicalSpace M] [inst_2 : AddCommMonoid M]\n  [inst_3 : Module R M] [inst_4 : ContinuousConstSMul R M] [inst_5 : ContinuousAdd M] {s : Submodule R M},\n  Dense ↑s ↔ Submodule.topologicalClosure s = ⊤ :=\n\n/-- For any topological space `X`, its one point compactification is a compact space. -/\ntheorem ∀ {X : Type u_1} [inst : TopologicalSpace X], CompactSpace (OnePoint X) :=\n\n/-- In a Noetherian space, all sets are compact. -/\ntheorem ∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace.NoetherianSpace α] (s : Set α), IsCompact s :=\n\n/-- In a compact space, the type of nonempty compact subsets is compact. This follows from\nthe same statement for closed subsets -/\ntheorem ∀ {α : Type u} [inst : EMetricSpace α] [inst_1 : CompactSpace α], CompactSpace (TopologicalSpace.NonemptyCompacts α) :=\n\n/-- The set of compact operators from a normed space to a complete topological vector space is\nclosed. -/\ntheorem ∀ {𝕜₁ : Type u_1} {𝕜₂ : Type u_2} [inst : NontriviallyNormedField 𝕜₁] [inst_1 : NormedField 𝕜₂] {σ₁₂ : 𝕜₁ →+* 𝕜₂}\n  {M₁ : Type u_3} {M₂ : Type u_4} [inst_2 : SeminormedAddCommGroup M₁] [inst_3 : AddCommGroup M₂]\n  [inst_4 : NormedSpace 𝕜₁ M₁] [inst_5 : Module 𝕜₂ M₂] [inst_6 : UniformSpace M₂] [inst_7 : UniformAddGroup M₂]\n  [inst_8 : ContinuousConstSMul 𝕜₂ M₂] [inst_9 : T2Space M₂] [inst_10 : CompleteSpace M₂],\n  IsClosed {f | IsCompactOperator ↑f} :=\n\n/-- In a locally compact space,\nevery neighbourhood of every point contains a compact neighbourhood of that same point. -/\ntheorem ∀ {α : Type u_1} [inst : TopologicalSpace α] [self : LocallyCompactSpace α] (x : α) (n : Set α),\n  n ∈ nhds x → ∃ s, s ∈ nhds x ∧ s ⊆ n ∧ IsCompact s :=\n\n/-- In a locally compact space every point has a compact neighborhood. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] (x : α), ∃ K, IsCompact K ∧ K ∈ nhds x :=\n\n/-- In a topological vector space, the closure of a convex set is convex. -/\ntheorem ∀ {𝕜 : Type u_2} {E : Type u_1} [inst : LinearOrderedField 𝕜] [inst_1 : AddCommGroup E] [inst_2 : Module 𝕜 E]\n  [inst_3 : TopologicalSpace E] [inst_4 : TopologicalAddGroup E] [inst_5 : ContinuousConstSMul 𝕜 E] {s : Set E},\n  Convex 𝕜 s → Convex 𝕜 (closure s) :=\n\n/-- If every points of a Hausdorff space admits a compact neighborhood, then this space is locally\ncompact. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T2Space α],\n  (∀ (x : α), ∃ s, s ∈ nhds x ∧ IsCompact s) → LocallyCompactSpace α :=\n\n/-- The intersection of two open compact subsets of a quasi-separated space is compact. -/\ntheorem ∀ {α : Type u_1} [inst : TopologicalSpace α] [self : QuasiSeparatedSpace α] (U V : Set α),\n  IsOpen U → IsCompact U → IsOpen V → IsCompact V → IsCompact (U ∩ V) :=\n\n/-- Any continuous function on compact Hausdorff spaces is a closed map. -/\ntheorem ∀ {X Y : CompHaus} (f : X ⟶ Y), IsClosedMap ↑f :=\n\n/-- If every compact subset of a topological space is closed, then the space is compact. -/\ntheorem", "choices": ["∀ {α : Type u} [inst : TopologicalSpace α], (∀ (s : Set α), IsCompact s → IsClosed s) → CompactSpace α ", "∀ {α : Type u} [inst : TopologicalSpace α],\n  (∀ (s : Set α), IsCompact s → IsClosed s) → CompactSpace α ", "∀ {α : Type u} [inst : TopologicalSpace α], (∀ (s : Set α), IsCompact s → IsClosed s) → CompactSpace α ", "∀ {α : Type u} [inst : TopologicalSpace α], (∀ (s : Set α), IsCompact s → IsClosed s) → CompactSpace α ", "∀ {α : Type u} [inst : TopologicalSpace α], (∀ (s : Set α), IsCompact s → IsClosed s) → CompactSpace α ", "∀ {α : Type u} [inst : TopologicalSpace α],\n  (∀ (s : Set α), IsCompact s → IsClosed s) → CompactSpace α ", "∀ {α : Type u} [inst : TopologicalSpace α], (∀ (s : Set α), IsCompact s → IsClosed s) → CompactSpace α ", "∀ {α : Type u} [inst : TopologicalSpace α], (∀ (s : Set α), IsCompact s → IsClosed s) → CompactSpace α ", "∀ {α : Type u} [inst : TopologicalSpace α], (∀ (s : Set α), IsCompact s → IsClosed s) → CompactSpace α ", "∀ {α : Type u} [inst : TopologicalSpace α], (∀ (s : Set α), IsCompact s → IsClosed s) → CompactSpace α "]}
{"docString": "In a commutative ring, the sum of idempotent elements is idempotent.", "prompts": "[{\"theorem\": \"∀ {α : Type u_1} [self : BooleanRing α] (a : α), a * a = a\",\n  \"isProp\": true,\n  \"docString\": \"Multiplication in a boolean ring is idempotent. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} {S : Type u_2} [inst : Mul R] [inst_1 : Mul S] [inst_2 : Add R] [inst_3 : Add S] (e : R ≃+* S)\\n  (x y : R), ↑e (x + y) = ↑e x + ↑e y\",\n  \"isProp\": true,\n  \"docString\": \"A ring isomorphism preserves addition. \"},\n {\"theorem\":\n  \"∀ (D : Type u_1) [inst : CategoryTheory.Category D] [inst_1 : CategoryTheory.Abelian D],\\n  CategoryTheory.IsIdempotentComplete D\",\n  \"isProp\": true,\n  \"docString\": \"An abelian category is idempotent complete. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : CommRing R] (I : Ideal R),\\n  Ideal.FG I → (IsIdempotentElem I ↔ ∃ e, IsIdempotentElem e ∧ I = Submodule.span R {e})\",\n  \"isProp\": true,\n  \"docString\":\n  \"A finitely generated idempotent ideal is generated by an idempotent element \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [self : StrictOrderedCommRing α] (a b : α), a * b = b * a\",\n  \"isProp\": true,\n  \"docString\": \"Multiplication is commutative in a commutative semigroup. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} {S : Type u_2} [inst : Mul R] [inst_1 : Mul S] [inst_2 : Add R] [inst_3 : Add S] (e : R ≃+* S)\\n  (x y : R), ↑e (x * y) = ↑e x * ↑e y\",\n  \"isProp\": true,\n  \"docString\": \"A ring isomorphism preserves multiplication. \"},\n {\"theorem\":\n  \"∀ {β : Type u} {α : Type v} [inst : AddCommMonoid β] {s : Finset α} (f : α → β),\\n  MulOpposite.op (Finset.sum s fun x => f x) = Finset.sum s fun x => MulOpposite.op (f x)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Moving to the opposite additive commutative monoid commutes with summing. \"},\n {\"theorem\":\n  \"∀ {F : Type u_1} {R : outParam (Type u_2)} {S : outParam (Type u_3)} [inst : Mul R] [inst_1 : Add R] [inst_2 : Mul S]\\n  [inst_3 : Add S] [self : RingEquivClass F R S] (f : F) (a b : R), ↑f (a + b) = ↑f a + ↑f b\",\n  \"isProp\": true,\n  \"docString\":\n  \"By definition, a ring isomorphism preserves the additive structure. \"},\n {\"theorem\":\n  \"∀ (R : Type u) [inst : Semiring R] {ι : Type v} [dec_ι : DecidableEq ι] {M : ι → Type w}\\n  [inst_1 : (i : ι) → AddCommMonoid (M i)] [inst_2 : (i : ι) → Module R (M i)] (s : Finset ι) (c : R)\\n  (x : (i : ↑↑s) → M ↑i), ↑(DirectSum.mk M s) (c • x) = c • ↑(DirectSum.mk M s) x\",\n  \"isProp\": true,\n  \"docString\": \"Scalar multiplication commutes with direct sums. \"},\n {\"theorem\": \"∀ {S : Type u_1} [inst : Mul S] (a : S), Commute a a\",\n  \"isProp\": true,\n  \"docString\": \"Any element commutes with itself. \"},\n {\"theorem\": \"∀ {S : Type u_1} [inst : Add S] (a : S), AddCommute a a\",\n  \"isProp\": true,\n  \"docString\": \"Any element commutes with itself.\"},\n {\"theorem\":\n  \"∀ {C : Type u_1} [inst : CategoryTheory.Category C] (self : CategoryTheory.Idempotents.Karoubi C),\\n  CategoryTheory.CategoryStruct.comp self.p self.p = self.p\",\n  \"isProp\": true,\n  \"docString\": \"the condition that the given endomorphism is an idempotent \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : NonAssocSemiring R] (self : Subsemiring R) {a b : R},\\n  a ∈ self.carrier → b ∈ self.carrier → a + b ∈ self.carrier\",\n  \"isProp\": true,\n  \"docString\":\n  \"The sum of two elements of an additive subsemigroup belongs to the subsemigroup. \"},\n {\"theorem\":\n  \"∀ (R : Type u) [inst : Semiring R] {ι : Type v} [dec_ι : DecidableEq ι] {M : ι → Type w}\\n  [inst_1 : (i : ι) → AddCommMonoid (M i)] [inst_2 : (i : ι) → Module R (M i)] (i : ι) (c : R) (x : M i),\\n  ↑(DirectSum.of M i) (c • x) = c • ↑(DirectSum.of M i) x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Scalar multiplication commutes with the inclusion of each component into the direct sum. \"},\n {\"theorem\":\n  \"∀ {M : Type u} [self : AddCancelCommMonoid M] (a b : M), a + b = b + a\",\n  \"isProp\": true,\n  \"docString\":\n  \"Addition is commutative in an additive commutative semigroup. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : Semigroup R] {a b : R}, IsRightRegular a → IsRightRegular b → IsRightRegular (a * b)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a semigroup, the product of right-regular elements is right-regular. \"},\n {\"theorem\":\n  \"∀ {M : Type u_1} [inst : Monoid M], SMulCommClass M { x // x ∈ Submonoid.center M } M\",\n  \"isProp\": true,\n  \"docString\": \"The center of a monoid acts commutatively on that monoid. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : AddMonoid G] {x y : G},\\n  AddCommute x y → IsOfFinAddOrder x → IsOfFinAddOrder y → IsOfFinAddOrder (x + y)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Commuting elements of finite additive order are closed under addition.\"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Monoid G] {x y : G}, Commute x y → IsOfFinOrder x → IsOfFinOrder y → IsOfFinOrder (x * y)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Commuting elements of finite order are closed under multiplication. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} (r : α → α → Prop), EqvGen.Setoid (Setoid.Rel (EqvGen.Setoid r)) = EqvGen.Setoid r\",\n  \"isProp\": true,\n  \"docString\": \"Equivalence closure is idempotent. \"}]\n", "prompt_cons": "/-- Multiplication in a boolean ring is idempotent. -/\ntheorem ∀ {α : Type u_1} [self : BooleanRing α] (a : α), a * a = a :=\n\n/-- A ring isomorphism preserves addition. -/\ntheorem ∀ {R : Type u_1} {S : Type u_2} [inst : Mul R] [inst_1 : Mul S] [inst_2 : Add R] [inst_3 : Add S] (e : R ≃+* S)\n  (x y : R), ↑e (x + y) = ↑e x + ↑e y :=\n\n/-- An abelian category is idempotent complete. -/\ntheorem ∀ (D : Type u_1) [inst : CategoryTheory.Category D] [inst_1 : CategoryTheory.Abelian D],\n  CategoryTheory.IsIdempotentComplete D :=\n\n/-- A finitely generated idempotent ideal is generated by an idempotent element -/\ntheorem ∀ {R : Type u_1} [inst : CommRing R] (I : Ideal R),\n  Ideal.FG I → (IsIdempotentElem I ↔ ∃ e, IsIdempotentElem e ∧ I = Submodule.span R {e}) :=\n\n/-- Multiplication is commutative in a commutative semigroup. -/\ntheorem ∀ {α : Type u_1} [self : StrictOrderedCommRing α] (a b : α), a * b = b * a :=\n\n/-- A ring isomorphism preserves multiplication. -/\ntheorem ∀ {R : Type u_1} {S : Type u_2} [inst : Mul R] [inst_1 : Mul S] [inst_2 : Add R] [inst_3 : Add S] (e : R ≃+* S)\n  (x y : R), ↑e (x * y) = ↑e x * ↑e y :=\n\n/-- Moving to the opposite additive commutative monoid commutes with summing. -/\ntheorem ∀ {β : Type u} {α : Type v} [inst : AddCommMonoid β] {s : Finset α} (f : α → β),\n  MulOpposite.op (Finset.sum s fun x => f x) = Finset.sum s fun x => MulOpposite.op (f x) :=\n\n/-- By definition, a ring isomorphism preserves the additive structure. -/\ntheorem ∀ {F : Type u_1} {R : outParam (Type u_2)} {S : outParam (Type u_3)} [inst : Mul R] [inst_1 : Add R] [inst_2 : Mul S]\n  [inst_3 : Add S] [self : RingEquivClass F R S] (f : F) (a b : R), ↑f (a + b) = ↑f a + ↑f b :=\n\n/-- Scalar multiplication commutes with direct sums. -/\ntheorem ∀ (R : Type u) [inst : Semiring R] {ι : Type v} [dec_ι : DecidableEq ι] {M : ι → Type w}\n  [inst_1 : (i : ι) → AddCommMonoid (M i)] [inst_2 : (i : ι) → Module R (M i)] (s : Finset ι) (c : R)\n  (x : (i : ↑↑s) → M ↑i), ↑(DirectSum.mk M s) (c • x) = c • ↑(DirectSum.mk M s) x :=\n\n/-- Any element commutes with itself. -/\ntheorem ∀ {S : Type u_1} [inst : Mul S] (a : S), Commute a a :=\n\n/-- Any element commutes with itself. -/\ntheorem ∀ {S : Type u_1} [inst : Add S] (a : S), AddCommute a a :=\n\n/-- the condition that the given endomorphism is an idempotent -/\ntheorem ∀ {C : Type u_1} [inst : CategoryTheory.Category C] (self : CategoryTheory.Idempotents.Karoubi C),\n  CategoryTheory.CategoryStruct.comp self.p self.p = self.p :=\n\n/-- The sum of two elements of an additive subsemigroup belongs to the subsemigroup. -/\ntheorem ∀ {R : Type u} [inst : NonAssocSemiring R] (self : Subsemiring R) {a b : R},\n  a ∈ self.carrier → b ∈ self.carrier → a + b ∈ self.carrier :=\n\n/-- Scalar multiplication commutes with the inclusion of each component into the direct sum. -/\ntheorem ∀ (R : Type u) [inst : Semiring R] {ι : Type v} [dec_ι : DecidableEq ι] {M : ι → Type w}\n  [inst_1 : (i : ι) → AddCommMonoid (M i)] [inst_2 : (i : ι) → Module R (M i)] (i : ι) (c : R) (x : M i),\n  ↑(DirectSum.of M i) (c • x) = c • ↑(DirectSum.of M i) x :=\n\n/-- Addition is commutative in an additive commutative semigroup. -/\ntheorem ∀ {M : Type u} [self : AddCancelCommMonoid M] (a b : M), a + b = b + a :=\n\n/-- In a semigroup, the product of right-regular elements is right-regular. -/\ntheorem ∀ {R : Type u_1} [inst : Semigroup R] {a b : R}, IsRightRegular a → IsRightRegular b → IsRightRegular (a * b) :=\n\n/-- The center of a monoid acts commutatively on that monoid. -/\ntheorem ∀ {M : Type u_1} [inst : Monoid M], SMulCommClass M { x // x ∈ Submonoid.center M } M :=\n\n/-- Commuting elements of finite additive order are closed under addition. -/\ntheorem ∀ {G : Type u_1} [inst : AddMonoid G] {x y : G},\n  AddCommute x y → IsOfFinAddOrder x → IsOfFinAddOrder y → IsOfFinAddOrder (x + y) :=\n\n/-- Commuting elements of finite order are closed under multiplication. -/\ntheorem ∀ {G : Type u_1} [inst : Monoid G] {x y : G}, Commute x y → IsOfFinOrder x → IsOfFinOrder y → IsOfFinOrder (x * y) :=\n\n/-- Equivalence closure is idempotent. -/\ntheorem ∀ {α : Type u_1} (r : α → α → Prop), EqvGen.Setoid (Setoid.Rel (EqvGen.Setoid r)) = EqvGen.Setoid r :=\n\n/-- In a commutative ring, the sum of idempotent elements is idempotent. -/\ntheorem", "choices": ["∀ {R : Type u_1} [inst : CommRing R] (x y : R), IsIdempotentElem x → IsIdempotentElem y → Commute x y → IsIdempotentElem (x + y) ", "∀ {R : Type u_1} [inst : CommRing R] (x y : R), IsIdempotentElem x → IsIdempotentElem y → IsIdempotentElem (x + y) ", "∀ {R : Type u_1} [inst : CommRing R] (a b : R), IsIdempotentElem a → IsIdempotentElem b → IsIdempotentElem (a + b) ", "∀ {R : Type u_1} [inst : CommRing R] (a b : R), IsIdempotentElem a → IsIdempotentElem b → IsIdempotentElem (a + b) ", "∀ {R : Type u_1} [inst : CommRing R] {a b : R},\n  IsIdempotentElem a → IsIdempotentElem b → IsIdempotentElem (a + b) ", "∀ {R : Type u_1} [self : CommRing R] (a b : R), IsIdempotentElem a → IsIdempotentElem b → IsIdempotentElem (a + b) ", "∀ {R : Type u_1} [inst : CommRing R] (x y : R), IsIdempotentElem x → IsIdempotentElem y → Commute x y → IsIdempotentElem (x + y) ", "∀ {R : Type u_1} [inst : CommRing R] (e₁ e₂ : R), IsIdempotentElem e₁ → IsIdempotentElem e₂ → IsIdempotentElem (e₁ + e₂) ", "∀ {R : Type u_1} [inst : CommRing R] (a b : R), IsIdempotentElem a → IsIdempotentElem b → IsIdempotentElem (a + b) ", "∀ {R : Type u_1} [inst : CommRing R] (a b : R), IsIdempotentElem a → IsIdempotentElem b → IsIdempotentElem (a + b) "]}
{"docString": "The number of partitions of a finite set is a prime number.", "prompts": "[{\"theorem\":\n  \"∀ {α : Type u_1} [inst : Fintype α] [inst_1 : Field α], IsPrimePow (Fintype.card α)\",\n  \"isProp\": true,\n  \"docString\": \"A finite field has prime power cardinality. \"},\n {\"theorem\": \"Set.InjOn Nat.factorization {x | x ≠ 0}\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every nonzero natural number has a unique prime factorization \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\\n  Fintype.card α = p → IsSimpleGroup α\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is simple. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : AddGroup α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\\n  Fintype.card α = p → IsSimpleAddGroup α\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is simple.\"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)], Fintype.card α = p → IsCyclic α\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : AddGroup α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\\n  Fintype.card α = p → IsAddCyclic α\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic.\"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R], Prime PowerSeries.X\",\n  \"isProp\": true,\n  \"docString\":\n  \"The variable of the power series ring over an integral domain is prime.\"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : CommRing R] [inst_1 : Fintype R] (p : ℕ) [inst_2 : Fact (Nat.Prime p)],\\n  p ∣ ringChar R ↔ p ∣ Fintype.card R\",\n  \"isProp\": true,\n  \"docString\":\n  \"The prime divisors of the characteristic of a finite commutative ring are exactly\\nthe prime divisors of its cardinality. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {a : Set α}, Set.Finite a → Set.Finite {b | b ⊆ a}\",\n  \"isProp\": true,\n  \"docString\": \"There are finitely many subsets of a given finite set \"},\n {\"theorem\":\n  \"∀ {A : Type u_1} {B : Type u_2} [inst : Field A] [inst_1 : Ring B] [inst_2 : IsDomain B] [inst_3 : Algebra A B] {x : B},\\n  IsIntegral A x → Prime (minpoly A x)\",\n  \"isProp\": true,\n  \"docString\": \"A minimal polynomial is prime. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : CancelCommMonoidWithZero α] [dec_irr : (p : Associates α) → Decidable (Irreducible p)]\\n  [inst_1 : UniqueFactorizationMonoid α] [dec : DecidableEq α] [dec' : DecidableEq (Associates α)] {a p : Associates α},\\n  Irreducible p →\\n    ∀ [inst_2 : (n : ℕ) → Decidable (a ∣ p ^ n)] {n : ℕ} (h : a ∣ p ^ n),\\n      a = p ^ Nat.find (_ : ∃ n, (fun n => a ∣ p ^ n) n)\",\n  \"isProp\": true,\n  \"docString\": \"The only divisors of prime powers are prime powers. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} (f : α → Finset β), Set.Finite (Set.range f) → Set.Finite (⋃ (a : α), ↑(f a))\",\n  \"isProp\": true,\n  \"docString\": \"A finite union of finsets is finite. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : PseudoMetricSpace α] {s : Set α}, Set.Finite s → Metric.Bounded s\",\n  \"isProp\": true,\n  \"docString\": \"A finite set is bounded \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : CommRing R] [self : IsBezout R] (I : Ideal R), Ideal.FG I → Submodule.IsPrincipal I\",\n  \"isProp\": true,\n  \"docString\": \"Any finitely generated ideal is principal. \"},\n {\"theorem\":\n  \"∀ {ι : Type u_2} {R : Type u_1} [inst : CommMonoidWithZero R] [inst_1 : NoZeroDivisors R] [inst_2 : Nontrivial R]\\n  [inst_3 : DecidableEq R] [inst_4 : LT R] {s : Finset ι} {f : ι → WithTop R},\\n  (∀ (i : ι), i ∈ s → f i ≠ ⊤) → (Finset.prod s fun i => f i) < ⊤\",\n  \"isProp\": true,\n  \"docString\": \"A product of finite numbers is still finite \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R],\\n  Set.Finite {I | Ideal.IsPrime I} → IsPrincipalIdealRing R\",\n  \"isProp\": true,\n  \"docString\": \"A Dedekind domain is a PID if its set of primes is finite. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {s : Set α}, Set.Countable s → Set.Countable {t | Set.Finite t ∧ t ⊆ s}\",\n  \"isProp\": true,\n  \"docString\": \"The set of finite subsets of a countable set is countable. \"},\n {\"theorem\":\n  \"∀ {K : Type u_1} [inst : LinearOrderedField K] [inst_1 : FloorRing K] (v : K) (n : ℕ),\\n  ∃ q, GeneralizedContinuedFraction.convergents (GeneralizedContinuedFraction.of v) n = ↑q\",\n  \"isProp\": true,\n  \"docString\": \"Every finite convergent corresponds to a rational number. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : Lattice α] [inst_1 : OrderBot α] {a : α} (self : Finpartition a), Finset.SupIndep self.parts id\",\n  \"isProp\": true,\n  \"docString\": \"The partition is supremum-independent \"},\n {\"theorem\":\n  \"∀ (p : Nat.Primes), PNat.factorMultiset ↑p = PrimeMultiset.ofPrime p\",\n  \"isProp\": true,\n  \"docString\":\n  \"Factoring a prime gives the corresponding one-element multiset. \"}]\n", "prompt_cons": "/-- A finite field has prime power cardinality. -/\ntheorem ∀ {α : Type u_1} [inst : Fintype α] [inst_1 : Field α], IsPrimePow (Fintype.card α) :=\n\n/-- Every nonzero natural number has a unique prime factorization -/\ntheorem Set.InjOn Nat.factorization {x | x ≠ 0} :=\n\n/-- A finite group of prime order is simple. -/\ntheorem ∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\n  Fintype.card α = p → IsSimpleGroup α :=\n\n/-- A finite group of prime order is simple. -/\ntheorem ∀ {α : Type u} [inst : AddGroup α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\n  Fintype.card α = p → IsSimpleAddGroup α :=\n\n/-- A finite group of prime order is cyclic. -/\ntheorem ∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)], Fintype.card α = p → IsCyclic α :=\n\n/-- A finite group of prime order is cyclic. -/\ntheorem ∀ {α : Type u} [inst : AddGroup α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\n  Fintype.card α = p → IsAddCyclic α :=\n\n/-- The variable of the power series ring over an integral domain is prime. -/\ntheorem ∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R], Prime PowerSeries.X :=\n\n/-- The prime divisors of the characteristic of a finite commutative ring are exactly\nthe prime divisors of its cardinality. -/\ntheorem ∀ {R : Type u_1} [inst : CommRing R] [inst_1 : Fintype R] (p : ℕ) [inst_2 : Fact (Nat.Prime p)],\n  p ∣ ringChar R ↔ p ∣ Fintype.card R :=\n\n/-- There are finitely many subsets of a given finite set -/\ntheorem ∀ {α : Type u} {a : Set α}, Set.Finite a → Set.Finite {b | b ⊆ a} :=\n\n/-- A minimal polynomial is prime. -/\ntheorem ∀ {A : Type u_1} {B : Type u_2} [inst : Field A] [inst_1 : Ring B] [inst_2 : IsDomain B] [inst_3 : Algebra A B] {x : B},\n  IsIntegral A x → Prime (minpoly A x) :=\n\n/-- The only divisors of prime powers are prime powers. -/\ntheorem ∀ {α : Type u_1} [inst : CancelCommMonoidWithZero α] [dec_irr : (p : Associates α) → Decidable (Irreducible p)]\n  [inst_1 : UniqueFactorizationMonoid α] [dec : DecidableEq α] [dec' : DecidableEq (Associates α)] {a p : Associates α},\n  Irreducible p →\n    ∀ [inst_2 : (n : ℕ) → Decidable (a ∣ p ^ n)] {n : ℕ} (h : a ∣ p ^ n),\n      a = p ^ Nat.find (_ : ∃ n, (fun n => a ∣ p ^ n) n) :=\n\n/-- A finite union of finsets is finite. -/\ntheorem ∀ {α : Type u} {β : Type v} (f : α → Finset β), Set.Finite (Set.range f) → Set.Finite (⋃ (a : α), ↑(f a)) :=\n\n/-- A finite set is bounded -/\ntheorem ∀ {α : Type u} [inst : PseudoMetricSpace α] {s : Set α}, Set.Finite s → Metric.Bounded s :=\n\n/-- Any finitely generated ideal is principal. -/\ntheorem ∀ {R : Type u} [inst : CommRing R] [self : IsBezout R] (I : Ideal R), Ideal.FG I → Submodule.IsPrincipal I :=\n\n/-- A product of finite numbers is still finite -/\ntheorem ∀ {ι : Type u_2} {R : Type u_1} [inst : CommMonoidWithZero R] [inst_1 : NoZeroDivisors R] [inst_2 : Nontrivial R]\n  [inst_3 : DecidableEq R] [inst_4 : LT R] {s : Finset ι} {f : ι → WithTop R},\n  (∀ (i : ι), i ∈ s → f i ≠ ⊤) → (Finset.prod s fun i => f i) < ⊤ :=\n\n/-- A Dedekind domain is a PID if its set of primes is finite. -/\ntheorem ∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R],\n  Set.Finite {I | Ideal.IsPrime I} → IsPrincipalIdealRing R :=\n\n/-- The set of finite subsets of a countable set is countable. -/\ntheorem ∀ {α : Type u} {s : Set α}, Set.Countable s → Set.Countable {t | Set.Finite t ∧ t ⊆ s} :=\n\n/-- Every finite convergent corresponds to a rational number. -/\ntheorem ∀ {K : Type u_1} [inst : LinearOrderedField K] [inst_1 : FloorRing K] (v : K) (n : ℕ),\n  ∃ q, GeneralizedContinuedFraction.convergents (GeneralizedContinuedFraction.of v) n = ↑q :=\n\n/-- The partition is supremum-independent -/\ntheorem ∀ {α : Type u_1} [inst : Lattice α] [inst_1 : OrderBot α] {a : α} (self : Finpartition a), Finset.SupIndep self.parts id :=\n\n/-- Factoring a prime gives the corresponding one-element multiset. -/\ntheorem ∀ (p : Nat.Primes), PNat.factorMultiset ↑p = PrimeMultiset.ofPrime p :=\n\n/-- The number of partitions of a finite set is a prime number. -/\ntheorem", "choices": ["∀ {α : Type u} [inst : Fintype α] [inst_1 : DecidableEq α], Nat.Prime (PartitionsCard α) ", "∀ {α : Type u} [inst : Fintype α], Nat.Prime (Fintype.card (Finpartition α)) ", "∀ {α : Type u} [inst : Fintype α], Nat.Prime (Finset.card (Finset.powerset (Fintype.elems α))) ", "∀ {α : Type u} [inst : Fintype α], Nat.Prime (partition.number (Set.univ : Set α)) ", "∀ {α : Type u} [inst : Fintype α], Nat.Prime (Finset.card (Finpartition.all (Set.univ : Set α))) ", "∀ {α : Type u} [inst : Fintype α], IsPrime (Finset.card (Finpartition α)) ", "∀ {α : Type u} [inst : Fintype α], IsPrime (Finset.card (Finset.powerset (Fintype.elems α))) ", "∀ {α : Type u} [inst : Fintype α], Nat.Prime (Finset.card (Finset.partitions (Finset.univ : Finset α))) ", "∀ {α : Type u} [inst : Fintype α], Nat.Prime (Finset.card (Finset.partitions (Finset.univ : Finset α))) ", "∀ {α : Type u} [inst : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)], Finset.card (Finset.powerset (Fintype.elems α)) = p → IsPrime p "]}
{"docString": "If a poset has a maximal element, then it has a unique minimal element.", "prompts": "[{\"theorem\":\n  \"∀ {α : Type u} {L : List (α × Bool)} [inst : DecidableEq α], FreeGroup.mk (FreeGroup.reduce L) = FreeGroup.mk L\",\n  \"isProp\": true,\n  \"docString\":\n  \"A word and its maximal reduction correspond to the same element of the free group. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [self : CompleteSemilatticeSup α] (s : Set α) (a : α), a ∈ s → a ≤ sSup s\",\n  \"isProp\": true,\n  \"docString\": \"Any element of a set is less than the set supremum. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : ConditionallyCompleteLattice α] {s : Set α} {a : α}, IsGreatest s a → sSup s = a\",\n  \"isProp\": true,\n  \"docString\": \"A greatest element of a set is the supremum of this set. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : ConditionallyCompleteLattice α] {s : Set α} {a : α}, IsLeast s a → sInf s = a\",\n  \"isProp\": true,\n  \"docString\": \"A least element of a set is the infimum of this set. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {r : α → α → Prop},\\n  (∀ (c : Set α), IsChain r c → ∃ ub, ∀ (a : α), a ∈ c → r a ub) →\\n    (∀ {a b c : α}, r a b → r b c → r a c) → ∃ m, ∀ (a : α), r m a → r a m\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Zorn's lemma**\\n\\nIf every chain has an upper bound, then there exists a maximal element. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {L₁ L₂ : List (α × Bool)} [inst : DecidableEq α],\\n  FreeAddGroup.Red L₁ L₂ → FreeAddGroup.reduce L₁ = FreeAddGroup.reduce L₂\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a word reduces to another word, then they have a common maximal reduction.\"},\n {\"theorem\":\n  \"∀ {R : Type u_2} {S : Type u_1} [inst : EuclideanDomain R] [inst_1 : CommRing S] [inst_2 : IsDomain S]\\n  [inst_3 : Algebra R S] (abv : AbsoluteValue R ℤ) (I : { x // x ∈ nonZeroDivisors (Ideal S) }),\\n  ∃ b, b ∈ ↑I ∧ b ≠ 0 ∧ ∀ (c : S), c ∈ ↑I → ↑abv (↑(Algebra.norm R) c) < ↑abv (↑(Algebra.norm R) b) → c = 0\",\n  \"isProp\": true,\n  \"docString\": \"A nonzero ideal has an element of minimal norm. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {L₁ L₂ : List (α × Bool)} [inst : DecidableEq α],\\n  FreeGroup.reduce L₁ = FreeGroup.reduce L₂ → FreeGroup.mk L₁ = FreeGroup.mk L₂\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two words have a common maximal reduction, then they correspond to the same element in the\\nfree group. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {L₁ L₂ : List (α × Bool)} [inst : DecidableEq α],\\n  FreeGroup.Red L₁ L₂ → FreeGroup.reduce L₁ = FreeGroup.reduce L₂\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a word reduces to another word, then they have a common maximal reduction. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {L₁ L₂ : List (α × Bool)} [inst : DecidableEq α],\\n  FreeGroup.mk L₁ = FreeGroup.mk L₂ → FreeGroup.reduce L₁ = FreeGroup.reduce L₂\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two words correspond to the same element in the free group, then they\\nhave a common maximal reduction. This is the proof that the function that sends\\nan element of the free group to its maximal reduction is well-defined. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : Semiring α] {I : Ideal α} [self : Ideal.IsPrime I] {x y : α}, x * y ∈ I → x ∈ I ∨ y ∈ I\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a product lies in the prime ideal, then at least one element lies in the prime ideal. \"},\n {\"theorem\":\n  \"∀ {M₀ : Type u_1} [inst : MulZeroOneClass M₀], 0 = 1 → ∀ (a : M₀), a = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a monoid with zero, if zero equals one, then zero is the only element. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [self : CompleteSemilatticeInf α] (s : Set α) (a : α), a ∈ s → sInf s ≤ a\",\n  \"isProp\": true,\n  \"docString\": \"Any element of a set is more than the set infimum. \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : Ring R],\\n  IsField R → ∀ (I : Ideal (Polynomial R)) [hI : Ideal.IsMaximal I] (x : R), ↑Polynomial.C x ∈ I → x = 0\",\n  \"isProp\": true,\n  \"docString\": \"The only constant in a maximal ideal over a field is `0`. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {L : List (α × Bool)} [inst : DecidableEq α], FreeAddGroup.mk (FreeAddGroup.reduce L) = FreeAddGroup.mk L\",\n  \"isProp\": true,\n  \"docString\":\n  \"A word and its maximal reduction correspond to the same element of the additive free\\ngroup.\"},\n {\"theorem\":\n  \"∀ {V : Type u} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj] [inst_2 : Nonempty V],\\n  ∃ v, SimpleGraph.maxDegree G = SimpleGraph.degree G v\",\n  \"isProp\": true,\n  \"docString\":\n  \"There exists a vertex of maximal degree. Note the assumption of being nonempty is necessary, as\\nthe lemma implies there exists a vertex. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {L₁ L₂ : List (α × Bool)} [inst : DecidableEq α],\\n  FreeAddGroup.mk L₁ = FreeAddGroup.mk L₂ → FreeAddGroup.reduce L₁ = FreeAddGroup.reduce L₂\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two words correspond to the same element in the additive free group, then they\\nhave a common maximal reduction. This is the proof that the function that sends an element of the\\nfree group to its maximal reduction is well-defined.\"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : InnerProductSpace 𝕜 E] [inst_3 : NormedAddCommGroup F] [inst_4 : InnerProductSpace 𝕜 F] {T : E →ₗ.[𝕜] F}\\n  {S : F →ₗ.[𝕜] E},\\n  Dense ↑T.domain → ∀ [inst_5 : CompleteSpace E], LinearPMap.IsFormalAdjoint T S → S ≤ LinearPMap.adjoint T\",\n  \"isProp\": true,\n  \"docString\":\n  \"The adjoint is maximal in the sense that it contains every formal adjoint. \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : CommRing R] (I : Ideal R), IsField (R ⧸ I) → Ideal.IsMaximal I\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the quotient by an ideal is a field, then the ideal is maximal. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : SemilatticeSup α] [inst_1 : OrderBot α] [inst_2 : WellFoundedLT α] (a : α),\\n  ∃ s, Finset.sup s id = a ∧ ∀ ⦃b : α⦄, b ∈ s → SupIrred b\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a well-founded lattice, any element is the supremum of finitely many sup-irreducible\\nelements. This is the order-theoretic analogue of prime factorisation. \"}]\n", "prompt_cons": "/-- A word and its maximal reduction correspond to the same element of the free group. -/\ntheorem ∀ {α : Type u} {L : List (α × Bool)} [inst : DecidableEq α], FreeGroup.mk (FreeGroup.reduce L) = FreeGroup.mk L :=\n\n/-- Any element of a set is less than the set supremum. -/\ntheorem ∀ {α : Type u_1} [self : CompleteSemilatticeSup α] (s : Set α) (a : α), a ∈ s → a ≤ sSup s :=\n\n/-- A greatest element of a set is the supremum of this set. -/\ntheorem ∀ {α : Type u_1} [inst : ConditionallyCompleteLattice α] {s : Set α} {a : α}, IsGreatest s a → sSup s = a :=\n\n/-- A least element of a set is the infimum of this set. -/\ntheorem ∀ {α : Type u_1} [inst : ConditionallyCompleteLattice α] {s : Set α} {a : α}, IsLeast s a → sInf s = a :=\n\n/-- **Zorn's lemma**\n\nIf every chain has an upper bound, then there exists a maximal element. -/\ntheorem ∀ {α : Type u_1} {r : α → α → Prop},\n  (∀ (c : Set α), IsChain r c → ∃ ub, ∀ (a : α), a ∈ c → r a ub) →\n    (∀ {a b c : α}, r a b → r b c → r a c) → ∃ m, ∀ (a : α), r m a → r a m :=\n\n/-- If a word reduces to another word, then they have a common maximal reduction. -/\ntheorem ∀ {α : Type u} {L₁ L₂ : List (α × Bool)} [inst : DecidableEq α],\n  FreeAddGroup.Red L₁ L₂ → FreeAddGroup.reduce L₁ = FreeAddGroup.reduce L₂ :=\n\n/-- A nonzero ideal has an element of minimal norm. -/\ntheorem ∀ {R : Type u_2} {S : Type u_1} [inst : EuclideanDomain R] [inst_1 : CommRing S] [inst_2 : IsDomain S]\n  [inst_3 : Algebra R S] (abv : AbsoluteValue R ℤ) (I : { x // x ∈ nonZeroDivisors (Ideal S) }),\n  ∃ b, b ∈ ↑I ∧ b ≠ 0 ∧ ∀ (c : S), c ∈ ↑I → ↑abv (↑(Algebra.norm R) c) < ↑abv (↑(Algebra.norm R) b) → c = 0 :=\n\n/-- If two words have a common maximal reduction, then they correspond to the same element in the\nfree group. -/\ntheorem ∀ {α : Type u} {L₁ L₂ : List (α × Bool)} [inst : DecidableEq α],\n  FreeGroup.reduce L₁ = FreeGroup.reduce L₂ → FreeGroup.mk L₁ = FreeGroup.mk L₂ :=\n\n/-- If a word reduces to another word, then they have a common maximal reduction. -/\ntheorem ∀ {α : Type u} {L₁ L₂ : List (α × Bool)} [inst : DecidableEq α],\n  FreeGroup.Red L₁ L₂ → FreeGroup.reduce L₁ = FreeGroup.reduce L₂ :=\n\n/-- If two words correspond to the same element in the free group, then they\nhave a common maximal reduction. This is the proof that the function that sends\nan element of the free group to its maximal reduction is well-defined. -/\ntheorem ∀ {α : Type u} {L₁ L₂ : List (α × Bool)} [inst : DecidableEq α],\n  FreeGroup.mk L₁ = FreeGroup.mk L₂ → FreeGroup.reduce L₁ = FreeGroup.reduce L₂ :=\n\n/-- If a product lies in the prime ideal, then at least one element lies in the prime ideal. -/\ntheorem ∀ {α : Type u} [inst : Semiring α] {I : Ideal α} [self : Ideal.IsPrime I] {x y : α}, x * y ∈ I → x ∈ I ∨ y ∈ I :=\n\n/-- In a monoid with zero, if zero equals one, then zero is the only element. -/\ntheorem ∀ {M₀ : Type u_1} [inst : MulZeroOneClass M₀], 0 = 1 → ∀ (a : M₀), a = 0 :=\n\n/-- Any element of a set is more than the set infimum. -/\ntheorem ∀ {α : Type u_1} [self : CompleteSemilatticeInf α] (s : Set α) (a : α), a ∈ s → sInf s ≤ a :=\n\n/-- The only constant in a maximal ideal over a field is `0`. -/\ntheorem ∀ {R : Type u} [inst : Ring R],\n  IsField R → ∀ (I : Ideal (Polynomial R)) [hI : Ideal.IsMaximal I] (x : R), ↑Polynomial.C x ∈ I → x = 0 :=\n\n/-- A word and its maximal reduction correspond to the same element of the additive free\ngroup. -/\ntheorem ∀ {α : Type u} {L : List (α × Bool)} [inst : DecidableEq α], FreeAddGroup.mk (FreeAddGroup.reduce L) = FreeAddGroup.mk L :=\n\n/-- There exists a vertex of maximal degree. Note the assumption of being nonempty is necessary, as\nthe lemma implies there exists a vertex. -/\ntheorem ∀ {V : Type u} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj] [inst_2 : Nonempty V],\n  ∃ v, SimpleGraph.maxDegree G = SimpleGraph.degree G v :=\n\n/-- If two words correspond to the same element in the additive free group, then they\nhave a common maximal reduction. This is the proof that the function that sends an element of the\nfree group to its maximal reduction is well-defined. -/\ntheorem ∀ {α : Type u} {L₁ L₂ : List (α × Bool)} [inst : DecidableEq α],\n  FreeAddGroup.mk L₁ = FreeAddGroup.mk L₂ → FreeAddGroup.reduce L₁ = FreeAddGroup.reduce L₂ :=\n\n/-- The adjoint is maximal in the sense that it contains every formal adjoint. -/\ntheorem ∀ {𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E]\n  [inst_2 : InnerProductSpace 𝕜 E] [inst_3 : NormedAddCommGroup F] [inst_4 : InnerProductSpace 𝕜 F] {T : E →ₗ.[𝕜] F}\n  {S : F →ₗ.[𝕜] E},\n  Dense ↑T.domain → ∀ [inst_5 : CompleteSpace E], LinearPMap.IsFormalAdjoint T S → S ≤ LinearPMap.adjoint T :=\n\n/-- If the quotient by an ideal is a field, then the ideal is maximal. -/\ntheorem ∀ {R : Type u} [inst : CommRing R] (I : Ideal R), IsField (R ⧸ I) → Ideal.IsMaximal I :=\n\n/-- In a well-founded lattice, any element is the supremum of finitely many sup-irreducible\nelements. This is the order-theoretic analogue of prime factorisation. -/\ntheorem ∀ {α : Type u_1} [inst : SemilatticeSup α] [inst_1 : OrderBot α] [inst_2 : WellFoundedLT α] (a : α),\n  ∃ s, Finset.sup s id = a ∧ ∀ ⦃b : α⦄, b ∈ s → SupIrred b :=\n\n/-- If a poset has a maximal element, then it has a unique minimal element. -/\ntheorem", "choices": ["∀ {α : Type u_1} [inst : PartialOrder α] [inst_1 : Nonempty α] (H : ∃ x, ∀ y, y ≤ x),\n  ∃! x, ∀ y, x ≤ y ", "∀ {α : Type u_1} [inst : PartialOrder α] [inst_1 : BoundedOrder α],\n  ∃! m, ∀ (a : α), a ≤ m ", "∀ {α : Type u_1} [inst : PartialOrder α] [inst_1 : BoundedOrder α],\n  ∃! m : α, ∀ (a : α), a ≤ m ", "∀ {α : Type u_1} [inst : PartialOrder α] [inst_1 : OrderTop α] [inst_2 : OrderBot α], (∃ x, ∀ (y : α), x ≤ y) → UniqueBot α ", "∀ {α : Type u_1} [inst : PartialOrder α] (s : Set α) [inst_1 : Nonempty s], (∃ x, IsMaximal s x) → ∃! x, IsMinimal s x ", "∀ {α : Type u_1} [inst : PartialOrder α] [inst_1 : OrderTop α] [inst_2 : Nonempty α] [self : UniqueBot α],\n  ∃ x, ∀ y, y < x → y = ⊥ ", "∀ {α : Type u_1} [inst : PartialOrder α] (s : Set α),\n  (∃ a, IsMaximalElement s a) → ∃! a, IsMinimalElement s a ", "∀ {α : Type u_1} [inst : PartialOrder α] (s : Set α) (m : α),\n  IsMaximal m → (∃! b, IsMinimal b) ", "∀ {α : Type u_1} [inst : PartialOrder α] [inst_1 : BoundedOrder α], ∃! (a : α), IsMinimal a ", "∀ {α : Type u_1} [inst : PartialOrder α] [inst_1 : OrderBot α], (∃ a, ∀ b, a ≤ b) → ∃! a, ∀ b, b ≤ a "]}
{"docString": "The automorphism group of an Abelian group is cyclic.", "prompts": "[{\"theorem\":\n  \"∀ {α : Type u} [inst : AddGroup α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\\n  Fintype.card α = p → IsAddCyclic α\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic.\"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)], Fintype.card α = p → IsCyclic α\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic. \"},\n {\"theorem\":\n  \"∀ {R : Type u_2} {G : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : Group G] [inst_3 : Finite G]\\n  (f : G →* R), Function.Injective ↑f → IsCyclic G\",\n  \"isProp\": true,\n  \"docString\":\n  \"A finite subgroup of the unit group of an integral domain is cyclic. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] (S : Subgroup Rˣ) [inst_2 : Finite { x // x ∈ S }],\\n  IsCyclic { x // x ∈ S }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A finite subgroup of the units of an integral domain is cyclic. \"},\n {\"theorem\": \"∀ (H : AddSubgroup ℤ), ∃ a, H = AddSubgroup.closure {a}\",\n  \"isProp\": true,\n  \"docString\": \"Every subgroup of `ℤ` is cyclic. \"},\n {\"theorem\":\n  \"∀ {p : ℕ} {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] [inst_2 : Fact (Nat.Prime p)],\\n  Fintype.card G = p ^ 2 → IsCyclic (G ⧸ Subgroup.center G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The quotient by the center of a group of cardinality `p ^ 2` is cyclic. \"},\n {\"theorem\": \"∀ {G : Type u_1} [inst : CommGroup G], Group.IsNilpotent G\",\n  \"isProp\": true,\n  \"docString\": \"Abelian groups are nilpotent \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : AddGroup G], AddAction.IsPretransitive Gᵃᵒᵖ G\",\n  \"isProp\": true,\n  \"docString\":\n  \"The right regular action of an additive group on itself is transitive.\"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : Group α] [inst_1 : CommGroup β] {f g : α → β},\\n  IsGroupHom f → IsGroupHom g → IsGroupHom fun a => f a * g a\",\n  \"isProp\": true,\n  \"docString\":\n  \"The product of group homomorphisms is a group homomorphism if the target is commutative. \"},\n {\"theorem\":\n  \"∀ (G : Type u_1) [inst : CommGroup G], CommMonoid.torsion G = (CommGroup.torsion G).toSubmonoid\",\n  \"isProp\": true,\n  \"docString\":\n  \"The torsion submonoid of an abelian group equals the torsion subgroup as a submonoid. \"},\n {\"theorem\":\n  \"∀ (D : Type u_1) [inst : CategoryTheory.Category D] [inst_1 : CategoryTheory.Abelian D],\\n  CategoryTheory.IsIdempotentComplete D\",\n  \"isProp\": true,\n  \"docString\": \"An abelian category is idempotent complete. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G], SMulCommClass G { x // x ∈ Subgroup.center G } G\",\n  \"isProp\": true,\n  \"docString\": \"The center of a group acts commutatively on that group. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : AddGroup α] [inst_1 : AddAction α β] (x : β),\\n  AddAction.IsPretransitive α ↑(AddAction.orbit α x)\",\n  \"isProp\": true,\n  \"docString\": \"The action of an additive group on an orbit is transitive.\"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : Group α] [inst_1 : Group β] {f : α → β}, IsGroupHom f → IsMonoidHom f\",\n  \"isProp\": true,\n  \"docString\": \"A group homomorphism is a monoid homomorphism. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : CommGroup G], Group.nilpotencyClass G ≤ 1\",\n  \"isProp\": true,\n  \"docString\": \"Abelian groups have nilpotency class at most one \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : CommGroup G] [inst_1 : TopologicalSpace G] [inst_2 : TopologicalGroup G] [inst_3 : T2Space G]\\n  [inst_4 : MeasurableSpace G] [inst_5 : BorelSpace G] [inst_6 : TopologicalSpace.SecondCountableTopology G]\\n  (μ : MeasureTheory.Measure G) [inst_7 : MeasureTheory.Measure.IsHaarMeasure μ] [inst_8 : LocallyCompactSpace G],\\n  MeasureTheory.Measure.IsInvInvariant μ\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any Haar measure is invariant under inversion in an abelian group. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"Finite groups are torsion groups. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [self : LinearOrderedCommGroupWithZero α] (a : α), a ≠ 0 → a * a⁻¹ = 1\",\n  \"isProp\": true,\n  \"docString\": \"Every nonzero element of a group with zero is invertible. \"},\n {\"theorem\":\n  \"∀ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Abelian C],\\n  CategoryTheory.Limits.HasFiniteBiproducts C\",\n  \"isProp\": true,\n  \"docString\": \"An abelian category has finite biproducts. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : AddGroup G], AddMonoid.IsTorsion G → ∀ (H : AddSubgroup G), AddMonoid.IsTorsion { x // x ∈ H }\",\n  \"isProp\": true,\n  \"docString\":\n  \"Subgroups of additive torsion groups are additive torsion groups.\"}]\n", "prompt_cons": "/-- A finite group of prime order is cyclic. -/\ntheorem ∀ {α : Type u} [inst : AddGroup α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\n  Fintype.card α = p → IsAddCyclic α :=\n\n/-- A finite group of prime order is cyclic. -/\ntheorem ∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)], Fintype.card α = p → IsCyclic α :=\n\n/-- A finite subgroup of the unit group of an integral domain is cyclic. -/\ntheorem ∀ {R : Type u_2} {G : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : Group G] [inst_3 : Finite G]\n  (f : G →* R), Function.Injective ↑f → IsCyclic G :=\n\n/-- A finite subgroup of the units of an integral domain is cyclic. -/\ntheorem ∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] (S : Subgroup Rˣ) [inst_2 : Finite { x // x ∈ S }],\n  IsCyclic { x // x ∈ S } :=\n\n/-- Every subgroup of `ℤ` is cyclic. -/\ntheorem ∀ (H : AddSubgroup ℤ), ∃ a, H = AddSubgroup.closure {a} :=\n\n/-- The quotient by the center of a group of cardinality `p ^ 2` is cyclic. -/\ntheorem ∀ {p : ℕ} {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] [inst_2 : Fact (Nat.Prime p)],\n  Fintype.card G = p ^ 2 → IsCyclic (G ⧸ Subgroup.center G) :=\n\n/-- Abelian groups are nilpotent -/\ntheorem ∀ {G : Type u_1} [inst : CommGroup G], Group.IsNilpotent G :=\n\n/-- The right regular action of an additive group on itself is transitive. -/\ntheorem ∀ {G : Type u_1} [inst : AddGroup G], AddAction.IsPretransitive Gᵃᵒᵖ G :=\n\n/-- The product of group homomorphisms is a group homomorphism if the target is commutative. -/\ntheorem ∀ {α : Type u_1} {β : Type u_2} [inst : Group α] [inst_1 : CommGroup β] {f g : α → β},\n  IsGroupHom f → IsGroupHom g → IsGroupHom fun a => f a * g a :=\n\n/-- The torsion submonoid of an abelian group equals the torsion subgroup as a submonoid. -/\ntheorem ∀ (G : Type u_1) [inst : CommGroup G], CommMonoid.torsion G = (CommGroup.torsion G).toSubmonoid :=\n\n/-- An abelian category is idempotent complete. -/\ntheorem ∀ (D : Type u_1) [inst : CategoryTheory.Category D] [inst_1 : CategoryTheory.Abelian D],\n  CategoryTheory.IsIdempotentComplete D :=\n\n/-- The center of a group acts commutatively on that group. -/\ntheorem ∀ {G : Type u_1} [inst : Group G], SMulCommClass G { x // x ∈ Subgroup.center G } G :=\n\n/-- The action of an additive group on an orbit is transitive. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : AddGroup α] [inst_1 : AddAction α β] (x : β),\n  AddAction.IsPretransitive α ↑(AddAction.orbit α x) :=\n\n/-- A group homomorphism is a monoid homomorphism. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : Group α] [inst_1 : Group β] {f : α → β}, IsGroupHom f → IsMonoidHom f :=\n\n/-- Abelian groups have nilpotency class at most one -/\ntheorem ∀ {G : Type u_1} [inst : CommGroup G], Group.nilpotencyClass G ≤ 1 :=\n\n/-- Any Haar measure is invariant under inversion in an abelian group. -/\ntheorem ∀ {G : Type u_1} [inst : CommGroup G] [inst_1 : TopologicalSpace G] [inst_2 : TopologicalGroup G] [inst_3 : T2Space G]\n  [inst_4 : MeasurableSpace G] [inst_5 : BorelSpace G] [inst_6 : TopologicalSpace.SecondCountableTopology G]\n  (μ : MeasureTheory.Measure G) [inst_7 : MeasureTheory.Measure.IsHaarMeasure μ] [inst_8 : LocallyCompactSpace G],\n  MeasureTheory.Measure.IsInvInvariant μ :=\n\n/-- Finite groups are torsion groups. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G :=\n\n/-- Every nonzero element of a group with zero is invertible. -/\ntheorem ∀ {α : Type u_1} [self : LinearOrderedCommGroupWithZero α] (a : α), a ≠ 0 → a * a⁻¹ = 1 :=\n\n/-- An abelian category has finite biproducts. -/\ntheorem ∀ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Abelian C],\n  CategoryTheory.Limits.HasFiniteBiproducts C :=\n\n/-- Subgroups of additive torsion groups are additive torsion groups. -/\ntheorem ∀ {G : Type u_1} [inst : AddGroup G], AddMonoid.IsTorsion G → ∀ (H : AddSubgroup G), AddMonoid.IsTorsion { x // x ∈ H } :=\n\n/-- The automorphism group of an Abelian group is cyclic. -/\ntheorem", "choices": ["∀ {G : Type u_1} [inst : AddCommGroup G], IsAddCyclic (AddEquiv G G) ", "∀ {G : Type u_1} [inst : AddCommGroup G], IsAddCyclic (AddAut G) ", "∀ {G : Type u_1} [inst : AddCommGroup G], IsAddCyclic (AddEquiv G G) ", "∀ {G : Type u_1} [inst : AddCommGroup G], IsAddCyclic (AddAut G) ", "∀ {G : Type u_1} [inst : AddCommGroup G], IsAddCyclic (AddAut G) ", "∀ {G : Type u_1} [inst : AddCommGroup G], IsAddCyclic (AddEquiv.addMonoidEnd G) ", "∀ {G : Type u_1} [inst : CommGroup G], IsCyclic (Aut G) ", "∀ {α : Type u} [inst : AddCommGroup α], IsCyclic (AddEquiv.aut α) ", "∀ {G : Type u_1} [inst : AddCommGroup G], IsAddCyclic (AddEquiv.aut G) ", "∀ {G : Type u_1} [inst : AddCommGroup G], IsAddCyclic (AddEquiv G G) "]}
{"docString": "If a function from the unit interval to itself has a fixed point, then it has points of all positive periods.", "prompts": "[{\"theorem\":\n  \"∀ {α : Type u_1} {f : α → α} {x : α}, Function.IsFixedPt f x → ∀ (n : ℕ), Function.IsPeriodicPt f n x\",\n  \"isProp\": true,\n  \"docString\":\n  \"A fixed point of `f` is a periodic point of `f` of any prescribed period. \"},\n {\"theorem\":\n  \"∀ {f : Ordinal.{u} → Ordinal.{u}}, Ordinal.IsNormal f → Set.Unbounded (fun x x_1 => x < x_1) (Function.fixedPoints f)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The fixed point lemma for normal functions: any normal function has an unbounded set of\\nfixed points. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} (f : α → α) (x : α), Function.IsPeriodicPt f 0 x\",\n  \"isProp\": true,\n  \"docString\": \"Any point is a periodic point of period `0`. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : T2Space α] {f : α → α},\\n  Continuous f → IsClosed (Function.fixedPoints f)\",\n  \"isProp\": true,\n  \"docString\": \"The set of fixed points of a continuous map is a closed set. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {f : ℝ → α} {c : ℝ},\\n  Function.Periodic f c → c ≠ 0 → Continuous f → IsCompact (Set.range f)\",\n  \"isProp\": true,\n  \"docString\": \"A continuous, periodic function has compact range. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {β : Type u_2} {f : α → β} {c : α} [inst : LinearOrderedAddCommGroup α] [inst_1 : Archimedean α],\\n  Function.Periodic f c → 0 < c → ∀ (x : α), ∃ y, y ∈ Set.Ico 0 c ∧ f x = f y\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function `f` is `periodic` with positive period `c`, then for all `x` there exists some\\n`y ∈ Ico 0 c` such that `f x = f y`. \"},\n {\"theorem\":\n  \"∀ {α : Type u_2} {β : Type u_1} {ι : Type u_3} {m : MeasurableSpace α} (μ : MeasureTheory.Measure α)\\n  [inst : NormedAddCommGroup β] {p : ENNReal} {g : α → β},\\n  1 ≤ p → p ≠ ⊤ → MeasureTheory.Memℒp g p → MeasureTheory.UnifIntegrable (fun x => g) p μ\",\n  \"isProp\": true,\n  \"docString\": \"A constant function is uniformly integrable. \"},\n {\"theorem\": \"∀ {α : Type u_1} (n : ℕ) (x : α), Function.IsPeriodicPt id n x\",\n  \"isProp\": true,\n  \"docString\": \"For the identity map, all points are periodic. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : PseudoMetricSpace α] {f : ℝ → α} {c : ℝ},\\n  Function.Periodic f c → c ≠ 0 → Continuous f → Metric.Bounded (Set.range f)\",\n  \"isProp\": true,\n  \"docString\": \"A continuous, periodic function is bounded. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {β : Type u_2} {f : α → β} {c : α} [inst : LinearOrderedAddCommGroup α] [inst_1 : Archimedean α],\\n  Function.Periodic f c → 0 < c → ∀ (x a : α), ∃ y, y ∈ Set.Ico a (a + c) ∧ f x = f y\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function `f` is `periodic` with positive period `c`, then for all `x` there exists some\\n`y ∈ Ico a (a + c)` such that `f x = f y`. \"},\n {\"theorem\":\n  \"∀ {o : Ordinal.{u}} {f : (b : Ordinal.{u}) → b < o → Ordinal.{max u v} → Ordinal.{max u v}},\\n  (∀ (i : Ordinal.{u}) (hi : i < o), Ordinal.IsNormal (f i hi)) →\\n    Set.Unbounded (fun x x_1 => x < x_1) (⋂ (i : Ordinal.{u}) (hi : i < o), Function.fixedPoints (f i hi))\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalization of the fixed point lemma for normal functions: any family of normal functions\\nhas an unbounded set of common fixed points. \"},\n {\"theorem\":\n  \"∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] {f g : ℝ → E} {μ : MeasureTheory.Measure ℝ}\\n  {a b : ℝ}, Set.EqOn f g (Set.uIcc a b) → ∫ (x : ℝ) in a..b, f x ∂μ = ∫ (x : ℝ) in a..b, g x ∂μ\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two functions are equal in the relevant interval, their interval integrals are also equal. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {p : Filter ι}\\n  [inst_1 : TopologicalSpace α],\\n  TendstoUniformly F f p → (∀ᶠ (n : ι) in p, Continuous (F n)) → ∀ [inst_2 : Filter.NeBot p], Continuous f\",\n  \"isProp\": true,\n  \"docString\": \"A uniform limit of continuous functions is continuous. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {β : Type u_2} {f : α → β} {c : α} [inst : LinearOrderedAddCommGroup α] [inst_1 : Archimedean α],\\n  Function.Periodic f c → 0 < c → ∀ (x a : α), ∃ y, y ∈ Set.Ioc a (a + c) ∧ f x = f y\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function `f` is `periodic` with positive period `c`, then for all `x` there exists some\\n`y ∈ Ioc a (a + c)` such that `f x = f y`. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {m0 : MeasurableSpace α} (μ : MeasureTheory.Measure α) [inst : MeasureTheory.SigmaFinite μ]\\n  {ε : ENNReal}, ε ≠ 0 → ∃ g, (∀ (x : α), 0 < g x) ∧ Measurable g ∧ ∫⁻ (x : α), ↑(g x) ∂μ < ε\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a sigma-finite measure space, there exists an integrable function which is\\npositive everywhere (and with an arbitrarily small integral). \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {s : Set α} {p : Filter ι}\\n  [inst_1 : TopologicalSpace α],\\n  TendstoUniformlyOn F f p s → (∀ᶠ (n : ι) in p, ContinuousOn (F n) s) → ∀ [inst_2 : Filter.NeBot p], ContinuousOn f s\",\n  \"isProp\": true,\n  \"docString\":\n  \"A uniform limit on a set of functions which are continuous on this set is itself continuous\\non this set. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderClosedTopology α]\\n  [inst_3 : TopologicalSpace β] [inst_4 : Nonempty α] {f : β → α} {K : Set β},\\n  IsCompact K → ContinuousOn f K → BddAbove (f '' K)\",\n  \"isProp\": true,\n  \"docString\": \"A continuous function is bounded above on a compact set. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {f : α → α} {x y : α} {m n : ℕ},\\n  Function.IsPeriodicPt f m x → Function.IsPeriodicPt f n y → 0 < m → 0 < n → f x = f y → x = y\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` sends two periodic points `x` and `y` of positive periods to the same point,\\nthen `x = y`. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : PseudoMetricSpace α] [inst_1 : PseudoMetricSpace β] {f : α → β} {x : α} {r : ℝ},\\n  0 < r → ∀ (K : ℝ), (∀ (y : α), dist y x < r → dist (f y) (f x) ≤ K * dist y x) → ContinuousAt f x\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function is locally Lipschitz around a point, then it is continuous at this point. \"},\n {\"theorem\":\n  \"∀ {G₀ : Type u_1} [inst : TopologicalSpace G₀] [inst_1 : GroupWithZero G₀] [inst_2 : ContinuousMul G₀],\\n  Filter.Tendsto Inv.inv (nhds 1) (nhds 1) → HasContinuousInv₀ G₀\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a group with zero has continuous multiplication and `fun x ↦ x⁻¹` is continuous at one,\\nthen it is continuous at any unit. \"}]\n", "prompt_cons": "/-- A fixed point of `f` is a periodic point of `f` of any prescribed period. -/\ntheorem ∀ {α : Type u_1} {f : α → α} {x : α}, Function.IsFixedPt f x → ∀ (n : ℕ), Function.IsPeriodicPt f n x :=\n\n/-- The fixed point lemma for normal functions: any normal function has an unbounded set of\nfixed points. -/\ntheorem ∀ {f : Ordinal.{u} → Ordinal.{u}}, Ordinal.IsNormal f → Set.Unbounded (fun x x_1 => x < x_1) (Function.fixedPoints f) :=\n\n/-- Any point is a periodic point of period `0`. -/\ntheorem ∀ {α : Type u_1} (f : α → α) (x : α), Function.IsPeriodicPt f 0 x :=\n\n/-- The set of fixed points of a continuous map is a closed set. -/\ntheorem ∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : T2Space α] {f : α → α},\n  Continuous f → IsClosed (Function.fixedPoints f) :=\n\n/-- A continuous, periodic function has compact range. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] {f : ℝ → α} {c : ℝ},\n  Function.Periodic f c → c ≠ 0 → Continuous f → IsCompact (Set.range f) :=\n\n/-- If a function `f` is `periodic` with positive period `c`, then for all `x` there exists some\n`y ∈ Ico 0 c` such that `f x = f y`. -/\ntheorem ∀ {α : Type u_1} {β : Type u_2} {f : α → β} {c : α} [inst : LinearOrderedAddCommGroup α] [inst_1 : Archimedean α],\n  Function.Periodic f c → 0 < c → ∀ (x : α), ∃ y, y ∈ Set.Ico 0 c ∧ f x = f y :=\n\n/-- A constant function is uniformly integrable. -/\ntheorem ∀ {α : Type u_2} {β : Type u_1} {ι : Type u_3} {m : MeasurableSpace α} (μ : MeasureTheory.Measure α)\n  [inst : NormedAddCommGroup β] {p : ENNReal} {g : α → β},\n  1 ≤ p → p ≠ ⊤ → MeasureTheory.Memℒp g p → MeasureTheory.UnifIntegrable (fun x => g) p μ :=\n\n/-- For the identity map, all points are periodic. -/\ntheorem ∀ {α : Type u_1} (n : ℕ) (x : α), Function.IsPeriodicPt id n x :=\n\n/-- A continuous, periodic function is bounded. -/\ntheorem ∀ {α : Type u} [inst : PseudoMetricSpace α] {f : ℝ → α} {c : ℝ},\n  Function.Periodic f c → c ≠ 0 → Continuous f → Metric.Bounded (Set.range f) :=\n\n/-- If a function `f` is `periodic` with positive period `c`, then for all `x` there exists some\n`y ∈ Ico a (a + c)` such that `f x = f y`. -/\ntheorem ∀ {α : Type u_1} {β : Type u_2} {f : α → β} {c : α} [inst : LinearOrderedAddCommGroup α] [inst_1 : Archimedean α],\n  Function.Periodic f c → 0 < c → ∀ (x a : α), ∃ y, y ∈ Set.Ico a (a + c) ∧ f x = f y :=\n\n/-- A generalization of the fixed point lemma for normal functions: any family of normal functions\nhas an unbounded set of common fixed points. -/\ntheorem ∀ {o : Ordinal.{u}} {f : (b : Ordinal.{u}) → b < o → Ordinal.{max u v} → Ordinal.{max u v}},\n  (∀ (i : Ordinal.{u}) (hi : i < o), Ordinal.IsNormal (f i hi)) →\n    Set.Unbounded (fun x x_1 => x < x_1) (⋂ (i : Ordinal.{u}) (hi : i < o), Function.fixedPoints (f i hi)) :=\n\n/-- If two functions are equal in the relevant interval, their interval integrals are also equal. -/\ntheorem ∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] {f g : ℝ → E} {μ : MeasureTheory.Measure ℝ}\n  {a b : ℝ}, Set.EqOn f g (Set.uIcc a b) → ∫ (x : ℝ) in a..b, f x ∂μ = ∫ (x : ℝ) in a..b, g x ∂μ :=\n\n/-- A uniform limit of continuous functions is continuous. -/\ntheorem ∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {p : Filter ι}\n  [inst_1 : TopologicalSpace α],\n  TendstoUniformly F f p → (∀ᶠ (n : ι) in p, Continuous (F n)) → ∀ [inst_2 : Filter.NeBot p], Continuous f :=\n\n/-- If a function `f` is `periodic` with positive period `c`, then for all `x` there exists some\n`y ∈ Ioc a (a + c)` such that `f x = f y`. -/\ntheorem ∀ {α : Type u_1} {β : Type u_2} {f : α → β} {c : α} [inst : LinearOrderedAddCommGroup α] [inst_1 : Archimedean α],\n  Function.Periodic f c → 0 < c → ∀ (x a : α), ∃ y, y ∈ Set.Ioc a (a + c) ∧ f x = f y :=\n\n/-- In a sigma-finite measure space, there exists an integrable function which is\npositive everywhere (and with an arbitrarily small integral). -/\ntheorem ∀ {α : Type u_1} {m0 : MeasurableSpace α} (μ : MeasureTheory.Measure α) [inst : MeasureTheory.SigmaFinite μ]\n  {ε : ENNReal}, ε ≠ 0 → ∃ g, (∀ (x : α), 0 < g x) ∧ Measurable g ∧ ∫⁻ (x : α), ↑(g x) ∂μ < ε :=\n\n/-- A uniform limit on a set of functions which are continuous on this set is itself continuous\non this set. -/\ntheorem ∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {s : Set α} {p : Filter ι}\n  [inst_1 : TopologicalSpace α],\n  TendstoUniformlyOn F f p s → (∀ᶠ (n : ι) in p, ContinuousOn (F n) s) → ∀ [inst_2 : Filter.NeBot p], ContinuousOn f s :=\n\n/-- A continuous function is bounded above on a compact set. -/\ntheorem ∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderClosedTopology α]\n  [inst_3 : TopologicalSpace β] [inst_4 : Nonempty α] {f : β → α} {K : Set β},\n  IsCompact K → ContinuousOn f K → BddAbove (f '' K) :=\n\n/-- If `f` sends two periodic points `x` and `y` of positive periods to the same point,\nthen `x = y`. -/\ntheorem ∀ {α : Type u_1} {f : α → α} {x y : α} {m n : ℕ},\n  Function.IsPeriodicPt f m x → Function.IsPeriodicPt f n y → 0 < m → 0 < n → f x = f y → x = y :=\n\n/-- If a function is locally Lipschitz around a point, then it is continuous at this point. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : PseudoMetricSpace α] [inst_1 : PseudoMetricSpace β] {f : α → β} {x : α} {r : ℝ},\n  0 < r → ∀ (K : ℝ), (∀ (y : α), dist y x < r → dist (f y) (f x) ≤ K * dist y x) → ContinuousAt f x :=\n\n/-- If a group with zero has continuous multiplication and `fun x ↦ x⁻¹` is continuous at one,\nthen it is continuous at any unit. -/\ntheorem ∀ {G₀ : Type u_1} [inst : TopologicalSpace G₀] [inst_1 : GroupWithZero G₀] [inst_2 : ContinuousMul G₀],\n  Filter.Tendsto Inv.inv (nhds 1) (nhds 1) → HasContinuousInv₀ G₀ :=\n\n/-- If a function from the unit interval to itself has a fixed point, then it has points of all positive periods. -/\ntheorem", "choices": ["∀ {α : Type u_1} {f : α → α} {x : α}, Function.IsFixedPt f x → ∀ (n : ℕ), Function.IsPeriodicPt f n x ", "∀ {α : Type u} {f : α → α} [inst : LinearOrder α] [inst_1 : UnitInterval α] {x : α},\n  Function.IsFixedPt f x → ∀ (n : ℕ), 0 < n → ∃ y, Function.IsPeriodicPt f n y ", "∀ {α : Type u_1} {f : α → α} {x : α} [inst : Nonempty α] [inst_1 : LinearOrder α] [inst_2 : BoundedOrder α] [inst_3 : TopologicalSpace α]\n  [inst_4 : OrderTopology α] [inst_5 : IsCompact (Set.Icc (BoundedOrder.bot : α) (BoundedOrder.top : α))],\n  ContinuousOn f (Set.Icc (BoundedOrder.bot : α) (BoundedOrder.top : α)) → Function.IsFixedPt f x → ∀ (n : ℕ), Function.IsPeriodicPt f n x ", "∀ {α : Type u_1} {f : α → α} {x : α}, Function.IsFixedPt f x → ∀ (n : ℕ), 0 < n → ∃ (y : α), Function.IsPeriodicPt f n y ", "∀ {α : Type u_1} {f : α → α} {a b : α} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderClosedTopology α]\n  (hab : a ≤ b) (hf : a ≤ f a ∧ f a ≤ b ∨ a ≤ f b ∧ f b ≤ b),\n  (∀ (n : ℕ), 0 < n → Function.IsPeriodicPt f n a ∨ Function.IsPeriodicPt f n b) ", "∀ {α : Type u_1} {f : α → α} {x : α} (h : Function.IsFixedPt f x) (n : ℕ),\n  0 < n → IsCompact (Set.Icc 0 1) → ContinuousOn f (Set.Icc 0 1) → Function.IsPeriodicPt f n x ", "∀ {α : Type u_1} {f : α → α} {x : α} {n : ℕ},\n  Function.IsFixedPt f x → 0 < n → ∃ y, Function.IsPeriodicPt f n y ", "∀ {α : Type u_1} {f : α → α} {x : α} (hf : ContinuousOn f (Set.Icc 0 1)) (hx : HasMem.Mem x (Set.Icc 0 1))\n  (h_fixed : f x = x), ∀ (n : ℕ) (hn : 0 < n), ∃ y, HasMem.Mem y (Set.Icc 0 1) ∧ Function.IsPeriodicPt f n y ", "∀ {α : Type u_1} {f : α → α} {x : α}, Function.IsFixedPt f x → ∀ (n : ℕ), Function.IsPeriodicPt f n x ", "∀ {α : Type u_1} {f : α → α} [inst : LinearOrderedField α] {x : α},\n  Function.IsFixedPt f x → 0 < x → x < 1 → ∀ (n : ℕ), ∃ y, Function.IsPeriodicPt f n y ∧ 0 < y ∧ y < 1 "]}
{"docString": "The complement of the union of two sets contains the union of their complements.", "prompts": "[{\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α} [self : IsClosed s], IsOpen sᶜ\",\n  \"isProp\": true,\n  \"docString\": \"The complement of a closed set is an open set. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] (s : Set α), frontier sᶜ = frontier s\",\n  \"isProp\": true,\n  \"docString\":\n  \"The complement of a set has the same frontier as the original set. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : PseudoMetricSpace α] {s t : Set α}, Metric.Bounded s → Metric.Bounded t → Metric.Bounded (s ∪ t)\",\n  \"isProp\": true,\n  \"docString\": \"The union of two bounded sets is bounded. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {E : Type u_2} {m0 : MeasurableSpace α} {p : ENNReal} {μ : MeasureTheory.Measure α}\\n  [inst : NormedAddCommGroup E] {s t : Set α} (hs : MeasurableSet s) (ht : MeasurableSet t) (hμs : ↑↑μ s ≠ ⊤)\\n  (hμt : ↑↑μ t ≠ ⊤),\\n  s ∩ t = ∅ →\\n    ∀ (c : E),\\n      MeasureTheory.indicatorConstLp p (_ : MeasurableSet (s ∪ t)) (_ : ↑↑μ (s ∪ t) ≠ ⊤) c =\\n        MeasureTheory.indicatorConstLp p hs hμs c + MeasureTheory.indicatorConstLp p ht hμt c\",\n  \"isProp\": true,\n  \"docString\":\n  \"The indicator of a disjoint union of two sets is the sum of the indicators of the sets. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : PseudoMetricSpace α] {s t : Set α}, Metric.Bounded (s ∪ t) ↔ Metric.Bounded s ∧ Metric.Bounded t\",\n  \"isProp\": true,\n  \"docString\":\n  \"The union of two sets is bounded iff each of the sets is bounded. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : CompactSpace α]\\n  [inst_3 : CompactSpace β], CompactSpace (α ⊕ β)\",\n  \"isProp\": true,\n  \"docString\": \"The disjoint union of two compact spaces is compact. \"},\n {\"theorem\":\n  \"∀ {α : Type u} (S T : Set α), Cardinal.mk ↑(S ∪ T) ≤ Cardinal.mk ↑S + Cardinal.mk ↑T\",\n  \"isProp\": true,\n  \"docString\":\n  \"The cardinality of a union is at most the sum of the cardinalities\\nof the two sets. \"},\n {\"theorem\":\n  \"∀ {α : Type ua} {β : Type ub} [inst : UniformSpace α] [inst_1 : UniformSpace β] {a : Set (α × α)},\\n  a ∈ uniformity α →\\n    ∀ {b : Set (β × β)},\\n      b ∈ uniformity β →\\n        (fun p => (Sum.inl p.fst, Sum.inl p.snd)) '' a ∪ (fun p => (Sum.inr p.fst, Sum.inr p.snd)) '' b ∈\\n          UniformSpace.Core.sum.uniformity\",\n  \"isProp\": true,\n  \"docString\":\n  \"The union of an entourage of the diagonal in each set of a disjoint union is again an entourage\\nof the diagonal. \"},\n {\"theorem\":\n  \"∀ (k : Type u_2) (V : Type u_3) {P : Type u_1} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [S : AddTorsor V P] (s t : Set P), affineSpan k (s ∪ t) = affineSpan k s ⊔ affineSpan k t\",\n  \"isProp\": true,\n  \"docString\": \"The span of a union of sets is the sup of their spans. \"},\n {\"theorem\":\n  \"∀ {γ : Type w} [inst : SemilatticeSup γ] {s t : Set γ}, BddAbove (s ∪ t) ↔ BddAbove s ∧ BddAbove t\",\n  \"isProp\": true,\n  \"docString\":\n  \"The union of two sets is bounded above if and only if each of the sets is. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {s t : Set α}, IsCompact s → IsClosed t → IsCompact (s ∩ t)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The intersection of a compact set and a closed set is a compact set. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T2Space α] {K U V : Set α},\\n  IsCompact K → IsOpen U → IsOpen V → K ⊆ U ∪ V → ∃ K₁ K₂, IsCompact K₁ ∧ IsCompact K₂ ∧ K₁ ⊆ U ∧ K₂ ⊆ V ∧ K = K₁ ∪ K₂\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a compact set is covered by two open sets, then we can cover it by two compact subsets. \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} [inst : TopologicalSpace X] (self : CompactExhaustion X),\\n  ⋃ (n : ℕ), CompactExhaustion.toFun self n = Set.univ\",\n  \"isProp\": true,\n  \"docString\":\n  \"The union of all sets in a compact exhaustion equals the entire space. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {Z a b : Set α},\\n  IsClopen Z → Z ⊆ a ∪ b → IsOpen a → IsOpen b → Disjoint a b → IsClopen (Z ∩ a)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The intersection of a disjoint covering by two open sets of a clopen set will be clopen. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} (f : α → Finset β), Set.Finite (Set.range f) → Set.Finite (⋃ (a : α), ↑(f a))\",\n  \"isProp\": true,\n  \"docString\": \"A finite union of finsets is finite. \"},\n {\"theorem\":\n  \"∀ {γ : Type w} [inst : SemilatticeInf γ] {s t : Set γ}, BddBelow (s ∪ t) ↔ BddBelow s ∧ BddBelow t\",\n  \"isProp\": true,\n  \"docString\":\n  \"The union of two sets is bounded above if and only if each of the sets is.\"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {s t : Set α}, IsCompact s → IsOpen t → IsCompact (s \\\\ t)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set difference of a compact set and an open set is a compact set. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} (self : Filter α) {x y : Set α}, x ∈ self.sets → y ∈ self.sets → x ∩ y ∈ self.sets\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two sets belong to a filter, then their intersection belongs to the filter as well. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {s t : Set α}, IsCompact t → IsClosed s → IsCompact (s ∩ t)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The intersection of a closed set and a compact set is a compact set. \"},\n {\"theorem\":\n  \"∀ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (S T : Set (ℙ K V)),\\n  Projectivization.Subspace.span (S ∪ T) = Projectivization.Subspace.span S ⊔ Projectivization.Subspace.span T\",\n  \"isProp\": true,\n  \"docString\":\n  \"The supremum of two subspaces is equal to the span of their union. \"}]\n", "prompt_cons": "/-- The complement of a closed set is an open set. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α} [self : IsClosed s], IsOpen sᶜ :=\n\n/-- The complement of a set has the same frontier as the original set. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] (s : Set α), frontier sᶜ = frontier s :=\n\n/-- The union of two bounded sets is bounded. -/\ntheorem ∀ {α : Type u} [inst : PseudoMetricSpace α] {s t : Set α}, Metric.Bounded s → Metric.Bounded t → Metric.Bounded (s ∪ t) :=\n\n/-- The indicator of a disjoint union of two sets is the sum of the indicators of the sets. -/\ntheorem ∀ {α : Type u_1} {E : Type u_2} {m0 : MeasurableSpace α} {p : ENNReal} {μ : MeasureTheory.Measure α}\n  [inst : NormedAddCommGroup E] {s t : Set α} (hs : MeasurableSet s) (ht : MeasurableSet t) (hμs : ↑↑μ s ≠ ⊤)\n  (hμt : ↑↑μ t ≠ ⊤),\n  s ∩ t = ∅ →\n    ∀ (c : E),\n      MeasureTheory.indicatorConstLp p (_ : MeasurableSet (s ∪ t)) (_ : ↑↑μ (s ∪ t) ≠ ⊤) c =\n        MeasureTheory.indicatorConstLp p hs hμs c + MeasureTheory.indicatorConstLp p ht hμt c :=\n\n/-- The union of two sets is bounded iff each of the sets is bounded. -/\ntheorem ∀ {α : Type u} [inst : PseudoMetricSpace α] {s t : Set α}, Metric.Bounded (s ∪ t) ↔ Metric.Bounded s ∧ Metric.Bounded t :=\n\n/-- The disjoint union of two compact spaces is compact. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : CompactSpace α]\n  [inst_3 : CompactSpace β], CompactSpace (α ⊕ β) :=\n\n/-- The cardinality of a union is at most the sum of the cardinalities\nof the two sets. -/\ntheorem ∀ {α : Type u} (S T : Set α), Cardinal.mk ↑(S ∪ T) ≤ Cardinal.mk ↑S + Cardinal.mk ↑T :=\n\n/-- The union of an entourage of the diagonal in each set of a disjoint union is again an entourage\nof the diagonal. -/\ntheorem ∀ {α : Type ua} {β : Type ub} [inst : UniformSpace α] [inst_1 : UniformSpace β] {a : Set (α × α)},\n  a ∈ uniformity α →\n    ∀ {b : Set (β × β)},\n      b ∈ uniformity β →\n        (fun p => (Sum.inl p.fst, Sum.inl p.snd)) '' a ∪ (fun p => (Sum.inr p.fst, Sum.inr p.snd)) '' b ∈\n          UniformSpace.Core.sum.uniformity :=\n\n/-- The span of a union of sets is the sup of their spans. -/\ntheorem ∀ (k : Type u_2) (V : Type u_3) {P : Type u_1} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [S : AddTorsor V P] (s t : Set P), affineSpan k (s ∪ t) = affineSpan k s ⊔ affineSpan k t :=\n\n/-- The union of two sets is bounded above if and only if each of the sets is. -/\ntheorem ∀ {γ : Type w} [inst : SemilatticeSup γ] {s t : Set γ}, BddAbove (s ∪ t) ↔ BddAbove s ∧ BddAbove t :=\n\n/-- The intersection of a compact set and a closed set is a compact set. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] {s t : Set α}, IsCompact s → IsClosed t → IsCompact (s ∩ t) :=\n\n/-- If a compact set is covered by two open sets, then we can cover it by two compact subsets. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T2Space α] {K U V : Set α},\n  IsCompact K → IsOpen U → IsOpen V → K ⊆ U ∪ V → ∃ K₁ K₂, IsCompact K₁ ∧ IsCompact K₂ ∧ K₁ ⊆ U ∧ K₂ ⊆ V ∧ K = K₁ ∪ K₂ :=\n\n/-- The union of all sets in a compact exhaustion equals the entire space. -/\ntheorem ∀ {X : Type u_1} [inst : TopologicalSpace X] (self : CompactExhaustion X),\n  ⋃ (n : ℕ), CompactExhaustion.toFun self n = Set.univ :=\n\n/-- The intersection of a disjoint covering by two open sets of a clopen set will be clopen. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] {Z a b : Set α},\n  IsClopen Z → Z ⊆ a ∪ b → IsOpen a → IsOpen b → Disjoint a b → IsClopen (Z ∩ a) :=\n\n/-- A finite union of finsets is finite. -/\ntheorem ∀ {α : Type u} {β : Type v} (f : α → Finset β), Set.Finite (Set.range f) → Set.Finite (⋃ (a : α), ↑(f a)) :=\n\n/-- The union of two sets is bounded above if and only if each of the sets is. -/\ntheorem ∀ {γ : Type w} [inst : SemilatticeInf γ] {s t : Set γ}, BddBelow (s ∪ t) ↔ BddBelow s ∧ BddBelow t :=\n\n/-- The set difference of a compact set and an open set is a compact set. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] {s t : Set α}, IsCompact s → IsOpen t → IsCompact (s \\ t) :=\n\n/-- If two sets belong to a filter, then their intersection belongs to the filter as well. -/\ntheorem ∀ {α : Type u_1} (self : Filter α) {x y : Set α}, x ∈ self.sets → y ∈ self.sets → x ∩ y ∈ self.sets :=\n\n/-- The intersection of a closed set and a compact set is a compact set. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] {s t : Set α}, IsCompact t → IsClosed s → IsCompact (s ∩ t) :=\n\n/-- The supremum of two subspaces is equal to the span of their union. -/\ntheorem ∀ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (S T : Set (ℙ K V)),\n  Projectivization.Subspace.span (S ∪ T) = Projectivization.Subspace.span S ⊔ Projectivization.Subspace.span T :=\n\n/-- The complement of the union of two sets contains the union of their complements. -/\ntheorem", "choices": ["∀ {α : Type u} (A B : Set α), (A ∪ B)ᶜ ⊆ Aᶜ ∩ Bᶜ ", "∀ {α : Type u} (A B : Set α), (A ∪ B)ᶜ ⊆ Aᶜ ∩ Bᶜ ", "∀ {α : Type u} (s t : Set α), sᶜ ∩ tᶜ ⊆ (s ∪ t)ᶜ ", "∀ {α : Type u} (s t : Set α), (s ∪ t)ᶜ ⊆ sᶜ ∩ tᶜ ", "∀ {α : Type u} (s t : Set α), (s ∪ t)ᶜ ⊆ sᶜ ∩ tᶜ ", "∀ {α : Type u} (A B : Set α), (A ∪ B)ᶜ ⊆ Aᶜ ∪ Bᶜ ", "∀ {α : Type u} (A B : Set α), (A ∪ B)ᶜ ⊆ Aᶜ ∪ Bᶜ ", "∀ {α : Type u} (s t : Set α), sᶜ ∪ tᶜ ⊆ (s ∪ t)ᶜ ", "∀ {α : Type u} (s t : Set α), (s ∪ t)ᶜ ⊆ sᶜ ∩ tᶜ ", "∀ {α : Type u} (s t : Set α), (s ∪ t)ᶜ ⊆ sᶜ ∪ tᶜ "]}
{"docString": "The square root of an rational number is rational.", "prompts": "[{\"theorem\":\n  \"∀ {K : Type u_1} [inst : LinearOrderedField K] [inst_1 : FloorRing K] (v : K) (n : ℕ),\\n  ∃ q, GeneralizedContinuedFraction.convergents (GeneralizedContinuedFraction.of v) n = ↑q\",\n  \"isProp\": true,\n  \"docString\": \"Every finite convergent corresponds to a rational number. \"},\n {\"theorem\":\n  \"∀ {K : Type u_1} [inst : LinearOrderedField K] [inst_1 : FloorRing K] {v : K},\\n  GeneralizedContinuedFraction.Terminates (GeneralizedContinuedFraction.of v) → ∃ q, v = ↑q\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every terminating continued fraction corresponds to a rational number. \"},\n {\"theorem\":\n  \"∀ (q : ℚ), GeneralizedContinuedFraction.Terminates (GeneralizedContinuedFraction.of q)\",\n  \"isProp\": true,\n  \"docString\": \"The continued fraction of a rational number terminates. \"},\n {\"theorem\": \"∀ (ξ : ℚ), Set.Finite {q | |ξ - q| < 1 / ↑q.den ^ 2}\",\n  \"isProp\": true,\n  \"docString\":\n  \"A rational number has only finitely many good rational approximations. \"},\n {\"theorem\": \"∀ {r : ℝ}, Transcendental ℚ r → Irrational r\",\n  \"isProp\": true,\n  \"docString\": \"A transcendental real number is irrational. \"},\n {\"theorem\": \"∀ {a : ℕ}, ↑(Nat.sqrt a) ≤ Real.sqrt ↑a\",\n  \"isProp\": true,\n  \"docString\": \"The natural square root is at most the real square root \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} [inst : LinearOrderedField 𝕜] [inst_1 : TopologicalSpace 𝕜] [inst_2 : OrderTopology 𝕜]\\n  [inst_3 : Archimedean 𝕜], DenseRange Rat.cast\",\n  \"isProp\": true,\n  \"docString\":\n  \"Rational numbers are dense in a linear ordered archimedean field. \"},\n {\"theorem\": \"∀ {x y : ℝ}, x < y → ∃ r, Irrational r ∧ x < r ∧ r < y\",\n  \"isProp\": true,\n  \"docString\":\n  \"There is an irrational number `r` between any two reals `x < r < y`. \"},\n {\"theorem\": \"∀ {a : ℕ}, Real.sqrt ↑a ≤ ↑(Nat.sqrt a) + 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The real square root is at most the natural square root plus one \"},\n {\"theorem\":\n  \"∀ (K : Type u_1) [inst : Field K] [inst_1 : NumberField K] (A : Type u_2) [inst_2 : NormedField A]\\n  [inst_3 : IsAlgClosed A] [inst_4 : NormedAlgebra ℚ A] {x : K},\\n  IsIntegral ℤ x → (∀ (φ : K →+* A), ‖↑φ x‖ = 1) → ∃ n x_1, x ^ n = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"An algebraic integer whose conjugates are all of norm one is a root of unity. \"},\n {\"theorem\":\n  \"∀ {p x : ℝ} {r : ℚ}, LiouvilleWith p x → r ≠ 0 → LiouvilleWith p (x * ↑r)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The product of a Liouville number and a nonzero rational number is again a Liouville number.  \"},\n {\"theorem\":\n  \"∀ {K : Type u_1} [inst : Field K] [inst_1 : NeZero 2] {a b c : K},\\n  a ≠ 0 → (∃ s, discrim a b c = s * s) → ∃ x, a * x * x + b * x + c = 0\",\n  \"isProp\": true,\n  \"docString\": \"A quadratic has roots if its discriminant has square roots \"},\n {\"theorem\": \"Irrational (Real.sqrt 2)\",\n  \"isProp\": true,\n  \"docString\": \"**Irrationality of the Square Root of 2** \"},\n {\"theorem\":\n  \"∀ {R : Type u} {S : Type v} [inst : CommRing R] [inst_1 : CommRing S] {R' : Type u_1} {S' : Type u_2}\\n  [inst_2 : CommRing R'] [inst_3 : CommRing S'] {f : R →+* S} {f' : R' →+* S'} {g : R →+* R'} {g' : S →+* S'}\\n  (hfg : RingHom.comp f' g = RingHom.comp g' f) (I : Ideal S'),\\n  let leq := (_ : Ideal.comap f (Ideal.comap g' I) ≤ Ideal.comap g (Ideal.comap f' I));\\n  RingHom.comp (Ideal.quotientMap I g' (_ : Ideal.comap g' I ≤ Ideal.comap g' I))\\n      (Ideal.quotientMap (Ideal.comap g' I) f\\n        (_ : Ideal.comap f (Ideal.comap g' I) ≤ Ideal.comap f (Ideal.comap g' I))) =\\n    RingHom.comp (Ideal.quotientMap I f' (_ : Ideal.comap f' I ≤ Ideal.comap f' I))\\n      (Ideal.quotientMap (Ideal.comap f' I) g leq)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Commutativity of a square is preserved when taking quotients by an ideal. \"},\n {\"theorem\": \"∀ (self : ℚ), Nat.coprime (Int.natAbs self.num) self.den\",\n  \"isProp\": true,\n  \"docString\":\n  \"The numerator and denominator are coprime: it is in \\\"reduced form\\\". \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : CommSemiring R] {I : Ideal R}, Ideal.radical I = I ↔ Ideal.IsRadical I\",\n  \"isProp\": true,\n  \"docString\": \"An ideal is radical iff it is equal to its radical. \"},\n {\"theorem\": \"Irrational goldenConj\",\n  \"isProp\": true,\n  \"docString\": \"The conjugate of the golden ratio is irrational. \"},\n {\"theorem\":\n  \"∀ {n : ℕ} {α : Type u_1} [inst : LinearOrderedField α] [inst_1 : Archimedean α],\\n  n ≠ 0 → ∀ {x y : α}, x < y → 0 < y → ∃ q, 0 < q ∧ x < ↑q ^ n ∧ ↑q ^ n < y\",\n  \"isProp\": true,\n  \"docString\":\n  \"There is a rational power between any two positive elements of an archimedean ordered field. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : CommRing R] {a b c : R},\\n  (∀ (s : R), discrim a b c ≠ s ^ 2) → ∀ (x : R), a * x * x + b * x + c ≠ 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"A quadratic has no root if its discriminant has no square root. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : CommRing R] {a b c : R} [inst_1 : NeZero 2] [inst_2 : NoZeroDivisors R],\\n  a ≠ 0 → ∀ (x : R), a * x * x + b * x + c = 0 ↔ discrim a b c = (2 * a * x + b) ^ 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"A quadratic has roots if and only if its discriminant equals some square.\\n\"}]\n", "prompt_cons": "/-- Every finite convergent corresponds to a rational number. -/\ntheorem ∀ {K : Type u_1} [inst : LinearOrderedField K] [inst_1 : FloorRing K] (v : K) (n : ℕ),\n  ∃ q, GeneralizedContinuedFraction.convergents (GeneralizedContinuedFraction.of v) n = ↑q :=\n\n/-- Every terminating continued fraction corresponds to a rational number. -/\ntheorem ∀ {K : Type u_1} [inst : LinearOrderedField K] [inst_1 : FloorRing K] {v : K},\n  GeneralizedContinuedFraction.Terminates (GeneralizedContinuedFraction.of v) → ∃ q, v = ↑q :=\n\n/-- The continued fraction of a rational number terminates. -/\ntheorem ∀ (q : ℚ), GeneralizedContinuedFraction.Terminates (GeneralizedContinuedFraction.of q) :=\n\n/-- A rational number has only finitely many good rational approximations. -/\ntheorem ∀ (ξ : ℚ), Set.Finite {q | |ξ - q| < 1 / ↑q.den ^ 2} :=\n\n/-- A transcendental real number is irrational. -/\ntheorem ∀ {r : ℝ}, Transcendental ℚ r → Irrational r :=\n\n/-- The natural square root is at most the real square root -/\ntheorem ∀ {a : ℕ}, ↑(Nat.sqrt a) ≤ Real.sqrt ↑a :=\n\n/-- Rational numbers are dense in a linear ordered archimedean field. -/\ntheorem ∀ {𝕜 : Type u_1} [inst : LinearOrderedField 𝕜] [inst_1 : TopologicalSpace 𝕜] [inst_2 : OrderTopology 𝕜]\n  [inst_3 : Archimedean 𝕜], DenseRange Rat.cast :=\n\n/-- There is an irrational number `r` between any two reals `x < r < y`. -/\ntheorem ∀ {x y : ℝ}, x < y → ∃ r, Irrational r ∧ x < r ∧ r < y :=\n\n/-- The real square root is at most the natural square root plus one -/\ntheorem ∀ {a : ℕ}, Real.sqrt ↑a ≤ ↑(Nat.sqrt a) + 1 :=\n\n/-- An algebraic integer whose conjugates are all of norm one is a root of unity. -/\ntheorem ∀ (K : Type u_1) [inst : Field K] [inst_1 : NumberField K] (A : Type u_2) [inst_2 : NormedField A]\n  [inst_3 : IsAlgClosed A] [inst_4 : NormedAlgebra ℚ A] {x : K},\n  IsIntegral ℤ x → (∀ (φ : K →+* A), ‖↑φ x‖ = 1) → ∃ n x_1, x ^ n = 1 :=\n\n/-- The product of a Liouville number and a nonzero rational number is again a Liouville number. -/\ntheorem ∀ {p x : ℝ} {r : ℚ}, LiouvilleWith p x → r ≠ 0 → LiouvilleWith p (x * ↑r) :=\n\n/-- A quadratic has roots if its discriminant has square roots -/\ntheorem ∀ {K : Type u_1} [inst : Field K] [inst_1 : NeZero 2] {a b c : K},\n  a ≠ 0 → (∃ s, discrim a b c = s * s) → ∃ x, a * x * x + b * x + c = 0 :=\n\n/-- **Irrationality of the Square Root of 2** -/\ntheorem Irrational (Real.sqrt 2) :=\n\n/-- Commutativity of a square is preserved when taking quotients by an ideal. -/\ntheorem ∀ {R : Type u} {S : Type v} [inst : CommRing R] [inst_1 : CommRing S] {R' : Type u_1} {S' : Type u_2}\n  [inst_2 : CommRing R'] [inst_3 : CommRing S'] {f : R →+* S} {f' : R' →+* S'} {g : R →+* R'} {g' : S →+* S'}\n  (hfg : RingHom.comp f' g = RingHom.comp g' f) (I : Ideal S'),\n  let leq := (_ : Ideal.comap f (Ideal.comap g' I) ≤ Ideal.comap g (Ideal.comap f' I));\n  RingHom.comp (Ideal.quotientMap I g' (_ : Ideal.comap g' I ≤ Ideal.comap g' I))\n      (Ideal.quotientMap (Ideal.comap g' I) f\n        (_ : Ideal.comap f (Ideal.comap g' I) ≤ Ideal.comap f (Ideal.comap g' I))) =\n    RingHom.comp (Ideal.quotientMap I f' (_ : Ideal.comap f' I ≤ Ideal.comap f' I))\n      (Ideal.quotientMap (Ideal.comap f' I) g leq) :=\n\n/-- The numerator and denominator are coprime: it is in \"reduced form\". -/\ntheorem ∀ (self : ℚ), Nat.coprime (Int.natAbs self.num) self.den :=\n\n/-- An ideal is radical iff it is equal to its radical. -/\ntheorem ∀ {R : Type u} [inst : CommSemiring R] {I : Ideal R}, Ideal.radical I = I ↔ Ideal.IsRadical I :=\n\n/-- The conjugate of the golden ratio is irrational. -/\ntheorem Irrational goldenConj :=\n\n/-- There is a rational power between any two positive elements of an archimedean ordered field. -/\ntheorem ∀ {n : ℕ} {α : Type u_1} [inst : LinearOrderedField α] [inst_1 : Archimedean α],\n  n ≠ 0 → ∀ {x y : α}, x < y → 0 < y → ∃ q, 0 < q ∧ x < ↑q ^ n ∧ ↑q ^ n < y :=\n\n/-- A quadratic has no root if its discriminant has no square root. -/\ntheorem ∀ {R : Type u_1} [inst : CommRing R] {a b c : R},\n  (∀ (s : R), discrim a b c ≠ s ^ 2) → ∀ (x : R), a * x * x + b * x + c ≠ 0 :=\n\n/-- A quadratic has roots if and only if its discriminant equals some square. -/\ntheorem ∀ {R : Type u_1} [inst : CommRing R] {a b c : R} [inst_1 : NeZero 2] [inst_2 : NoZeroDivisors R],\n  a ≠ 0 → ∀ (x : R), a * x * x + b * x + c = 0 ↔ discrim a b c = (2 * a * x + b) ^ 2 :=\n\n/-- The square root of an rational number is rational. -/\ntheorem", "choices": ["∀ (q : ℚ), ∃ r, Real.sqrt ↑q = ↑r ", "∀ (q : ℚ), ∃ r, Real.sqrt ↑q = ↑r ", "∀ (q : ℚ), ∃ x, x * x = q ", "∀ (q : ℚ), ∃ r : ℚ, r * r = q ", "∀ (q : ℚ), ∃ r : ℚ, r * r = q ", "∀ (q : ℚ), ∃ r : ℚ, r * r = q ", "∀ (q : ℚ), ∃ r, Real.sqrt q = ↑r ", "∀ (q : ℚ), ∃ r, Real.sqrt q = r ", "∀ (q : ℚ), ∃ r : ℚ, r * r = q ", "∀ (q : ℚ), ∃ r, Real.sqrt ↑q = ↑r "]}
{"docString": "If a module over a ring is free, then the ring is commutative.", "prompts": "[{\"theorem\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\\n  IsNoetherian K V ↔ Module.Finite K V\",\n  \"isProp\": true,\n  \"docString\":\n  \"A module over a division ring is noetherian if and only if it is finitely generated. \"},\n {\"theorem\":\n  \"∀ {ι : Type u_1} (R : Type u) [inst : Semiring R] (M : ι → Type u_2) [inst_1 : Finite ι]\\n  [inst_2 : (i : ι) → AddCommMonoid (M i)] [inst_3 : (i : ι) → Module R (M i)]\\n  [inst_4 : ∀ (i : ι), Module.Free R (M i)], Module.Free R ((i : ι) → M i)\",\n  \"isProp\": true,\n  \"docString\": \"The product of finitely many free modules is free. \"},\n {\"theorem\":\n  \"∀ {K : Type u_1} {V : Type u} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\\n  IsAtomistic (Submodule K V)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The lattice of submodules of a module over a division ring is atomistic. \"},\n {\"theorem\":\n  \"∀ (R : Type u_1) (M : Type u_2) [inst : Subsingleton R] [inst : Semiring R] [inst_1 : AddCommMonoid M]\\n  [inst_2 : Module R M], IsNoetherian R M\",\n  \"isProp\": true,\n  \"docString\": \"Modules over the trivial ring are Noetherian. \"},\n {\"theorem\":\n  \"∀ (R : Type u_1) (M : Type u_2) [inst : AddCommMonoid M] [inst_1 : Ring R] [inst_2 : Finite R] [inst_3 : Module R M],\\n  AddMonoid.IsTorsion M\",\n  \"isProp\": true,\n  \"docString\":\n  \"A module with a finite ring of scalars is additively torsion. \"},\n {\"theorem\":\n  \"∀ {R : Type u} {M : Type v} {N : Type w} [inst : Ring R] [inst_1 : StrongRankCondition R] [inst_2 : AddCommGroup M]\\n  [inst_3 : Module R M] [inst_4 : Module.Free R M] [inst_5 : Module.Finite R M] [inst_6 : AddCommGroup N]\\n  [inst_7 : Module R N] [inst_8 : Module.Free R N] [inst_9 : Module.Finite R N],\\n  Nonempty (M ≃ₗ[R] N) ↔ FiniteDimensional.finrank R M = FiniteDimensional.finrank R N\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two finite and free modules are isomorphic if and only if they have the same (finite) rank. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} {M : Type u_2} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\\n  [self : Module.Finite R M], Submodule.FG ⊤\",\n  \"isProp\": true,\n  \"docString\":\n  \"A module over a semiring is `Finite` if it is finitely generated as a module. \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : Ring R], CategoryTheory.EnoughProjectives (ModuleCat R)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The category of modules has enough projectives, since every module is a quotient of a free\\nmodule. \"},\n {\"theorem\":\n  \"∀ {K : Type u_1} {V : Type u} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  (W : Submodule K V), IsAtom W ↔ ∃ v x, W = Submodule.span K {v}\",\n  \"isProp\": true,\n  \"docString\":\n  \"The atoms of the lattice of submodules of a module over a division ring are the\\nsubmodules equal to the span of a nonzero element of the module. \"},\n {\"theorem\":\n  \"∀ {R : Type u_2} {M : Type u_1} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M],\\n  Submodule.torsion R (M ⧸ Submodule.torsion R M) = ⊥\",\n  \"isProp\": true,\n  \"docString\":\n  \"Quotienting by the torsion submodule gives a torsion-free module. \"},\n {\"theorem\":\n  \"∀ (R : Type u_1) {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  [inst_3 : IsNoetherianRing R] {A : Set M}, Set.Finite A → IsNoetherian R { x // x ∈ Submodule.span R A }\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a module over a Noetherian ring, the submodule generated by finitely many vectors is\\nNoetherian. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  [inst_3 : IsNoetherian R M] (f : M →ₗ[R] M), Function.Surjective ↑f → Function.Injective ↑f\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any surjective endomorphism of a Noetherian module is injective. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} {M : Type u_2} {P : Type u_3} {N : Type w} [inst : Ring R] [inst_1 : AddCommGroup M]\\n  [inst_2 : Module R M] [inst_3 : AddCommGroup N] [inst_4 : Module R N] [inst_5 : AddCommGroup P] [inst_6 : Module R P]\\n  [inst_7 : IsNoetherian R M] [inst_8 : IsNoetherian R P] (f : M →ₗ[R] N) (g : N →ₗ[R] P),\\n  Function.Injective ↑f → Function.Surjective ↑g → LinearMap.range f = LinearMap.ker g → IsNoetherian R N\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the first and final modules in a short exact sequence are Noetherian,\\nthen the middle module is also Noetherian. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  [inst_3 : IsNoetherian R M] (f : M →ₗ[R] M), Function.Surjective ↑f → Function.Bijective ↑f\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any surjective endomorphism of a Noetherian module is bijective. \"},\n {\"theorem\":\n  \"∀ (R : Type u_2) [inst : Semiring R] (M : Type u_1) [inst_1 : AddCommMonoid M] [inst_2 : Module R M],\\n  Function.Surjective ↑(Finsupp.total M M R id)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any module is a quotient of a free module. This is stated as surjectivity of\\n`Finsupp.total M M R id : (M →₀ R) →ₗ[R] M`. \"},\n {\"theorem\":\n  \"∀ {K : Type u} {η : Type u₁'} {φ : η → Type u_1} [inst : Ring K] [inst_1 : StrongRankCondition K]\\n  [inst_2 : (i : η) → AddCommGroup (φ i)] [inst_3 : (i : η) → Module K (φ i)] [inst_4 : ∀ (i : η), Module.Free K (φ i)]\\n  [inst_5 : Finite η], Module.rank K ((i : η) → φ i) = Cardinal.sum fun i => Module.rank K (φ i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The rank of a finite product of free modules is the sum of the ranks. \"},\n {\"theorem\":\n  \"∀ (R : Type u) (M : Type v) [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\\n  [inst_3 : Module.Free R M] {m : Type u_1} {n : Type u_2} [inst_4 : Finite m] [inst_5 : Finite n],\\n  Module.Free R (Matrix m n M)\",\n  \"isProp\": true,\n  \"docString\": \"The module of finite matrices is free. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  [inst_3 : IsArtinian R M] (f : M →ₗ[R] M), Function.Injective ↑f → Function.Surjective ↑f\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any injective endomorphism of an Artinian module is surjective. \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : CommMonoid R] [inst_1 : StarSemigroup R], StarModule R R\",\n  \"isProp\": true,\n  \"docString\":\n  \"A commutative star monoid is a star module over itself via `Monoid.toMulAction`. \"},\n {\"theorem\":\n  \"∀ {M : Type u_1} [inst : Monoid M], SMulCommClass M { x // x ∈ Submonoid.center M } M\",\n  \"isProp\": true,\n  \"docString\": \"The center of a monoid acts commutatively on that monoid. \"}]\n", "prompt_cons": "/-- A module over a division ring is noetherian if and only if it is finitely generated. -/\ntheorem ∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  IsNoetherian K V ↔ Module.Finite K V :=\n\n/-- The product of finitely many free modules is free. -/\ntheorem ∀ {ι : Type u_1} (R : Type u) [inst : Semiring R] (M : ι → Type u_2) [inst_1 : Finite ι]\n  [inst_2 : (i : ι) → AddCommMonoid (M i)] [inst_3 : (i : ι) → Module R (M i)]\n  [inst_4 : ∀ (i : ι), Module.Free R (M i)], Module.Free R ((i : ι) → M i) :=\n\n/-- The lattice of submodules of a module over a division ring is atomistic. -/\ntheorem ∀ {K : Type u_1} {V : Type u} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  IsAtomistic (Submodule K V) :=\n\n/-- Modules over the trivial ring are Noetherian. -/\ntheorem ∀ (R : Type u_1) (M : Type u_2) [inst : Subsingleton R] [inst : Semiring R] [inst_1 : AddCommMonoid M]\n  [inst_2 : Module R M], IsNoetherian R M :=\n\n/-- A module with a finite ring of scalars is additively torsion. -/\ntheorem ∀ (R : Type u_1) (M : Type u_2) [inst : AddCommMonoid M] [inst_1 : Ring R] [inst_2 : Finite R] [inst_3 : Module R M],\n  AddMonoid.IsTorsion M :=\n\n/-- Two finite and free modules are isomorphic if and only if they have the same (finite) rank. -/\ntheorem ∀ {R : Type u} {M : Type v} {N : Type w} [inst : Ring R] [inst_1 : StrongRankCondition R] [inst_2 : AddCommGroup M]\n  [inst_3 : Module R M] [inst_4 : Module.Free R M] [inst_5 : Module.Finite R M] [inst_6 : AddCommGroup N]\n  [inst_7 : Module R N] [inst_8 : Module.Free R N] [inst_9 : Module.Finite R N],\n  Nonempty (M ≃ₗ[R] N) ↔ FiniteDimensional.finrank R M = FiniteDimensional.finrank R N :=\n\n/-- A module over a semiring is `Finite` if it is finitely generated as a module. -/\ntheorem ∀ {R : Type u_1} {M : Type u_2} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\n  [self : Module.Finite R M], Submodule.FG ⊤ :=\n\n/-- The category of modules has enough projectives, since every module is a quotient of a free\nmodule. -/\ntheorem ∀ {R : Type u} [inst : Ring R], CategoryTheory.EnoughProjectives (ModuleCat R) :=\n\n/-- The atoms of the lattice of submodules of a module over a division ring are the\nsubmodules equal to the span of a nonzero element of the module. -/\ntheorem ∀ {K : Type u_1} {V : Type u} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  (W : Submodule K V), IsAtom W ↔ ∃ v x, W = Submodule.span K {v} :=\n\n/-- Quotienting by the torsion submodule gives a torsion-free module. -/\ntheorem ∀ {R : Type u_2} {M : Type u_1} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M],\n  Submodule.torsion R (M ⧸ Submodule.torsion R M) = ⊥ :=\n\n/-- In a module over a Noetherian ring, the submodule generated by finitely many vectors is\nNoetherian. -/\ntheorem ∀ (R : Type u_1) {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  [inst_3 : IsNoetherianRing R] {A : Set M}, Set.Finite A → IsNoetherian R { x // x ∈ Submodule.span R A } :=\n\n/-- Any surjective endomorphism of a Noetherian module is injective. -/\ntheorem ∀ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  [inst_3 : IsNoetherian R M] (f : M →ₗ[R] M), Function.Surjective ↑f → Function.Injective ↑f :=\n\n/-- If the first and final modules in a short exact sequence are Noetherian,\nthen the middle module is also Noetherian. -/\ntheorem ∀ {R : Type u_1} {M : Type u_2} {P : Type u_3} {N : Type w} [inst : Ring R] [inst_1 : AddCommGroup M]\n  [inst_2 : Module R M] [inst_3 : AddCommGroup N] [inst_4 : Module R N] [inst_5 : AddCommGroup P] [inst_6 : Module R P]\n  [inst_7 : IsNoetherian R M] [inst_8 : IsNoetherian R P] (f : M →ₗ[R] N) (g : N →ₗ[R] P),\n  Function.Injective ↑f → Function.Surjective ↑g → LinearMap.range f = LinearMap.ker g → IsNoetherian R N :=\n\n/-- Any surjective endomorphism of a Noetherian module is bijective. -/\ntheorem ∀ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  [inst_3 : IsNoetherian R M] (f : M →ₗ[R] M), Function.Surjective ↑f → Function.Bijective ↑f :=\n\n/-- Any module is a quotient of a free module. This is stated as surjectivity of\n`Finsupp.total M M R id : (M →₀ R) →ₗ[R] M`. -/\ntheorem ∀ (R : Type u_2) [inst : Semiring R] (M : Type u_1) [inst_1 : AddCommMonoid M] [inst_2 : Module R M],\n  Function.Surjective ↑(Finsupp.total M M R id) :=\n\n/-- The rank of a finite product of free modules is the sum of the ranks. -/\ntheorem ∀ {K : Type u} {η : Type u₁'} {φ : η → Type u_1} [inst : Ring K] [inst_1 : StrongRankCondition K]\n  [inst_2 : (i : η) → AddCommGroup (φ i)] [inst_3 : (i : η) → Module K (φ i)] [inst_4 : ∀ (i : η), Module.Free K (φ i)]\n  [inst_5 : Finite η], Module.rank K ((i : η) → φ i) = Cardinal.sum fun i => Module.rank K (φ i) :=\n\n/-- The module of finite matrices is free. -/\ntheorem ∀ (R : Type u) (M : Type v) [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\n  [inst_3 : Module.Free R M] {m : Type u_1} {n : Type u_2} [inst_4 : Finite m] [inst_5 : Finite n],\n  Module.Free R (Matrix m n M) :=\n\n/-- Any injective endomorphism of an Artinian module is surjective. -/\ntheorem ∀ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  [inst_3 : IsArtinian R M] (f : M →ₗ[R] M), Function.Injective ↑f → Function.Surjective ↑f :=\n\n/-- A commutative star monoid is a star module over itself via `Monoid.toMulAction`. -/\ntheorem ∀ {R : Type u} [inst : CommMonoid R] [inst_1 : StarSemigroup R], StarModule R R :=\n\n/-- The center of a monoid acts commutatively on that monoid. -/\ntheorem ∀ {M : Type u_1} [inst : Monoid M], SMulCommClass M { x // x ∈ Submonoid.center M } M :=\n\n/-- If a module over a ring is free, then the ring is commutative. -/\ntheorem", "choices": ["∀ {R : Type u} {M : Type v} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M] [inst_3 : Module.Free R M],\n  IsCommutative R (*) ", "∀ {R : Type u} {M : Type v} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M] [inst_3 : Module.Free R M],\n  IsCommutative R (*) ", "∀ {R : Type u} {M : Type v} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M] [inst_3 : Module.Free R M],\n  IsCommutative R (*) ", "∀ {R : Type u} {M : Type v} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M] [inst_3 : Module.Free R M],\n  Commute.is_central_set (Set.Range (Basis.coord (_ : Basis M R M))) → IsCommutative R Mul ", "∀ {R : Type u} {M : Type v} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M] [inst_3 : Module.Free R M],\n  IsCommutative R (*) ", "forall {R : Type u} {M : Type v} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  [inst_3 : Module.Free R M] [inst_4 : Nontrivial M], IsCommutative R (*) ", "∀ {R : Type u} {M : Type v} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M] [inst_3 : Module.Free R M],\n  IsCommutative R (*) ", " ∀ {R : Type u} {M : Type v} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  [inst_3 : Module.Free R M], IsCommutative R (*) ", "∀ {R : Type u} {M : Type v} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M] [inst_3 : Module.Free R M],\n  IsCommutative R (*) ", "∀ {R : Type u} {M : Type v} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\n  [inst_3 : Module.Free R M], IsCommutative R (*) "]}
{"docString": "If the set of units of a ring forms a group then the ring is commutative.", "prompts": "[{\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G], SMulCommClass G { x // x ∈ Subgroup.center G } G\",\n  \"isProp\": true,\n  \"docString\": \"The center of a group acts commutatively on that group. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : Group α] [inst_1 : CommGroup β] {f g : α → β},\\n  IsGroupHom f → IsGroupHom g → IsGroupHom fun a => f a * g a\",\n  \"isProp\": true,\n  \"docString\":\n  \"The product of group homomorphisms is a group homomorphism if the target is commutative. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : NormedRing R] [inst_1 : CompleteSpace R], IsOpen {x | IsUnit x}\",\n  \"isProp\": true,\n  \"docString\":\n  \"The group of units of a complete normed ring is an open subset of the ring. \"},\n {\"theorem\":\n  \"∀ {M : Type u_1} [inst : Monoid M], SMulCommClass M { x // x ∈ Submonoid.center M } M\",\n  \"isProp\": true,\n  \"docString\": \"The center of a monoid acts commutatively on that monoid. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [self : StrictOrderedCommRing α] (a b : α), a * b = b * a\",\n  \"isProp\": true,\n  \"docString\": \"Multiplication is commutative in a commutative semigroup. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : Group α] [inst_1 : CommGroup β] {f : α → β},\\n  IsGroupHom f → IsGroupHom fun a => (f a)⁻¹\",\n  \"isProp\": true,\n  \"docString\":\n  \"The inverse of a group homomorphism is a group homomorphism if the target is commutative. \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : Semiring R], IsField R → ∀ (x y : R), x * y = y * x\",\n  \"isProp\": true,\n  \"docString\": \"Fields are commutative. \"},\n {\"theorem\":\n  \"∀ {α : Type u_2} {β : Type u_3} {γ : Type u_4} [inst : NonUnitalNonAssocSemiring α]\\n  [inst_1 : NonUnitalNonAssocSemiring β] [inst_2 : NonUnitalNonAssocSemiring γ] {δ : Type u_1}\\n  {x : NonUnitalNonAssocSemiring δ} (f : α →ₙ+* β) (g : β →ₙ+* γ) (h : γ →ₙ+* δ),\\n  NonUnitalRingHom.comp (NonUnitalRingHom.comp h g) f = NonUnitalRingHom.comp h (NonUnitalRingHom.comp g f)\",\n  \"isProp\": true,\n  \"docString\": \"Composition of non-unital ring homomorphisms is associative. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : Group α] [inst_1 : Group β] {f : α → β}, IsGroupHom f → IsMonoidHom f\",\n  \"isProp\": true,\n  \"docString\": \"A group homomorphism is a monoid homomorphism. \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : CommRing R],\\n  (∀ (P : Ideal R), Ideal.IsPrime P → Submodule.IsPrincipal P) → IsPrincipalIdealRing R\",\n  \"isProp\": true,\n  \"docString\":\n  \"If all prime ideals in a commutative ring are principal, so are all other ideals. \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : CommRing R], CompactSpace (PrimeSpectrum R)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The prime spectrum of a commutative ring is a compact topological space. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] (S : Subgroup Rˣ) [inst_2 : Finite { x // x ∈ S }],\\n  IsCyclic { x // x ∈ S }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A finite subgroup of the units of an integral domain is cyclic. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Monoid G] {x y : G}, Commute x y → IsOfFinOrder x → IsOfFinOrder y → IsOfFinOrder (x * y)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Commuting elements of finite order are closed under multiplication. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} {S : Type u_2} [inst : Mul R] [inst_1 : Mul S] [inst_2 : Add R] [inst_3 : Add S] (e : R ≃+* S)\\n  (x y : R), ↑e (x * y) = ↑e x * ↑e y\",\n  \"isProp\": true,\n  \"docString\": \"A ring isomorphism preserves multiplication. \"},\n {\"theorem\": \"∀ {S : Type u_1} [inst : Mul S] (a : S), Commute a a\",\n  \"isProp\": true,\n  \"docString\": \"Any element commutes with itself. \"},\n {\"theorem\":\n  \"∀ {R : Type u_2} {G : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : Group G] [inst_3 : Finite G]\\n  (f : G →* R), Function.Injective ↑f → IsCyclic G\",\n  \"isProp\": true,\n  \"docString\":\n  \"A finite subgroup of the unit group of an integral domain is cyclic. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [self : SeminormedCommRing α] (x y : α), x * y = y * x\",\n  \"isProp\": true,\n  \"docString\": \"Multiplication is commutative. \"},\n {\"theorem\": \"∀ {S : Type u_1} [inst : Add S] (a : S), AddCommute a a\",\n  \"isProp\": true,\n  \"docString\": \"Any element commutes with itself.\"},\n {\"theorem\":\n  \"∀ (R : Type u_1) [inst : CommRing R] [inst_1 : Nontrivial R], StrongRankCondition R\",\n  \"isProp\": true,\n  \"docString\": \"Any commutative ring satisfies the `StrongRankCondition`. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [self : OrderedCommGroup α] (a b : α), a ≤ b → ∀ (c : α), c * a ≤ c * b\",\n  \"isProp\": true,\n  \"docString\": \"Multiplication is monotone in an ordered commutative group. \"}]\n", "prompt_cons": "/-- The center of a group acts commutatively on that group. -/\ntheorem ∀ {G : Type u_1} [inst : Group G], SMulCommClass G { x // x ∈ Subgroup.center G } G :=\n\n/-- The product of group homomorphisms is a group homomorphism if the target is commutative. -/\ntheorem ∀ {α : Type u_1} {β : Type u_2} [inst : Group α] [inst_1 : CommGroup β] {f g : α → β},\n  IsGroupHom f → IsGroupHom g → IsGroupHom fun a => f a * g a :=\n\n/-- The group of units of a complete normed ring is an open subset of the ring. -/\ntheorem ∀ {R : Type u_1} [inst : NormedRing R] [inst_1 : CompleteSpace R], IsOpen {x | IsUnit x} :=\n\n/-- The center of a monoid acts commutatively on that monoid. -/\ntheorem ∀ {M : Type u_1} [inst : Monoid M], SMulCommClass M { x // x ∈ Submonoid.center M } M :=\n\n/-- Multiplication is commutative in a commutative semigroup. -/\ntheorem ∀ {α : Type u_1} [self : StrictOrderedCommRing α] (a b : α), a * b = b * a :=\n\n/-- The inverse of a group homomorphism is a group homomorphism if the target is commutative. -/\ntheorem ∀ {α : Type u_1} {β : Type u_2} [inst : Group α] [inst_1 : CommGroup β] {f : α → β},\n  IsGroupHom f → IsGroupHom fun a => (f a)⁻¹ :=\n\n/-- Fields are commutative. -/\ntheorem ∀ {R : Type u} [inst : Semiring R], IsField R → ∀ (x y : R), x * y = y * x :=\n\n/-- Composition of non-unital ring homomorphisms is associative. -/\ntheorem ∀ {α : Type u_2} {β : Type u_3} {γ : Type u_4} [inst : NonUnitalNonAssocSemiring α]\n  [inst_1 : NonUnitalNonAssocSemiring β] [inst_2 : NonUnitalNonAssocSemiring γ] {δ : Type u_1}\n  {x : NonUnitalNonAssocSemiring δ} (f : α →ₙ+* β) (g : β →ₙ+* γ) (h : γ →ₙ+* δ),\n  NonUnitalRingHom.comp (NonUnitalRingHom.comp h g) f = NonUnitalRingHom.comp h (NonUnitalRingHom.comp g f) :=\n\n/-- A group homomorphism is a monoid homomorphism. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : Group α] [inst_1 : Group β] {f : α → β}, IsGroupHom f → IsMonoidHom f :=\n\n/-- If all prime ideals in a commutative ring are principal, so are all other ideals. -/\ntheorem ∀ {R : Type u} [inst : CommRing R],\n  (∀ (P : Ideal R), Ideal.IsPrime P → Submodule.IsPrincipal P) → IsPrincipalIdealRing R :=\n\n/-- The prime spectrum of a commutative ring is a compact topological space. -/\ntheorem ∀ {R : Type u} [inst : CommRing R], CompactSpace (PrimeSpectrum R) :=\n\n/-- A finite subgroup of the units of an integral domain is cyclic. -/\ntheorem ∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] (S : Subgroup Rˣ) [inst_2 : Finite { x // x ∈ S }],\n  IsCyclic { x // x ∈ S } :=\n\n/-- Commuting elements of finite order are closed under multiplication. -/\ntheorem ∀ {G : Type u_1} [inst : Monoid G] {x y : G}, Commute x y → IsOfFinOrder x → IsOfFinOrder y → IsOfFinOrder (x * y) :=\n\n/-- A ring isomorphism preserves multiplication. -/\ntheorem ∀ {R : Type u_1} {S : Type u_2} [inst : Mul R] [inst_1 : Mul S] [inst_2 : Add R] [inst_3 : Add S] (e : R ≃+* S)\n  (x y : R), ↑e (x * y) = ↑e x * ↑e y :=\n\n/-- Any element commutes with itself. -/\ntheorem ∀ {S : Type u_1} [inst : Mul S] (a : S), Commute a a :=\n\n/-- A finite subgroup of the unit group of an integral domain is cyclic. -/\ntheorem ∀ {R : Type u_2} {G : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : Group G] [inst_3 : Finite G]\n  (f : G →* R), Function.Injective ↑f → IsCyclic G :=\n\n/-- Multiplication is commutative. -/\ntheorem ∀ {α : Type u_1} [self : SeminormedCommRing α] (x y : α), x * y = y * x :=\n\n/-- Any element commutes with itself. -/\ntheorem ∀ {S : Type u_1} [inst : Add S] (a : S), AddCommute a a :=\n\n/-- Any commutative ring satisfies the `StrongRankCondition`. -/\ntheorem ∀ (R : Type u_1) [inst : CommRing R] [inst_1 : Nontrivial R], StrongRankCondition R :=\n\n/-- Multiplication is monotone in an ordered commutative group. -/\ntheorem ∀ {α : Type u} [self : OrderedCommGroup α] (a b : α), a ≤ b → ∀ (c : α), c * a ≤ c * b :=\n\n/-- If the set of units of a ring forms a group then the ring is commutative. -/\ntheorem", "choices": ["∀ {R : Type u_1} [inst : Ring R], IsGroup (Units R) → ∀ (x y : R), x * y = y * x ", "∀ {R : Type u_1} [inst : Ring R] (s : Subgroup Rˣ),\n  (∃ (mul : Rˣ → Rˣ → Rˣ) (inv : Rˣ → Rˣ) (one : Rˣ) (div : Rˣ → Rˣ → Rˣ),\n    Group.mk mul inv one div = s) → ∀ (x y : R), x * y = y * x ", "∀ {R : Type u_1} [inst : Mul R] [inst_1 : Add R] [inst_2 : One R] [inst_3 : Zero R] [inst_4 : Neg R] [inst_5 : Inv R],\n  Group { x // IsUnit x } → ∀ (x y : R), x * y = y * x ", "∀ {R : Type u_1} [inst : Ring R] [inst_1 : IsGroup (Rˣ)], IsCommRing R ", "∀ {R : Type u_1} [inst : Ring R], (∀ a b : R, IsUnit a → IsUnit b → IsUnit (a * b)) → ∀ (x y : R), x * y = y * x ", "∀ {R : Type u_1} [inst : Ring R] (s : Set R) [inst_1 : IsGroup s] (h : ∀ (x : Units R), ↑x ∈ s),\n  (∀ (x y : R), x * y ∈ s → y * x ∈ s) → ∀ (x y : R), x * y = y * x ", "∀ {R : Type u_1} [inst : Ring R], IsGroup (IsUnit.unit R) → ∀ (x y : R), x * y = y * x ", "∀ {R : Type u_1} [inst : Ring R] [inst_1 : Group (Units R)], IsCommutative R ", "∀ {R : Type u_1} [inst : Ring R] [inst_1 : Group Rˣ], IsCommutative R (*) ", "∀ {R : Type u_1} [inst : Ring R], IsGroup (Rˣ) → ∀ (x y : R), x * y = y * x "]}
{"docString": "Every natural number larger than `10` is the sum of a square and a prime.", "prompts": "[{\"theorem\": \"Set.InjOn Nat.factorization {x | x ≠ 0}\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every nonzero natural number has a unique prime factorization \"},\n {\"theorem\":\n  \"∀ {a b x y u v : ℕ}, a = x ^ 2 + y ^ 2 → b = u ^ 2 + v ^ 2 → ∃ r s, a * b = r ^ 2 + s ^ 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of natural numbers that are sums of two squares is closed under multiplication. \"},\n {\"theorem\": \"∀ {n : ℕ}, 0 < n → ¬Nat.Prime n → Nat.minFac n ^ 2 ≤ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"The square of the smallest prime factor of a composite number `n` is at most `n`.\\n\"},\n {\"theorem\": \"∀ {n : ℕ}, IsSquare (-1) → ∃ x y, n = x ^ 2 + y ^ 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `-1` is a square modulo the natural number `n`, then `n` is a sum of two squares. \"},\n {\"theorem\": \"∀ {a : ℕ}, Real.sqrt ↑a ≤ ↑(Nat.sqrt a) + 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The real square root is at most the natural square root plus one \"},\n {\"theorem\": \"∀ (p : ℕ) [inst : Fact (Nat.Prime p)], Prime ↑p ↔ p % 4 = 3\",\n  \"isProp\": true,\n  \"docString\":\n  \"A prime natural number is prime in `ℤ[i]` if and only if it is `3` mod `4` \"},\n {\"theorem\":\n  \"∀ (R : Type u) [inst : Semiring R] (q : ℕ) [hq : ExpChar R q], Nat.Prime q ∨ q = 1\",\n  \"isProp\": true,\n  \"docString\": \"The exponential characteristic is a prime number or one. \"},\n {\"theorem\": \"∀ (n : ℕ), n ≠ 0 → ∃ p, Nat.Prime p ∧ n < p ∧ p ≤ 2 * n\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Bertrand's Postulate**: For any positive natural number, there is a prime which is greater than\\nit, but no more than twice as large.\\n\"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : CancelCommMonoidWithZero α] [dec_irr : (p : Associates α) → Decidable (Irreducible p)]\\n  [inst_1 : UniqueFactorizationMonoid α] [dec : DecidableEq α] [dec' : DecidableEq (Associates α)] {a p : Associates α},\\n  Irreducible p →\\n    ∀ [inst_2 : (n : ℕ) → Decidable (a ∣ p ^ n)] {n : ℕ} (h : a ∣ p ^ n),\\n      a = p ^ Nat.find (_ : ∃ n, (fun n => a ∣ p ^ n) n)\",\n  \"isProp\": true,\n  \"docString\": \"The only divisors of prime powers are prime powers. \"},\n {\"theorem\":\n  \"∀ {n : ℕ}, (∃ x y, n = x ^ 2 + y ^ 2) ↔ ∀ {q : ℕ}, Nat.Prime q → q % 4 = 3 → Even (padicValNat q n)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A (positive) natural number `n` is a sum of two squares if and only if the exponent of\\nevery prime `q` such that `q % 4 = 3` in the prime factorization of `n` is even.\\n(The assumption `0 < n` is not present, since for `n = 0`, both sides are satisfied;\\nthe right hand side holds, since `padicValNat q 0 = 0` by definition.) \"},\n {\"theorem\": \"∀ (n : ℕ), Nat.factorization n = 0 ↔ n = 0 ∨ n = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The only numbers with empty prime factorization are `0` and `1` \"},\n {\"theorem\": \"∀ {a : ℕ}, ↑(Nat.sqrt a) ≤ Real.sqrt ↑a\",\n  \"isProp\": true,\n  \"docString\": \"The natural square root is at most the real square root \"},\n {\"theorem\": \"∀ {m n : ℕ}, (∀ (a : ℕ), m ∣ a ↔ n ∣ a) ↔ m = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two natural numbers are equal if and only if they have the same multiples. \"},\n {\"theorem\": \"∀ {n : ℕ}, 1 < n → ¬Nat.Prime n → FermatPsp n 1\",\n  \"isProp\": true,\n  \"docString\": \"All composite numbers are Fermat pseudoprimes to base 1.\\n\"},\n {\"theorem\":\n  \"∀ {n : ℕ}, (∃ x y, n = x ^ 2 + y ^ 2) ↔ ∃ a b, n = a ^ 2 * b ∧ IsSquare (-1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A natural number `n` is a sum of two squares if and only if `n = a^2 * b` with natural\\nnumbers `a` and `b` such that `-1` is a square modulo `b`. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : LinearOrderedRing α] [inst_1 : Archimedean α] {x y : α},\\n  1 ≤ x → 1 < y → ∃ n, y ^ n ≤ x ∧ x < y ^ (n + 1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every x greater than or equal to 1 is between two successive\\nnatural-number powers of every y greater than one. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : StrictOrderedSemiring R] (l : List R), (∀ (a : R), a ∈ l → 0 < a) → 0 < List.prod l\",\n  \"isProp\": true,\n  \"docString\":\n  \"The product of a list of positive natural numbers is positive,\\nand likewise for any nontrivial ordered semiring. \"},\n {\"theorem\": \"∀ {m n : ℕ}, (∀ (a : ℕ), a ∣ m ↔ a ∣ n) ↔ m = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two natural numbers are equal if and only if they have the same divisors. \"},\n {\"theorem\": \"∀ {a b : ℕ}, a ∣ b → b < a → b = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a small natural number is divisible by a larger natural number,\\nthe small number is zero. \"},\n {\"theorem\":\n  \"∀ {n x y : ℕ}, n = x ^ 2 + y ^ 2 → Nat.coprime x y → IsSquare (-1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the natural number `n` is a sum of two squares of coprime natural numbers, then\\n`-1` is a square modulo `n`. \"}]\n", "prompt_cons": "/-- Every nonzero natural number has a unique prime factorization -/\ntheorem Set.InjOn Nat.factorization {x | x ≠ 0} :=\n\n/-- The set of natural numbers that are sums of two squares is closed under multiplication. -/\ntheorem ∀ {a b x y u v : ℕ}, a = x ^ 2 + y ^ 2 → b = u ^ 2 + v ^ 2 → ∃ r s, a * b = r ^ 2 + s ^ 2 :=\n\n/-- The square of the smallest prime factor of a composite number `n` is at most `n`. -/\ntheorem ∀ {n : ℕ}, 0 < n → ¬Nat.Prime n → Nat.minFac n ^ 2 ≤ n :=\n\n/-- If `-1` is a square modulo the natural number `n`, then `n` is a sum of two squares. -/\ntheorem ∀ {n : ℕ}, IsSquare (-1) → ∃ x y, n = x ^ 2 + y ^ 2 :=\n\n/-- The real square root is at most the natural square root plus one -/\ntheorem ∀ {a : ℕ}, Real.sqrt ↑a ≤ ↑(Nat.sqrt a) + 1 :=\n\n/-- A prime natural number is prime in `ℤ[i]` if and only if it is `3` mod `4` -/\ntheorem ∀ (p : ℕ) [inst : Fact (Nat.Prime p)], Prime ↑p ↔ p % 4 = 3 :=\n\n/-- The exponential characteristic is a prime number or one. -/\ntheorem ∀ (R : Type u) [inst : Semiring R] (q : ℕ) [hq : ExpChar R q], Nat.Prime q ∨ q = 1 :=\n\n/-- **Bertrand's Postulate**: For any positive natural number, there is a prime which is greater than\nit, but no more than twice as large. -/\ntheorem ∀ (n : ℕ), n ≠ 0 → ∃ p, Nat.Prime p ∧ n < p ∧ p ≤ 2 * n :=\n\n/-- The only divisors of prime powers are prime powers. -/\ntheorem ∀ {α : Type u_1} [inst : CancelCommMonoidWithZero α] [dec_irr : (p : Associates α) → Decidable (Irreducible p)]\n  [inst_1 : UniqueFactorizationMonoid α] [dec : DecidableEq α] [dec' : DecidableEq (Associates α)] {a p : Associates α},\n  Irreducible p →\n    ∀ [inst_2 : (n : ℕ) → Decidable (a ∣ p ^ n)] {n : ℕ} (h : a ∣ p ^ n),\n      a = p ^ Nat.find (_ : ∃ n, (fun n => a ∣ p ^ n) n) :=\n\n/-- A (positive) natural number `n` is a sum of two squares if and only if the exponent of\nevery prime `q` such that `q % 4 = 3` in the prime factorization of `n` is even.\n(The assumption `0 < n` is not present, since for `n = 0`, both sides are satisfied;\nthe right hand side holds, since `padicValNat q 0 = 0` by definition.) -/\ntheorem ∀ {n : ℕ}, (∃ x y, n = x ^ 2 + y ^ 2) ↔ ∀ {q : ℕ}, Nat.Prime q → q % 4 = 3 → Even (padicValNat q n) :=\n\n/-- The only numbers with empty prime factorization are `0` and `1` -/\ntheorem ∀ (n : ℕ), Nat.factorization n = 0 ↔ n = 0 ∨ n = 1 :=\n\n/-- The natural square root is at most the real square root -/\ntheorem ∀ {a : ℕ}, ↑(Nat.sqrt a) ≤ Real.sqrt ↑a :=\n\n/-- Two natural numbers are equal if and only if they have the same multiples. -/\ntheorem ∀ {m n : ℕ}, (∀ (a : ℕ), m ∣ a ↔ n ∣ a) ↔ m = n :=\n\n/-- All composite numbers are Fermat pseudoprimes to base 1. -/\ntheorem ∀ {n : ℕ}, 1 < n → ¬Nat.Prime n → FermatPsp n 1 :=\n\n/-- A natural number `n` is a sum of two squares if and only if `n = a^2 * b` with natural\nnumbers `a` and `b` such that `-1` is a square modulo `b`. -/\ntheorem ∀ {n : ℕ}, (∃ x y, n = x ^ 2 + y ^ 2) ↔ ∃ a b, n = a ^ 2 * b ∧ IsSquare (-1) :=\n\n/-- Every x greater than or equal to 1 is between two successive\nnatural-number powers of every y greater than one. -/\ntheorem ∀ {α : Type u_1} [inst : LinearOrderedRing α] [inst_1 : Archimedean α] {x y : α},\n  1 ≤ x → 1 < y → ∃ n, y ^ n ≤ x ∧ x < y ^ (n + 1) :=\n\n/-- The product of a list of positive natural numbers is positive,\nand likewise for any nontrivial ordered semiring. -/\ntheorem ∀ {R : Type u_1} [inst : StrictOrderedSemiring R] (l : List R), (∀ (a : R), a ∈ l → 0 < a) → 0 < List.prod l :=\n\n/-- Two natural numbers are equal if and only if they have the same divisors. -/\ntheorem ∀ {m n : ℕ}, (∀ (a : ℕ), a ∣ m ↔ a ∣ n) ↔ m = n :=\n\n/-- If a small natural number is divisible by a larger natural number,\nthe small number is zero. -/\ntheorem ∀ {a b : ℕ}, a ∣ b → b < a → b = 0 :=\n\n/-- If the natural number `n` is a sum of two squares of coprime natural numbers, then\n`-1` is a square modulo `n`. -/\ntheorem ∀ {n x y : ℕ}, n = x ^ 2 + y ^ 2 → Nat.coprime x y → IsSquare (-1) :=\n\n/-- Every natural number larger than `10` is the sum of a square and a prime. -/\ntheorem", "choices": ["∀ (n : ℕ), n > 10 → ∃ x p, n = x ^ 2 + p ∧ Nat.Prime p ", "∀ (n : ℕ), 10 < n → ∃ x y p, n = x ^ 2 + p ∧ Nat.Prime p ", "∀ (n : ℕ), 10 < n → ∃ p x, Nat.Prime p ∧ n = x ^ 2 + p ", "∀ (n : ℕ), 10 < n → ∃ x p, n = x ^ 2 + p ∧ Nat.Prime p ", "∀ (n : ℕ), n > 10 → ∃ x p, n = x ^ 2 + p ∧ Nat.Prime p ", "∀ (n : ℕ), 10 < n → ∃ x y, n = x ^ 2 + y ∧ Nat.Prime y ", "∀ (n : ℕ), n > 10 → ∃ x p, n = x ^ 2 + p ∧ Nat.Prime p ", "∀ {n : ℕ}, 10 < n → ∃ x p, n = x ^ 2 + p ∧ Nat.Prime p ", "∀ (n : ℕ), n > 10 → ∃ x p, n = x ^ 2 + p ∧ Nat.Prime p ", "∀ (n : ℕ), 10 < n → ∃ a p, n = a ^ 2 + p ∧ Nat.Prime p "]}
{"docString": "The initial object of a category is isomorphic to its terminal object.", "prompts": "[{\"theorem\":\n  \"∀ {C : Type u₁} [inst : CategoryTheory.Category C] (X : C) [h : (Y : C) → Unique (Y ⟶ X)],\\n  CategoryTheory.Limits.HasTerminal C\",\n  \"isProp\": true,\n  \"docString\":\n  \"We can more explicitly show that a category has a terminal object by specifying the object,\\nand showing there is a unique morphism to it from any other object. \"},\n {\"theorem\":\n  \"∀ {C : Type u₁} [inst : CategoryTheory.Category C] {X Y : C},\\n  CategoryTheory.Limits.IsTerminal X → ∀ (f g : Y ⟶ X), f = g\",\n  \"isProp\": true,\n  \"docString\": \"Any two morphisms to a terminal object are equal. \"},\n {\"theorem\":\n  \"∀ {C : Type u₁} [inst : CategoryTheory.Category C] (X : C) [h : (Y : C) → Unique (X ⟶ Y)],\\n  CategoryTheory.Limits.HasInitial C\",\n  \"isProp\": true,\n  \"docString\":\n  \"We can more explicitly show that a category has an initial object by specifying the object,\\nand showing there is a unique morphism from it to any other object. \"},\n {\"theorem\":\n  \"∀ {C : Type u₁} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasFiniteProducts C]\\n  [inst_2 : CategoryTheory.CartesianClosed C], CategoryTheory.ExponentialIdeal (CategoryTheory.subterminalInclusion C)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The subcategory of subterminal objects is an exponential ideal. \"},\n {\"theorem\":\n  \"∀ {C : Type u₁} [inst : CategoryTheory.Category C] {D : Type u₂} [inst_1 : CategoryTheory.Category D]\\n  {F : CategoryTheory.Functor D C}, CategoryTheory.IsSkeletonOf C D F → CategoryTheory.Skeletal D\",\n  \"isProp\": true,\n  \"docString\": \"The category `D` has isomorphic objects equal \"},\n {\"theorem\":\n  \"∀ {C : Type u₁} [inst : CategoryTheory.Category C] {X Y : C},\\n  CategoryTheory.Limits.IsTerminal X → ∀ (f : X ⟶ Y), CategoryTheory.Mono f\",\n  \"isProp\": true,\n  \"docString\": \"Any morphism from a terminal object is mono. \"},\n {\"theorem\":\n  \"∀ {C : Type u₁} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasInitial C]\\n  [inst_2 : CategoryTheory.Limits.HasTerminal C],\\n  CategoryTheory.Mono (CategoryTheory.Limits.initial.to (⊤_ C)) → CategoryTheory.Limits.InitialMonoClass C\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show a category is an `InitialMonoClass` it suffices to show the unique morphism from the\\ninitial object to a terminal object is a monomorphism. \"},\n {\"theorem\":\n  \"∀ {C : Type u₁} [inst : CategoryTheory.Category C] {I T : C} (hI : CategoryTheory.Limits.IsInitial I),\\n  CategoryTheory.Limits.IsTerminal T →\\n    CategoryTheory.Mono (CategoryTheory.Limits.IsInitial.to hI T) → CategoryTheory.Limits.InitialMonoClass C\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show a category is an `InitialMonoClass` it suffices to show the unique morphism from an\\ninitial object to a terminal object is a monomorphism. \"},\n {\"theorem\":\n  \"∀ {C : Type u₁} [inst : CategoryTheory.Category C] {X Y : C}, CategoryTheory.Limits.IsInitial X → ∀ (f g : X ⟶ Y), f = g\",\n  \"isProp\": true,\n  \"docString\": \"Any two morphisms from an initial object are equal. \"},\n {\"theorem\":\n  \"∀ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]\\n  [inst_2 : CategoryTheory.Limits.HasTerminal C], CategoryTheory.Limits.HasZeroObject C\",\n  \"isProp\": true,\n  \"docString\":\n  \"If there are zero morphisms, any terminal object is a zero object. \"},\n {\"theorem\":\n  \"∀ {C : Type u₁} [inst : CategoryTheory.Category C] {X Y : C},\\n  CategoryTheory.Limits.IsInitial X → ∀ (f : Y ⟶ X), CategoryTheory.Epi f\",\n  \"isProp\": true,\n  \"docString\": \"Any morphism to an initial object is epi. \"},\n {\"theorem\":\n  \"∀ (C : Type u) [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]\\n  [inst_2 : CategoryTheory.Limits.HasFiniteBiproducts C], CategoryTheory.Limits.HasZeroObject C\",\n  \"isProp\": true,\n  \"docString\": \"A category with finite biproducts has a zero object. \"},\n {\"theorem\":\n  \"∀ {J : Type u₁} [inst : CategoryTheory.Category J] [inst_1 : CategoryTheory.IsConnected J] (j₁ j₂ : J),\\n  CategoryTheory.Zigzag j₁ j₂\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a connected category, any two objects are related by `Zigzag`. \"},\n {\"theorem\":\n  \"∀ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Preadditive C]\\n  [inst_2 : CategoryTheory.Limits.HasKernels C] [inst_3 : CategoryTheory.Limits.HasCokernels C]\\n  [inst_4 : ∀ {X Y : C} (f : X ⟶ Y), CategoryTheory.IsIso (CategoryTheory.Abelian.coimageImageComparison f)],\\n  CategoryTheory.Limits.HasImages C\",\n  \"isProp\": true,\n  \"docString\":\n  \"A category in which coimage-image comparisons are all isomorphisms has images. \"},\n {\"theorem\":\n  \"∀ (C : Type u) [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasInitial C]\\n  [inst_2 : CategoryTheory.Limits.HasPushouts C], CategoryTheory.Limits.HasBinaryCoproducts C\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any category with pushouts and initial object has binary coproducts. \"},\n {\"theorem\":\n  \"∀ {C : Type u₁} [inst : CategoryTheory.Category C] [self : CategoryTheory.Limits.InitialMonoClass C] {I : C} (X : C)\\n  (hI : CategoryTheory.Limits.IsInitial I), CategoryTheory.Mono (CategoryTheory.Limits.IsInitial.to hI X)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The map from the (any as stated) initial object to any other object is a\\nmonomorphism \"},\n {\"theorem\":\n  \"∀ {J : Type u₁} [inst : CategoryTheory.Category J] (j : CategoryTheory.ConnectedComponents J),\\n  CategoryTheory.IsConnected (CategoryTheory.Component j)\",\n  \"isProp\": true,\n  \"docString\": \"Each connected component of the category is connected. \"},\n {\"theorem\":\n  \"∀ {C : Type u} [inst : CategoryTheory.Category C] (I : C),\\n  (∀ (A : C) (f : I ⟶ A), CategoryTheory.IsIso f) → CategoryTheory.Limits.HasStrictTerminalObjects C\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `C` has an object such that every morphism *from* it is an isomorphism, then `C`\\nhas strict terminal objects. \"},\n {\"theorem\":\n  \"∀ {C : Type u₁} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.MonoidalCategory C],\\n  CategoryTheory.ReflectsIsomorphisms (Mon_.forget C)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The forgetful functor from monoid objects to the ambient category reflects isomorphisms. \"},\n {\"theorem\":\n  \"∀ {C : Type u₁} [inst : CategoryTheory.Category C] {X Y : C},\\n  CategoryTheory.Limits.IsTerminal X → ∀ (f : X ⟶ Y), CategoryTheory.IsSplitMono f\",\n  \"isProp\": true,\n  \"docString\": \"Any morphism from a terminal object is split mono. \"}]\n", "prompt_cons": "/-- We can more explicitly show that a category has a terminal object by specifying the object,\nand showing there is a unique morphism to it from any other object. -/\ntheorem ∀ {C : Type u₁} [inst : CategoryTheory.Category C] (X : C) [h : (Y : C) → Unique (Y ⟶ X)],\n  CategoryTheory.Limits.HasTerminal C :=\n\n/-- Any two morphisms to a terminal object are equal. -/\ntheorem ∀ {C : Type u₁} [inst : CategoryTheory.Category C] {X Y : C},\n  CategoryTheory.Limits.IsTerminal X → ∀ (f g : Y ⟶ X), f = g :=\n\n/-- We can more explicitly show that a category has an initial object by specifying the object,\nand showing there is a unique morphism from it to any other object. -/\ntheorem ∀ {C : Type u₁} [inst : CategoryTheory.Category C] (X : C) [h : (Y : C) → Unique (X ⟶ Y)],\n  CategoryTheory.Limits.HasInitial C :=\n\n/-- The subcategory of subterminal objects is an exponential ideal. -/\ntheorem ∀ {C : Type u₁} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasFiniteProducts C]\n  [inst_2 : CategoryTheory.CartesianClosed C], CategoryTheory.ExponentialIdeal (CategoryTheory.subterminalInclusion C) :=\n\n/-- The category `D` has isomorphic objects equal -/\ntheorem ∀ {C : Type u₁} [inst : CategoryTheory.Category C] {D : Type u₂} [inst_1 : CategoryTheory.Category D]\n  {F : CategoryTheory.Functor D C}, CategoryTheory.IsSkeletonOf C D F → CategoryTheory.Skeletal D :=\n\n/-- Any morphism from a terminal object is mono. -/\ntheorem ∀ {C : Type u₁} [inst : CategoryTheory.Category C] {X Y : C},\n  CategoryTheory.Limits.IsTerminal X → ∀ (f : X ⟶ Y), CategoryTheory.Mono f :=\n\n/-- To show a category is an `InitialMonoClass` it suffices to show the unique morphism from the\ninitial object to a terminal object is a monomorphism. -/\ntheorem ∀ {C : Type u₁} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasInitial C]\n  [inst_2 : CategoryTheory.Limits.HasTerminal C],\n  CategoryTheory.Mono (CategoryTheory.Limits.initial.to (⊤_ C)) → CategoryTheory.Limits.InitialMonoClass C :=\n\n/-- To show a category is an `InitialMonoClass` it suffices to show the unique morphism from an\ninitial object to a terminal object is a monomorphism. -/\ntheorem ∀ {C : Type u₁} [inst : CategoryTheory.Category C] {I T : C} (hI : CategoryTheory.Limits.IsInitial I),\n  CategoryTheory.Limits.IsTerminal T →\n    CategoryTheory.Mono (CategoryTheory.Limits.IsInitial.to hI T) → CategoryTheory.Limits.InitialMonoClass C :=\n\n/-- Any two morphisms from an initial object are equal. -/\ntheorem ∀ {C : Type u₁} [inst : CategoryTheory.Category C] {X Y : C}, CategoryTheory.Limits.IsInitial X → ∀ (f g : X ⟶ Y), f = g :=\n\n/-- If there are zero morphisms, any terminal object is a zero object. -/\ntheorem ∀ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]\n  [inst_2 : CategoryTheory.Limits.HasTerminal C], CategoryTheory.Limits.HasZeroObject C :=\n\n/-- Any morphism to an initial object is epi. -/\ntheorem ∀ {C : Type u₁} [inst : CategoryTheory.Category C] {X Y : C},\n  CategoryTheory.Limits.IsInitial X → ∀ (f : Y ⟶ X), CategoryTheory.Epi f :=\n\n/-- A category with finite biproducts has a zero object. -/\ntheorem ∀ (C : Type u) [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]\n  [inst_2 : CategoryTheory.Limits.HasFiniteBiproducts C], CategoryTheory.Limits.HasZeroObject C :=\n\n/-- In a connected category, any two objects are related by `Zigzag`. -/\ntheorem ∀ {J : Type u₁} [inst : CategoryTheory.Category J] [inst_1 : CategoryTheory.IsConnected J] (j₁ j₂ : J),\n  CategoryTheory.Zigzag j₁ j₂ :=\n\n/-- A category in which coimage-image comparisons are all isomorphisms has images. -/\ntheorem ∀ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Preadditive C]\n  [inst_2 : CategoryTheory.Limits.HasKernels C] [inst_3 : CategoryTheory.Limits.HasCokernels C]\n  [inst_4 : ∀ {X Y : C} (f : X ⟶ Y), CategoryTheory.IsIso (CategoryTheory.Abelian.coimageImageComparison f)],\n  CategoryTheory.Limits.HasImages C :=\n\n/-- Any category with pushouts and initial object has binary coproducts. -/\ntheorem ∀ (C : Type u) [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasInitial C]\n  [inst_2 : CategoryTheory.Limits.HasPushouts C], CategoryTheory.Limits.HasBinaryCoproducts C :=\n\n/-- The map from the (any as stated) initial object to any other object is a\nmonomorphism -/\ntheorem ∀ {C : Type u₁} [inst : CategoryTheory.Category C] [self : CategoryTheory.Limits.InitialMonoClass C] {I : C} (X : C)\n  (hI : CategoryTheory.Limits.IsInitial I), CategoryTheory.Mono (CategoryTheory.Limits.IsInitial.to hI X) :=\n\n/-- Each connected component of the category is connected. -/\ntheorem ∀ {J : Type u₁} [inst : CategoryTheory.Category J] (j : CategoryTheory.ConnectedComponents J),\n  CategoryTheory.IsConnected (CategoryTheory.Component j) :=\n\n/-- If `C` has an object such that every morphism *from* it is an isomorphism, then `C`\nhas strict terminal objects. -/\ntheorem ∀ {C : Type u} [inst : CategoryTheory.Category C] (I : C),\n  (∀ (A : C) (f : I ⟶ A), CategoryTheory.IsIso f) → CategoryTheory.Limits.HasStrictTerminalObjects C :=\n\n/-- The forgetful functor from monoid objects to the ambient category reflects isomorphisms. -/\ntheorem ∀ {C : Type u₁} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.MonoidalCategory C],\n  CategoryTheory.ReflectsIsomorphisms (Mon_.forget C) :=\n\n/-- Any morphism from a terminal object is split mono. -/\ntheorem ∀ {C : Type u₁} [inst : CategoryTheory.Category C] {X Y : C},\n  CategoryTheory.Limits.IsTerminal X → ∀ (f : X ⟶ Y), CategoryTheory.IsSplitMono f :=\n\n/-- The initial object of a category is isomorphic to its terminal object. -/\ntheorem", "choices": ["∀ {C : Type u₁} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasInitial C]\n  [inst_2 : CategoryTheory.Limits.HasTerminal C], C ⥤ ⊤_ C ", "∀ {C : Type u₁} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasInitial C]\n  [inst_2 : CategoryTheory.Limits.HasTerminal C], Nonempty (⊥_ C ≅ ⊤_ C) ", "∀ {C : Type u₁} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasInitial C]\n  [inst_2 : CategoryTheory.Limits.HasTerminal C], CategoryTheory.IsIsomorphic (⊥_ C) (⊤_ C) ", "∀ {C : Type u₁} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasInitial C]\n  [inst_2 : CategoryTheory.Limits.HasTerminal C], CategoryTheory.Limits.initial ≅ ⊤_ C ", "∀ {C : Type u₁} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasInitial C]\n  [inst_2 : CategoryTheory.Limits.HasTerminal C], CategoryTheory.IsIsomorphic (⊥_ C) (⊤_ C) ", "∀ {C : Type u₁} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasInitial C]\n  [inst_2 : CategoryTheory.Limits.HasTerminal C], C ≅ ⊤_ C ", "∀ {C : Type u₁} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasInitial C]\n  [inst_2 : CategoryTheory.Limits.HasTerminal C], CategoryTheory.IsIsomorphic (⊥_ C) (⊤_ C) ", "∀ {C : Type u₁} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasInitial C] [inst_2 : CategoryTheory.Limits.HasTerminal C],\n  ⊥_ C ≅ ⊤_ C ", "∀ {C : Type u₁} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasInitial C]\n  [inst_2 : CategoryTheory.Limits.HasTerminal C], CategoryTheory.Limits.initial C ≅ CategoryTheory.Limits.terminal C ", "∀ {C : Type u₁} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasInitial C]\n  [inst_2 : CategoryTheory.Limits.HasTerminal C], Nonempty (⊥_ C ≅ ⊤_ C) "]}
{"docString": "If the composition of two functions is continuous, then each of them is continuous.", "prompts": "[{\"theorem\":\n  \"∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] {m : MeasurableSpace X} [inst_1 : TopologicalSpace Y]\\n  [inst_2 : T2Space Y] {μ : MeasureTheory.Measure X} [inst_3 : MeasureTheory.Measure.IsOpenPosMeasure μ] {f g : X → Y},\\n  f =ᶠ[MeasureTheory.Measure.ae μ] g → Continuous f → Continuous g → f = g\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two continuous functions are a.e. equal, then they are equal. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u𝕜} {G : Type uG} {E : Type uE} {E' : Type uE'} {F : Type uF} [inst : NormedAddCommGroup E]\\n  [inst_1 : NormedAddCommGroup E'] [inst_2 : NormedAddCommGroup F] {f : G → E} {g : G → E'}\\n  [inst_3 : NontriviallyNormedField 𝕜] [inst_4 : NormedSpace 𝕜 E] [inst_5 : NormedSpace 𝕜 E'] [inst_6 : NormedSpace 𝕜 F]\\n  (L : E →L[𝕜] E' →L[𝕜] F) [inst_7 : MeasurableSpace G] {μ : MeasureTheory.Measure G} [inst_8 : NormedSpace ℝ F]\\n  [inst_9 : AddGroup G] [inst_10 : TopologicalSpace G] [inst_11 : TopologicalAddGroup G] [inst_12 : BorelSpace G]\\n  [inst_13 : TopologicalSpace.FirstCountableTopology G] [inst_14 : TopologicalSpace.SecondCountableTopology G],\\n  BddAbove (Set.range fun x => ‖g x‖) → MeasureTheory.Integrable f → Continuous g → Continuous (convolution f g L)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The convolution is continuous if one function is integrable and the other is bounded and\\ncontinuous. \"},\n {\"theorem\":\n  \"∀ {α : Type u_2} {β : Type u_1} {γ : Type u_3} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β]\\n  [inst_2 : TopologicalSpace γ] (e : LocalHomeomorph α β) {f : β → γ} {s : Set β},\\n  s ⊆ e.target → (ContinuousOn f s ↔ ContinuousOn (f ∘ ↑e) (e.source ∩ ↑e ⁻¹' s))\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function is continuous on a set if and only if its composition with a local homeomorphism\\non the right is continuous on the corresponding set. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : T2Space α] {s : Set β},\\n  Dense s → ∀ {f g : β → α}, Continuous f → Continuous g → Set.EqOn f g s → f = g\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two continuous functions are equal on a dense set, then they are equal. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {p : Filter ι}\\n  [inst_1 : TopologicalSpace α],\\n  TendstoUniformly F f p → (∀ᶠ (n : ι) in p, Continuous (F n)) → ∀ [inst_2 : Filter.NeBot p], Continuous f\",\n  \"isProp\": true,\n  \"docString\": \"A uniform limit of continuous functions is continuous. \"},\n {\"theorem\":\n  \"∀ {ι : Type u_1} {X : Type u_2} {α : Type u_3} [inst : TopologicalSpace X] [inst_1 : UniformSpace α] {F : ι → X → α},\\n  Equicontinuous F → ∀ (i : ι), Continuous (F i)\",\n  \"isProp\": true,\n  \"docString\": \"Each function of an equicontinuous family is continuous. \"},\n {\"theorem\":\n  \"∀ {α : Type u_2} {β : Type u_3} {γ : Type u_1} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β]\\n  [inst_2 : TopologicalSpace γ] (e : LocalHomeomorph α β) {f : γ → α} {s : Set γ},\\n  s ⊆ f ⁻¹' e.source → (ContinuousOn f s ↔ ContinuousOn (↑e ∘ f) s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function is continuous on a set if and only if its composition with a local homeomorphism\\non the left is continuous on the corresponding set. \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] {m : MeasurableSpace X} [inst_1 : TopologicalSpace Y]\\n  [inst_2 : T2Space Y] {μ : MeasureTheory.Measure X} [inst_3 : MeasureTheory.Measure.IsOpenPosMeasure μ] {U : Set X}\\n  {f g : X → Y},\\n  f =ᶠ[MeasureTheory.Measure.ae (MeasureTheory.Measure.restrict μ U)] g →\\n    IsOpen U → ContinuousOn f U → ContinuousOn g U → Set.EqOn f g U\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two functions are a.e. equal on an open set and are continuous on this set, then they are\\nequal on this set. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : UniformSpace β] {f : α → β} [inst_1 : TopologicalSpace α],\\n  (∀ (u : Set (β × β)), u ∈ uniformity β → ∃ F, Continuous F ∧ ∀ (y : α), (f y, F y) ∈ u) → Continuous f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be uniformly approximated by continuous functions is continuous. \"},\n {\"theorem\":\n  \"∀ {α : Type u_2} {β : Type u_3} {γ : Type u_1} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β]\\n  [inst_2 : TopologicalSpace γ] (e : LocalHomeomorph α β) {f : γ → α},\\n  f ⁻¹' e.source = Set.univ → (Continuous f ↔ Continuous (↑e ∘ f))\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function is continuous if and only if its composition with a local homeomorphism\\non the left is continuous and its image is contained in the source. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u𝕜} {G : Type uG} {E : Type uE} {E' : Type uE'} {F : Type uF} [inst : NormedAddCommGroup E]\\n  [inst_1 : NormedAddCommGroup E'] [inst_2 : NormedAddCommGroup F] {f : G → E} {g : G → E'}\\n  [inst_3 : NontriviallyNormedField 𝕜] [inst_4 : NormedSpace 𝕜 E] [inst_5 : NormedSpace 𝕜 E'] [inst_6 : NormedSpace 𝕜 F]\\n  (L : E →L[𝕜] E' →L[𝕜] F) [inst_7 : MeasurableSpace G] {μ : MeasureTheory.Measure G} [inst_8 : NormedSpace ℝ F]\\n  [inst_9 : AddGroup G] [inst_10 : TopologicalSpace G] [inst_11 : TopologicalAddGroup G] [inst_12 : BorelSpace G]\\n  [inst_13 : TopologicalSpace.FirstCountableTopology G],\\n  HasCompactSupport g → MeasureTheory.LocallyIntegrable f → Continuous g → Continuous (convolution f g L)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The convolution is continuous if one function is locally integrable and the other has compact\\nsupport and is continuous. \"},\n {\"theorem\":\n  \"∀ {ι : Type u_1} {α : Type u_2} {β : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β] {F : ι → β → α},\\n  UniformEquicontinuous F → ∀ (i : ι), UniformContinuous (F i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Each function of a uniformly equicontinuous family is uniformly continuous. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : UniformSpace β] {f : α → β} [inst_1 : TopologicalSpace α],\\n  (∀ (x : α) (u : Set (β × β)),\\n      u ∈ uniformity β → ∃ t, t ∈ nhds x ∧ ∃ F, ContinuousAt F x ∧ ∀ (y : α), y ∈ t → (f y, F y) ∈ u) →\\n    Continuous f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be locally uniformly approximated by continuous functions is continuous. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {p : Filter ι}\\n  [inst_1 : TopologicalSpace α],\\n  TendstoLocallyUniformly F f p → (∀ᶠ (n : ι) in p, Continuous (F n)) → ∀ [inst_2 : Filter.NeBot p], Continuous f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A locally uniform limit of continuous functions is continuous. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderClosedTopology α]\\n  [inst_3 : TopologicalSpace β] [inst_4 : Nonempty α] {f : β → α} {K : Set β},\\n  IsCompact K → ContinuousOn f K → BddAbove (f '' K)\",\n  \"isProp\": true,\n  \"docString\": \"A continuous function is bounded above on a compact set. \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : SequentialSpace X]\\n  {f : X → Y}, SeqContinuous f → Continuous f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A sequentially continuous function defined on a sequential space is continuous. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {γ : Type u_2} [inst : TopologicalSpace α] [inst_1 : MeasurableSpace α]\\n  [inst_2 : OpensMeasurableSpace α] [inst_3 : TopologicalSpace γ] [inst_4 : MeasurableSpace γ] [inst_5 : BorelSpace γ]\\n  {f g : α → γ} {s : Set α} [inst_6 : (j : α) → Decidable (j ∈ s)],\\n  ContinuousOn f s → ContinuousOn g sᶜ → MeasurableSet s → Measurable (Set.piecewise s f g)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function is defined piecewise in terms of functions which are continuous on their\\nrespective pieces, then it is measurable. \"},\n {\"theorem\":\n  \"∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] {f g : ℝ → E} {μ : MeasureTheory.Measure ℝ}\\n  {a b : ℝ}, Set.EqOn f g (Set.uIcc a b) → ∫ (x : ℝ) in a..b, f x ∂μ = ∫ (x : ℝ) in a..b, g x ∂μ\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two functions are equal in the relevant interval, their interval integrals are also equal. \"},\n {\"theorem\":\n  \"∀ {α : Type u_3} {β : Type u_1} {γ : Type u_2} {m : MeasurableSpace α} {μ : MeasureTheory.Measure α}\\n  [inst : TopologicalSpace β] [inst_1 : TopologicalSpace γ] {g : β → γ} {f : α → β},\\n  Continuous g → MeasureTheory.AEStronglyMeasurable f μ → MeasureTheory.AEStronglyMeasurable (fun x => g (f x)) μ\",\n  \"isProp\": true,\n  \"docString\":\n  \"The composition of a continuous function and an ae strongly measurable function is ae strongly\\nmeasurable. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderClosedTopology α]\\n  [inst_3 : TopologicalSpace β] [inst_4 : Nonempty α] {f : β → α} {K : Set β},\\n  IsCompact K → ContinuousOn f K → BddBelow (f '' K)\",\n  \"isProp\": true,\n  \"docString\": \"A continuous function is bounded below on a compact set. \"}]\n", "prompt_cons": "/-- If two continuous functions are a.e. equal, then they are equal. -/\ntheorem ∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] {m : MeasurableSpace X} [inst_1 : TopologicalSpace Y]\n  [inst_2 : T2Space Y] {μ : MeasureTheory.Measure X} [inst_3 : MeasureTheory.Measure.IsOpenPosMeasure μ] {f g : X → Y},\n  f =ᶠ[MeasureTheory.Measure.ae μ] g → Continuous f → Continuous g → f = g :=\n\n/-- The convolution is continuous if one function is integrable and the other is bounded and\ncontinuous. -/\ntheorem ∀ {𝕜 : Type u𝕜} {G : Type uG} {E : Type uE} {E' : Type uE'} {F : Type uF} [inst : NormedAddCommGroup E]\n  [inst_1 : NormedAddCommGroup E'] [inst_2 : NormedAddCommGroup F] {f : G → E} {g : G → E'}\n  [inst_3 : NontriviallyNormedField 𝕜] [inst_4 : NormedSpace 𝕜 E] [inst_5 : NormedSpace 𝕜 E'] [inst_6 : NormedSpace 𝕜 F]\n  (L : E →L[𝕜] E' →L[𝕜] F) [inst_7 : MeasurableSpace G] {μ : MeasureTheory.Measure G} [inst_8 : NormedSpace ℝ F]\n  [inst_9 : AddGroup G] [inst_10 : TopologicalSpace G] [inst_11 : TopologicalAddGroup G] [inst_12 : BorelSpace G]\n  [inst_13 : TopologicalSpace.FirstCountableTopology G] [inst_14 : TopologicalSpace.SecondCountableTopology G],\n  BddAbove (Set.range fun x => ‖g x‖) → MeasureTheory.Integrable f → Continuous g → Continuous (convolution f g L) :=\n\n/-- A function is continuous on a set if and only if its composition with a local homeomorphism\non the right is continuous on the corresponding set. -/\ntheorem ∀ {α : Type u_2} {β : Type u_1} {γ : Type u_3} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β]\n  [inst_2 : TopologicalSpace γ] (e : LocalHomeomorph α β) {f : β → γ} {s : Set β},\n  s ⊆ e.target → (ContinuousOn f s ↔ ContinuousOn (f ∘ ↑e) (e.source ∩ ↑e ⁻¹' s)) :=\n\n/-- If two continuous functions are equal on a dense set, then they are equal. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : T2Space α] {s : Set β},\n  Dense s → ∀ {f g : β → α}, Continuous f → Continuous g → Set.EqOn f g s → f = g :=\n\n/-- A uniform limit of continuous functions is continuous. -/\ntheorem ∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {p : Filter ι}\n  [inst_1 : TopologicalSpace α],\n  TendstoUniformly F f p → (∀ᶠ (n : ι) in p, Continuous (F n)) → ∀ [inst_2 : Filter.NeBot p], Continuous f :=\n\n/-- Each function of an equicontinuous family is continuous. -/\ntheorem ∀ {ι : Type u_1} {X : Type u_2} {α : Type u_3} [inst : TopologicalSpace X] [inst_1 : UniformSpace α] {F : ι → X → α},\n  Equicontinuous F → ∀ (i : ι), Continuous (F i) :=\n\n/-- A function is continuous on a set if and only if its composition with a local homeomorphism\non the left is continuous on the corresponding set. -/\ntheorem ∀ {α : Type u_2} {β : Type u_3} {γ : Type u_1} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β]\n  [inst_2 : TopologicalSpace γ] (e : LocalHomeomorph α β) {f : γ → α} {s : Set γ},\n  s ⊆ f ⁻¹' e.source → (ContinuousOn f s ↔ ContinuousOn (↑e ∘ f) s) :=\n\n/-- If two functions are a.e. equal on an open set and are continuous on this set, then they are\nequal on this set. -/\ntheorem ∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] {m : MeasurableSpace X} [inst_1 : TopologicalSpace Y]\n  [inst_2 : T2Space Y] {μ : MeasureTheory.Measure X} [inst_3 : MeasureTheory.Measure.IsOpenPosMeasure μ] {U : Set X}\n  {f g : X → Y},\n  f =ᶠ[MeasureTheory.Measure.ae (MeasureTheory.Measure.restrict μ U)] g →\n    IsOpen U → ContinuousOn f U → ContinuousOn g U → Set.EqOn f g U :=\n\n/-- A function which can be uniformly approximated by continuous functions is continuous. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : UniformSpace β] {f : α → β} [inst_1 : TopologicalSpace α],\n  (∀ (u : Set (β × β)), u ∈ uniformity β → ∃ F, Continuous F ∧ ∀ (y : α), (f y, F y) ∈ u) → Continuous f :=\n\n/-- A function is continuous if and only if its composition with a local homeomorphism\non the left is continuous and its image is contained in the source. -/\ntheorem ∀ {α : Type u_2} {β : Type u_3} {γ : Type u_1} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β]\n  [inst_2 : TopologicalSpace γ] (e : LocalHomeomorph α β) {f : γ → α},\n  f ⁻¹' e.source = Set.univ → (Continuous f ↔ Continuous (↑e ∘ f)) :=\n\n/-- The convolution is continuous if one function is locally integrable and the other has compact\nsupport and is continuous. -/\ntheorem ∀ {𝕜 : Type u𝕜} {G : Type uG} {E : Type uE} {E' : Type uE'} {F : Type uF} [inst : NormedAddCommGroup E]\n  [inst_1 : NormedAddCommGroup E'] [inst_2 : NormedAddCommGroup F] {f : G → E} {g : G → E'}\n  [inst_3 : NontriviallyNormedField 𝕜] [inst_4 : NormedSpace 𝕜 E] [inst_5 : NormedSpace 𝕜 E'] [inst_6 : NormedSpace 𝕜 F]\n  (L : E →L[𝕜] E' →L[𝕜] F) [inst_7 : MeasurableSpace G] {μ : MeasureTheory.Measure G} [inst_8 : NormedSpace ℝ F]\n  [inst_9 : AddGroup G] [inst_10 : TopologicalSpace G] [inst_11 : TopologicalAddGroup G] [inst_12 : BorelSpace G]\n  [inst_13 : TopologicalSpace.FirstCountableTopology G],\n  HasCompactSupport g → MeasureTheory.LocallyIntegrable f → Continuous g → Continuous (convolution f g L) :=\n\n/-- Each function of a uniformly equicontinuous family is uniformly continuous. -/\ntheorem ∀ {ι : Type u_1} {α : Type u_2} {β : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β] {F : ι → β → α},\n  UniformEquicontinuous F → ∀ (i : ι), UniformContinuous (F i) :=\n\n/-- A function which can be locally uniformly approximated by continuous functions is continuous. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : UniformSpace β] {f : α → β} [inst_1 : TopologicalSpace α],\n  (∀ (x : α) (u : Set (β × β)),\n      u ∈ uniformity β → ∃ t, t ∈ nhds x ∧ ∃ F, ContinuousAt F x ∧ ∀ (y : α), y ∈ t → (f y, F y) ∈ u) →\n    Continuous f :=\n\n/-- A locally uniform limit of continuous functions is continuous. -/\ntheorem ∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {p : Filter ι}\n  [inst_1 : TopologicalSpace α],\n  TendstoLocallyUniformly F f p → (∀ᶠ (n : ι) in p, Continuous (F n)) → ∀ [inst_2 : Filter.NeBot p], Continuous f :=\n\n/-- A continuous function is bounded above on a compact set. -/\ntheorem ∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderClosedTopology α]\n  [inst_3 : TopologicalSpace β] [inst_4 : Nonempty α] {f : β → α} {K : Set β},\n  IsCompact K → ContinuousOn f K → BddAbove (f '' K) :=\n\n/-- A sequentially continuous function defined on a sequential space is continuous. -/\ntheorem ∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : SequentialSpace X]\n  {f : X → Y}, SeqContinuous f → Continuous f :=\n\n/-- If a function is defined piecewise in terms of functions which are continuous on their\nrespective pieces, then it is measurable. -/\ntheorem ∀ {α : Type u_1} {γ : Type u_2} [inst : TopologicalSpace α] [inst_1 : MeasurableSpace α]\n  [inst_2 : OpensMeasurableSpace α] [inst_3 : TopologicalSpace γ] [inst_4 : MeasurableSpace γ] [inst_5 : BorelSpace γ]\n  {f g : α → γ} {s : Set α} [inst_6 : (j : α) → Decidable (j ∈ s)],\n  ContinuousOn f s → ContinuousOn g sᶜ → MeasurableSet s → Measurable (Set.piecewise s f g) :=\n\n/-- If two functions are equal in the relevant interval, their interval integrals are also equal. -/\ntheorem ∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] {f g : ℝ → E} {μ : MeasureTheory.Measure ℝ}\n  {a b : ℝ}, Set.EqOn f g (Set.uIcc a b) → ∫ (x : ℝ) in a..b, f x ∂μ = ∫ (x : ℝ) in a..b, g x ∂μ :=\n\n/-- The composition of a continuous function and an ae strongly measurable function is ae strongly\nmeasurable. -/\ntheorem ∀ {α : Type u_3} {β : Type u_1} {γ : Type u_2} {m : MeasurableSpace α} {μ : MeasureTheory.Measure α}\n  [inst : TopologicalSpace β] [inst_1 : TopologicalSpace γ] {g : β → γ} {f : α → β},\n  Continuous g → MeasureTheory.AEStronglyMeasurable f μ → MeasureTheory.AEStronglyMeasurable (fun x => g (f x)) μ :=\n\n/-- A continuous function is bounded below on a compact set. -/\ntheorem ∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderClosedTopology α]\n  [inst_3 : TopologicalSpace β] [inst_4 : Nonempty α] {f : β → α} {K : Set β},\n  IsCompact K → ContinuousOn f K → BddBelow (f '' K) :=\n\n/-- If the composition of two functions is continuous, then each of them is continuous. -/\ntheorem", "choices": ["∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β]\n  [inst_2 : TopologicalSpace γ] {f : α → β} {g : β → γ} {h : α → γ},\n  h = g ∘ f → Continuous h → Continuous f → Continuous g ", "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β]\n  [inst_2 : TopologicalSpace γ] {f : α → β} {g : β → γ} {h : α → γ}, h = g ∘ f → Continuous h → Continuous f → Continuous g ", "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β]\n  [inst_2 : TopologicalSpace γ] {f : α → β} {g : β → γ}, Continuous (g ∘ f) → Continuous f → Continuous g ", "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : TopologicalSpace γ]\n  {f : α → β} {g : β → γ} {h : α → γ}, h = g ∘ f → Continuous h → Continuous f → Continuous g ", "forall {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : TopologicalSpace γ]\n  {f : α → β} {g : β → γ} {h : α → γ}, h = (g ∘ f) → Continuous h → Continuous f → Continuous g ", "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β]\n  [inst_2 : TopologicalSpace γ] {f : α → β} {g : β → γ},\n  Continuous (g ∘ f) → Continuous f → Continuous g ", "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β]\n  [inst_2 : TopologicalSpace γ] {f : α → β} {g : β → γ}, Continuous (g ∘ f) → Continuous f → Continuous g ", "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β]\n  [inst_2 : TopologicalSpace γ] {f : α → β} {g : β → γ}, Continuous (g ∘ f) → Continuous f → Continuous g ", "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : TopologicalSpace γ]\n  {f : α → β} {g : β → γ} {h : α → γ}, h = (g ∘ f) → Continuous h → Continuous f → Continuous g ", "∀ {α : Type u_3} {β : Type u_1} {γ : Type u_2} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β]\n  [inst_2 : TopologicalSpace γ] {g : β → γ} {f : α → β},\n  Continuous (g ∘ f) → Continuous f → Continuous g "]}
{"docString": "If `a` commutes with `b` and `b` commutes with `c` then `a` commutes with `c`.", "prompts": "[{\"theorem\":\n  \"∀ {S : Type u_1} [inst : Add S] {a b : S}, AddCommute a b → AddCommute b a\",\n  \"isProp\": true,\n  \"docString\": \"If `a` commutes with `b`, then `b` commutes with `a`.\"},\n {\"theorem\":\n  \"∀ {S : Type u_1} [inst : Mul S] {a b : S}, Commute a b → Commute b a\",\n  \"isProp\": true,\n  \"docString\": \"If `a` commutes with `b`, then `b` commutes with `a`. \"},\n {\"theorem\":\n  \"∀ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a b → Commute a c → Commute a (b * c)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `a` commutes with both `b` and `c`, then it commutes with their product. \"},\n {\"theorem\":\n  \"∀ {S : Type u_1} [inst : AddSemigroup S] {a b c : S}, AddCommute a b → AddCommute a c → AddCommute a (b + c)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `a` commutes with both `b` and `c`, then it commutes with their sum.\"},\n {\"theorem\":\n  \"∀ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a c → Commute b c → Commute (a * b) c\",\n  \"isProp\": true,\n  \"docString\":\n  \"If both `a` and `b` commute with `c`, then their product commutes with `c`. \"},\n {\"theorem\":\n  \"∀ {S : Type u_1} [inst : AddSemigroup S] {a b c : S}, AddCommute a c → AddCommute b c → AddCommute (a + b) c\",\n  \"isProp\": true,\n  \"docString\":\n  \"If both `a` and `b` commute with `c`, then their product commutes with `c`.\"},\n {\"theorem\": \"∀ {S : Type u_1} [inst : Mul S] (a : S), Commute a a\",\n  \"isProp\": true,\n  \"docString\": \"Any element commutes with itself. \"},\n {\"theorem\": \"∀ {S : Type u_1} [inst : Add S] (a : S), AddCommute a a\",\n  \"isProp\": true,\n  \"docString\": \"Any element commutes with itself.\"},\n {\"theorem\":\n  \"∀ {R : Type u_1} {M : Type u_2} [inst : OrderedSemiring R] [inst_1 : OrderedAddCommMonoid M] [inst_2 : SMulWithZero R M]\\n  [self : OrderedSMul R M] {a b : M} {c : R}, c • a < c • b → 0 < c → a < b\",\n  \"isProp\": true,\n  \"docString\": \"If `c • a < c • b` for some positive `c`, then `a < b`. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {r : α → α → Prop} [self : IsDirected α r] (a b : α), ∃ c, r a c ∧ r b c\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every pair of elements `a` and `b` there is a `c` such that `r a c` and `r b c` \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : LinearOrderedAddCommGroup α] [hα : Archimedean α] {p : α} (hp : 0 < p) {a b c : α},\\n  toIcoMod hp c a = toIcoMod hp c b ↔ a ≡ b [PMOD p]\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `a` and `b` fall within the same cycle WRT `c`, then they are congruent modulo `p`. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : BEq α] [self : PartialEquivBEq α] {a b c : α},\\n  (a == b) = true → (b == c) = true → (a == c) = true\",\n  \"isProp\": true,\n  \"docString\":\n  \"Transitivity for `BEq`. If `a == b` and `b == c` then `a == c`. \"},\n {\"theorem\": \"∀ {a b c : ℤ}, a % b = c → b ∣ a - c\",\n  \"isProp\": true,\n  \"docString\": \"If `a % b = c` then `b` divides `a - c`. \"},\n {\"theorem\":\n  \"∀ {S : Type u_1} [inst : Semigroup S], Transitive fun a b => ∃ c, SemiconjBy c a b\",\n  \"isProp\": true,\n  \"docString\":\n  \"The relation “there exists an element that semiconjugates `a` to `b`” on a semigroup\\nis transitive. \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : Semiring R] {p : Polynomial R}, Polynomial.X * p = p * Polynomial.X\",\n  \"isProp\": true,\n  \"docString\":\n  \"`X` commutes with everything, even when the coefficients are noncommutative. \"},\n {\"theorem\":\n  \"∀ {S : Type u_1} [inst : Mul S] {a b : S}, Commute a b → a * b = b * a\",\n  \"isProp\": true,\n  \"docString\": \"Equality behind `Commute a b`; useful for rewriting. \"},\n {\"theorem\":\n  \"∀ {S : Type u_1} [inst : Semigroup S] {a b x y z : S}, SemiconjBy a y z → SemiconjBy b x y → SemiconjBy (a * b) x z\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `b` semiconjugates `x` to `y` and `a` semiconjugates `y` to `z`, then `a * b`\\nsemiconjugates `x` to `z`. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : CommMonoid α] (a b u : α), IsUnit u → (a ∣ u * b ↔ a ∣ b)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a commutative monoid, an element `a` divides an element `b` iff `a` divides all left\\nassociates of `b`. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [self : CircularPartialOrder α] {a b c : α}, btw a b c → btw c b a → a = b ∨ b = c ∨ c = a\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `b` is between `a` and `c` and also between `c` and `a`, then at least one pair of points\\namong `a`, `b`, `c` are identical. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : CommMonoid α] {a b : α} {u : αˣ}, ↑u * a ∣ b ↔ a ∣ b\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a commutative monoid, an element `a` divides an element `b` iff all\\nleft associates of `a` divide `b`.\"}]\n", "prompt_cons": "/-- If `a` commutes with `b`, then `b` commutes with `a`. -/\ntheorem ∀ {S : Type u_1} [inst : Add S] {a b : S}, AddCommute a b → AddCommute b a :=\n\n/-- If `a` commutes with `b`, then `b` commutes with `a`. -/\ntheorem ∀ {S : Type u_1} [inst : Mul S] {a b : S}, Commute a b → Commute b a :=\n\n/-- If `a` commutes with both `b` and `c`, then it commutes with their product. -/\ntheorem ∀ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a b → Commute a c → Commute a (b * c) :=\n\n/-- If `a` commutes with both `b` and `c`, then it commutes with their sum. -/\ntheorem ∀ {S : Type u_1} [inst : AddSemigroup S] {a b c : S}, AddCommute a b → AddCommute a c → AddCommute a (b + c) :=\n\n/-- If both `a` and `b` commute with `c`, then their product commutes with `c`. -/\ntheorem ∀ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a c → Commute b c → Commute (a * b) c :=\n\n/-- If both `a` and `b` commute with `c`, then their product commutes with `c`. -/\ntheorem ∀ {S : Type u_1} [inst : AddSemigroup S] {a b c : S}, AddCommute a c → AddCommute b c → AddCommute (a + b) c :=\n\n/-- Any element commutes with itself. -/\ntheorem ∀ {S : Type u_1} [inst : Mul S] (a : S), Commute a a :=\n\n/-- Any element commutes with itself. -/\ntheorem ∀ {S : Type u_1} [inst : Add S] (a : S), AddCommute a a :=\n\n/-- If `c • a < c • b` for some positive `c`, then `a < b`. -/\ntheorem ∀ {R : Type u_1} {M : Type u_2} [inst : OrderedSemiring R] [inst_1 : OrderedAddCommMonoid M] [inst_2 : SMulWithZero R M]\n  [self : OrderedSMul R M] {a b : M} {c : R}, c • a < c • b → 0 < c → a < b :=\n\n/-- For every pair of elements `a` and `b` there is a `c` such that `r a c` and `r b c` -/\ntheorem ∀ {α : Type u_1} {r : α → α → Prop} [self : IsDirected α r] (a b : α), ∃ c, r a c ∧ r b c :=\n\n/-- If `a` and `b` fall within the same cycle WRT `c`, then they are congruent modulo `p`. -/\ntheorem ∀ {α : Type u_1} [inst : LinearOrderedAddCommGroup α] [hα : Archimedean α] {p : α} (hp : 0 < p) {a b c : α},\n  toIcoMod hp c a = toIcoMod hp c b ↔ a ≡ b [PMOD p] :=\n\n/-- Transitivity for `BEq`. If `a == b` and `b == c` then `a == c`. -/\ntheorem ∀ {α : Type u_1} [inst : BEq α] [self : PartialEquivBEq α] {a b c : α},\n  (a == b) = true → (b == c) = true → (a == c) = true :=\n\n/-- If `a % b = c` then `b` divides `a - c`. -/\ntheorem ∀ {a b c : ℤ}, a % b = c → b ∣ a - c :=\n\n/-- The relation “there exists an element that semiconjugates `a` to `b`” on a semigroup\nis transitive. -/\ntheorem ∀ {S : Type u_1} [inst : Semigroup S], Transitive fun a b => ∃ c, SemiconjBy c a b :=\n\n/-- `X` commutes with everything, even when the coefficients are noncommutative. -/\ntheorem ∀ {R : Type u} [inst : Semiring R] {p : Polynomial R}, Polynomial.X * p = p * Polynomial.X :=\n\n/-- Equality behind `Commute a b`; useful for rewriting. -/\ntheorem ∀ {S : Type u_1} [inst : Mul S] {a b : S}, Commute a b → a * b = b * a :=\n\n/-- If `b` semiconjugates `x` to `y` and `a` semiconjugates `y` to `z`, then `a * b`\nsemiconjugates `x` to `z`. -/\ntheorem ∀ {S : Type u_1} [inst : Semigroup S] {a b x y z : S}, SemiconjBy a y z → SemiconjBy b x y → SemiconjBy (a * b) x z :=\n\n/-- In a commutative monoid, an element `a` divides an element `b` iff `a` divides all left\nassociates of `b`. -/\ntheorem ∀ {α : Type u_1} [inst : CommMonoid α] (a b u : α), IsUnit u → (a ∣ u * b ↔ a ∣ b) :=\n\n/-- If `b` is between `a` and `c` and also between `c` and `a`, then at least one pair of points\namong `a`, `b`, `c` are identical. -/\ntheorem ∀ {α : Type u_1} [self : CircularPartialOrder α] {a b c : α}, btw a b c → btw c b a → a = b ∨ b = c ∨ c = a :=\n\n/-- In a commutative monoid, an element `a` divides an element `b` iff all\nleft associates of `a` divide `b`. -/\ntheorem ∀ {α : Type u_1} [inst : CommMonoid α] {a b : α} {u : αˣ}, ↑u * a ∣ b ↔ a ∣ b :=\n\n/-- If `a` commutes with `b` and `b` commutes with `c` then `a` commutes with `c`. -/\ntheorem", "choices": ["∀ {S : Type u_1} [inst : Mul S] {a b c : S}, Commute a b → Commute b c → Commute a c ", "∀ {S : Type u_1} [inst : Mul S] {a b c : S}, Commute a b → Commute b c → Commute a c ", "∀ {S : Type u_1} [inst : Mul S] {a b c : S}, Commute a b → Commute b c → Commute a c ", "∀ {S : Type u_1} [inst : Mul S] {a b c : S}, Commute a b → Commute b c → Commute a c ", "∀ {S : Type u_1} [inst : Mul S] {a b c : S}, Commute a b → Commute b c → Commute a c ", "∀ {S : Type u_1} [inst : Mul S] {a b c : S}, Commute a b → Commute b c → Commute a c ", "∀ {S : Type u_1} [inst : Mul S] {a b c : S}, Commute a b → Commute b c → Commute a c ", "∀ {S : Type u_1} [inst : Mul S] {a b c : S}, Commute a b → Commute b c → Commute a c ", "∀ {S : Type u_1} [inst : Mul S] {a b c : S}, Commute a b → Commute b c → Commute a c ", "∀ {S : Type u_1} [inst : Mul S] {a b c : S}, Commute a b → Commute b c → Commute a c "]}
{"docString": "If an element maps to zero under a ring homomorphism, then it is zero.", "prompts": "[{\"theorem\":\n  \"∀ {α : Type u_1} {β : Type u_2} {x : NonAssocSemiring α} {x_1 : NonAssocSemiring β} (f : α →+* β), ↑f 0 = 0\",\n  \"isProp\": true,\n  \"docString\": \"Ring homomorphisms map zero to zero. \"},\n {\"theorem\":\n  \"∀ {R : Type u_2} {S : Type u_1} [inst : NonUnitalNonAssocSemiring R] [inst_1 : NonUnitalNonAssocSemiring S]\\n  (f : R ≃+* S), ↑f 0 = 0\",\n  \"isProp\": true,\n  \"docString\": \"A ring isomorphism sends zero to zero. \"},\n {\"theorem\":\n  \"∀ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Abelian C] {P Q : C} (f : P ⟶ Q),\\n  (∀ (a : CategoryTheory.Abelian.Pseudoelement P), CategoryTheory.Abelian.Pseudoelement.pseudoApply f a = 0 → a = 0) →\\n    CategoryTheory.Mono f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A morphism that only maps the zero pseudoelement to zero is a monomorphism. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : AddGroup α] [inst_1 : AddGroup β] {f : α → β}, IsAddGroupHom f → f 0 = 0\",\n  \"isProp\": true,\n  \"docString\": \"An additive group homomorphism sends 0 to 0.\"},\n {\"theorem\":\n  \"∀ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Abelian C] {P Q : C} (f : P ⟶ Q),\\n  Function.Injective (CategoryTheory.Abelian.Pseudoelement.pseudoApply f) →\\n    ∀ (a : CategoryTheory.Abelian.Pseudoelement P), CategoryTheory.Abelian.Pseudoelement.pseudoApply f a = 0 → a = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"A morphism that is injective on pseudoelements only maps the zero element to zero. \"},\n {\"theorem\":\n  \"∀ {R : Type u} {S : Type v} {F : Type u_1} [inst : Semiring R] [inst_1 : Semiring S] [rcf : RingHomClass F R S] (f : F)\\n  {r : R}, r ∈ RingHom.ker f ↔ ↑f r = 0\",\n  \"isProp\": true,\n  \"docString\": \"An element is in the kernel if and only if it maps to zero.\"},\n {\"theorem\":\n  \"∀ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Abelian C] {P : C} (Q : C)\\n  (a : CategoryTheory.Abelian.Pseudoelement P), CategoryTheory.Abelian.Pseudoelement.pseudoApply 0 a = 0\",\n  \"isProp\": true,\n  \"docString\": \"The zero morphism maps every pseudoelement to 0. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : Ring R] [inst_1 : NoZeroDivisors R] (s : Subring R), NoZeroDivisors { x // x ∈ s }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subring of a ring with no zero divisors has no zero divisors. \"},\n {\"theorem\":\n  \"∀ {R₁ : Type u_1} {R₂ : Type u_2} [inst : Semiring R₁] [inst_1 : Semiring R₂] [inst_2 : Norm R₁] [inst_3 : Norm R₂]\\n  {σ : R₁ →+* R₂} [self : RingHomIsometric σ] {x : R₁}, ‖↑σ x‖ = ‖x‖\",\n  \"isProp\": true,\n  \"docString\": \"The ring homomorphism is an isometry. \"},\n {\"theorem\":\n  \"∀ {M₀ : Type u_1} [inst : MulZeroOneClass M₀], 0 = 1 → ∀ (a : M₀), a = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a monoid with zero, if zero equals one, then zero is the only element. \"},\n {\"theorem\":\n  \"∀ {R : Type u} {S : Type v} [inst : Ring R] [inst_1 : Ring S] {f g : R →+* S} {s : Set R},\\n  Set.EqOn (↑f) (↑g) s → Set.EqOn ↑f ↑g ↑(Subring.closure s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two ring homomorphisms are equal on a set, then they are equal on its subring closure. \"},\n {\"theorem\":\n  \"∀ (R : Type u_1) [inst : CommRing R], Nonempty (Algebra ℚ R) ↔ ∀ (I : Ideal R), I ≠ ⊤ → CharZero (R ⧸ I)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A ring is a `ℚ`-algebra iff it has equal characteristic zero. \"},\n {\"theorem\":\n  \"∀ {M₀ : Type u_1} [inst : MulZeroOneClass M₀], 0 = 1 ↔ Subsingleton M₀\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a monoid with zero, zero equals one if and only if all elements of that semiring\\nare equal. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} {A : Type u_2} [inst : CommSemiring R] [inst_1 : Semiring A] [inst_2 : Algebra R A],\\n  Function.Injective ↑(algebraMap R A) → ∀ [inst : CharZero R], CharZero A\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the algebra map `R →+* A` is injective and `R` has characteristic zero then so does `A`. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {β : Type u_2} {x : NonAssocSemiring α} {x_1 : NonAssocSemiring β} (f : α →+* β), ↑f 1 = 1\",\n  \"isProp\": true,\n  \"docString\": \"Ring homomorphisms map one to one. \"},\n {\"theorem\":\n  \"∀ {K : Type u} {L : Type v} [inst : Field K] [inst_1 : Field L] {f g : K →+* L} {s : Set K},\\n  Set.EqOn (↑f) (↑g) s → Set.EqOn ↑f ↑g ↑(Subfield.closure s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two ring homomorphisms are equal on a set, then they are equal on its subfield closure. \"},\n {\"theorem\":\n  \"∀ {R : Type u_2} {G : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : Group G] [inst_3 : Fintype G]\\n  (f : G →* R), f ≠ 1 → (Finset.sum Finset.univ fun g => ↑f g) = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"In an integral domain, a sum indexed by a nontrivial homomorphism from a finite group is zero.\\n\"},\n {\"theorem\":\n  \"∀ {C : Type u_2} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Preadditive C]\\n  {X : CategoryTheory.SimplicialObject C} (q : ℕ), HomologicalComplex.Hom.f (AlgebraicTopology.DoldKan.Hσ q) 0 = 0\",\n  \"isProp\": true,\n  \"docString\": \"In degree `0`, the null homotopic map `Hσ` is zero. \"},\n {\"theorem\":\n  \"∀ {R : Type u} {S : Type v} [inst : NonAssocSemiring R] [inst_1 : NonAssocSemiring S] {f g : R →+* S} {s : Set R},\\n  Set.EqOn (↑f) (↑g) s → Set.EqOn ↑f ↑g ↑(Subsemiring.closure s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two ring homomorphisms are equal on a set, then they are equal on its subsemiring closure. \"},\n {\"theorem\":\n  \"∀ {R₁ : Type u_1} {R₂ : Type u_2} [inst : Semiring R₁] [inst_1 : Semiring R₂] {σ : R₁ →+* R₂}\\n  [self : RingHomSurjective σ], Function.Surjective ↑σ\",\n  \"isProp\": true,\n  \"docString\": \"The ring homomorphism is surjective \"}]\n", "prompt_cons": "/-- Ring homomorphisms map zero to zero. -/\ntheorem ∀ {α : Type u_1} {β : Type u_2} {x : NonAssocSemiring α} {x_1 : NonAssocSemiring β} (f : α →+* β), ↑f 0 = 0 :=\n\n/-- A ring isomorphism sends zero to zero. -/\ntheorem ∀ {R : Type u_2} {S : Type u_1} [inst : NonUnitalNonAssocSemiring R] [inst_1 : NonUnitalNonAssocSemiring S]\n  (f : R ≃+* S), ↑f 0 = 0 :=\n\n/-- A morphism that only maps the zero pseudoelement to zero is a monomorphism. -/\ntheorem ∀ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Abelian C] {P Q : C} (f : P ⟶ Q),\n  (∀ (a : CategoryTheory.Abelian.Pseudoelement P), CategoryTheory.Abelian.Pseudoelement.pseudoApply f a = 0 → a = 0) →\n    CategoryTheory.Mono f :=\n\n/-- An additive group homomorphism sends 0 to 0. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : AddGroup α] [inst_1 : AddGroup β] {f : α → β}, IsAddGroupHom f → f 0 = 0 :=\n\n/-- A morphism that is injective on pseudoelements only maps the zero element to zero. -/\ntheorem ∀ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Abelian C] {P Q : C} (f : P ⟶ Q),\n  Function.Injective (CategoryTheory.Abelian.Pseudoelement.pseudoApply f) →\n    ∀ (a : CategoryTheory.Abelian.Pseudoelement P), CategoryTheory.Abelian.Pseudoelement.pseudoApply f a = 0 → a = 0 :=\n\n/-- An element is in the kernel if and only if it maps to zero. -/\ntheorem ∀ {R : Type u} {S : Type v} {F : Type u_1} [inst : Semiring R] [inst_1 : Semiring S] [rcf : RingHomClass F R S] (f : F)\n  {r : R}, r ∈ RingHom.ker f ↔ ↑f r = 0 :=\n\n/-- The zero morphism maps every pseudoelement to 0. -/\ntheorem ∀ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Abelian C] {P : C} (Q : C)\n  (a : CategoryTheory.Abelian.Pseudoelement P), CategoryTheory.Abelian.Pseudoelement.pseudoApply 0 a = 0 :=\n\n/-- A subring of a ring with no zero divisors has no zero divisors. -/\ntheorem ∀ {R : Type u_1} [inst : Ring R] [inst_1 : NoZeroDivisors R] (s : Subring R), NoZeroDivisors { x // x ∈ s } :=\n\n/-- The ring homomorphism is an isometry. -/\ntheorem ∀ {R₁ : Type u_1} {R₂ : Type u_2} [inst : Semiring R₁] [inst_1 : Semiring R₂] [inst_2 : Norm R₁] [inst_3 : Norm R₂]\n  {σ : R₁ →+* R₂} [self : RingHomIsometric σ] {x : R₁}, ‖↑σ x‖ = ‖x‖ :=\n\n/-- In a monoid with zero, if zero equals one, then zero is the only element. -/\ntheorem ∀ {M₀ : Type u_1} [inst : MulZeroOneClass M₀], 0 = 1 → ∀ (a : M₀), a = 0 :=\n\n/-- If two ring homomorphisms are equal on a set, then they are equal on its subring closure. -/\ntheorem ∀ {R : Type u} {S : Type v} [inst : Ring R] [inst_1 : Ring S] {f g : R →+* S} {s : Set R},\n  Set.EqOn (↑f) (↑g) s → Set.EqOn ↑f ↑g ↑(Subring.closure s) :=\n\n/-- A ring is a `ℚ`-algebra iff it has equal characteristic zero. -/\ntheorem ∀ (R : Type u_1) [inst : CommRing R], Nonempty (Algebra ℚ R) ↔ ∀ (I : Ideal R), I ≠ ⊤ → CharZero (R ⧸ I) :=\n\n/-- In a monoid with zero, zero equals one if and only if all elements of that semiring\nare equal. -/\ntheorem ∀ {M₀ : Type u_1} [inst : MulZeroOneClass M₀], 0 = 1 ↔ Subsingleton M₀ :=\n\n/-- If the algebra map `R →+* A` is injective and `R` has characteristic zero then so does `A`. -/\ntheorem ∀ {R : Type u_1} {A : Type u_2} [inst : CommSemiring R] [inst_1 : Semiring A] [inst_2 : Algebra R A],\n  Function.Injective ↑(algebraMap R A) → ∀ [inst : CharZero R], CharZero A :=\n\n/-- Ring homomorphisms map one to one. -/\ntheorem ∀ {α : Type u_1} {β : Type u_2} {x : NonAssocSemiring α} {x_1 : NonAssocSemiring β} (f : α →+* β), ↑f 1 = 1 :=\n\n/-- If two ring homomorphisms are equal on a set, then they are equal on its subfield closure. -/\ntheorem ∀ {K : Type u} {L : Type v} [inst : Field K] [inst_1 : Field L] {f g : K →+* L} {s : Set K},\n  Set.EqOn (↑f) (↑g) s → Set.EqOn ↑f ↑g ↑(Subfield.closure s) :=\n\n/-- In an integral domain, a sum indexed by a nontrivial homomorphism from a finite group is zero. -/\ntheorem ∀ {R : Type u_2} {G : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : Group G] [inst_3 : Fintype G]\n  (f : G →* R), f ≠ 1 → (Finset.sum Finset.univ fun g => ↑f g) = 0 :=\n\n/-- In degree `0`, the null homotopic map `Hσ` is zero. -/\ntheorem ∀ {C : Type u_2} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Preadditive C]\n  {X : CategoryTheory.SimplicialObject C} (q : ℕ), HomologicalComplex.Hom.f (AlgebraicTopology.DoldKan.Hσ q) 0 = 0 :=\n\n/-- If two ring homomorphisms are equal on a set, then they are equal on its subsemiring closure. -/\ntheorem ∀ {R : Type u} {S : Type v} [inst : NonAssocSemiring R] [inst_1 : NonAssocSemiring S] {f g : R →+* S} {s : Set R},\n  Set.EqOn (↑f) (↑g) s → Set.EqOn ↑f ↑g ↑(Subsemiring.closure s) :=\n\n/-- The ring homomorphism is surjective -/\ntheorem ∀ {R₁ : Type u_1} {R₂ : Type u_2} [inst : Semiring R₁] [inst_1 : Semiring R₂] {σ : R₁ →+* R₂}\n  [self : RingHomSurjective σ], Function.Surjective ↑σ :=\n\n/-- If an element maps to zero under a ring homomorphism, then it is zero. -/\ntheorem", "choices": ["∀ {R : Type u} {S : Type v} [inst : Ring R] [inst_1 : Ring S] {f : R →+* S} (x : R), ↑f x = 0 → x = 0 ", "∀ {R : Type u} {S : Type v} [inst : Ring R] [inst_1 : Ring S] {f : R →+* S} {r : R}, ↑f r = 0 → r ∈ RingHom.ker f ", "∀ {α : Type u_1} {β : Type u_2} {x : NonAssocSemiring α} {x_1 : NonAssocSemiring β} (f : α →+* β) (a : α),\n  ↑f a = 0 → a = 0 ", "∀ {α : Type u_1} {β : Type u_2} {x : NonAssocSemiring α} {x_1 : NonAssocSemiring β} (f : α →+* β) (a : α),\n  ↑f a = 0 → a = 0 ", "∀ {R : Type u} {S : Type v} [inst : Ring R] [inst_1 : Ring S] {f : R →+* S} (r : R), (↑f r = 0) → r = 0 ", "∀ {R : Type u} {S : Type v} [inst : NonAssocSemiring R] [inst_1 : NonAssocSemiring S] (f : R →+* S) (a : R),\n  ↑f a = 0 → a = 0 ", "∀ {α : Type u_1} {β : Type u_2} {x : NonAssocSemiring α} {x_1 : NonAssocSemiring β} (f : α →+* β) (a : α),\n  ↑f a = 0 → a = 0 ", "∀ {R : Type u} {S : Type v} [inst : Ring R] [inst_1 : Ring S] {f : R →+* S} {r : R}, ↑f r = 0 → r = 0 ", "∀ {α : Type u_1} {β : Type u_2} {x : NonAssocSemiring α} {x_1 : NonAssocSemiring β} (f : α →+* β) (a : α),\n  ↑f a = 0 → a = 0 ", "∀ {α : Type u_1} {β : Type u_2} {x : NonAssocSemiring α} {x_1 : NonAssocSemiring β} (f : α →+* β) (a : α),\n  ↑f a = 0 → a = 0 "]}
{"docString": "Implication `→` is symmetric. If `P → Q` then `Q → P`.", "prompts": "[{\"theorem\": \"∀ {p q r : Prop}, (p → q) → (q → r) → p → r\",\n  \"isProp\": true,\n  \"docString\":\n  \"Implication `→` is transitive. If `P → Q` and `Q → R` then `P → R`. \"},\n {\"theorem\":\n  \"∀ {α : Sort u} {r : α → α → Prop}, Equivalence r → ∀ {x y : α}, r x y → r y x\",\n  \"isProp\": true,\n  \"docString\":\n  \"An equivalence relation is symmetric: `x ~ y` implies `y ~ x` \"},\n {\"theorem\":\n  \"∀ {C : Type u} [inst : CategoryTheory.Category C] (J : CategoryTheory.GrothendieckTopology C) {D : Type w}\\n  [inst_1 : CategoryTheory.Category D]\\n  [inst_2 :\\n    ∀ (P : CategoryTheory.Functor Cᵒᵖ D) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover J X),\\n      CategoryTheory.Limits.HasMultiequalizer (CategoryTheory.GrothendieckTopology.Cover.index S P)]\\n  (P : CategoryTheory.Functor Cᵒᵖ D)\\n  [inst_3 : ∀ (X : C), CategoryTheory.Limits.HasColimitsOfShape (CategoryTheory.GrothendieckTopology.Cover J X)ᵒᵖ D],\\n  CategoryTheory.GrothendieckTopology.plusMap J (CategoryTheory.GrothendieckTopology.toPlus J P) =\\n    CategoryTheory.GrothendieckTopology.toPlus J (CategoryTheory.GrothendieckTopology.plusObj J P)\",\n  \"isProp\": true,\n  \"docString\": \"`(P ⟶ P⁺)⁺ = P⁺ ⟶ P⁺⁺` \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : Monoid α] {p q : α}, Irreducible p → Irreducible q → p ∣ q → q ∣ p\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` and `q` are irreducible, then `p ∣ q` implies `q ∣ p`. \"},\n {\"theorem\":\n  \"∀ {P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme},\\n  AlgebraicGeometry.PropertyIsLocalAtTarget P → CategoryTheory.MorphismProperty.RespectsIso P\",\n  \"isProp\": true,\n  \"docString\": \"`P` respects isomorphisms. \"},\n {\"theorem\":\n  \"∀ {α : Sort u} {r : α → α → Prop}, Equivalence r → ∀ {x y z : α}, r x y → r y z → r x z\",\n  \"isProp\": true,\n  \"docString\":\n  \"An equivalence relation is transitive: `x ~ y` and `y ~ z` implies `x ~ z` \"},\n {\"theorem\":\n  \"∀ {α : Sort u} {r : α → α → Prop}, Equivalence r → ∀ (x : α), r x x\",\n  \"isProp\": true,\n  \"docString\": \"An equivalence relation is reflexive: `x ~ x` \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} {M : Type u_2} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\\n  [inst_3 : IsNoetherian R M] {P : Submodule R M → Prop},\\n  (∀ (I : Submodule R M), (∀ (J : Submodule R M), J > I → P J) → P I) → ∀ (I : Submodule R M), P I\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `∀ I > J, P I` implies `P J`, then `P` holds for all submodules. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {a b c d : α} [inst : Preorder α], c ≤ a → b ≤ d → a ≤ b → c ≤ d\",\n  \"isProp\": true,\n  \"docString\": \"monotonicity of `≤` with respect to `→` \"},\n {\"theorem\":\n  \"∀ {α : Sort u} {r : α → α → Prop} [self : Antisymm r] {a b : α}, r a b → r b a → a = b\",\n  \"isProp\": true,\n  \"docString\":\n  \"An antisymmetric relation `(·≤·)` satisfies `a ≤ b → b ≤ a → a = b`. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [self : BooleanAlgebra α] (x y : α), x ⇨ y = y ⊔ xᶜ\",\n  \"isProp\": true,\n  \"docString\": \"`x ⇨ y` is equal to `y ⊔ xᶜ` \"},\n {\"theorem\":\n  \"∀ {P : AlgebraicGeometry.AffineTargetMorphismProperty},\\n  AlgebraicGeometry.AffineTargetMorphismProperty.IsLocal P →\\n    CategoryTheory.MorphismProperty.RespectsIso (AlgebraicGeometry.AffineTargetMorphismProperty.toProperty P)\",\n  \"isProp\": true,\n  \"docString\": \"`P` as a morphism property respects isomorphisms \"},\n {\"theorem\":\n  \"∀ {M : Type u_1} [inst : Mul M] (c : Con M) {x y : M}, ↑c x y → ↑c y x\",\n  \"isProp\": true,\n  \"docString\": \"Congruence relations are symmetric. \"},\n {\"theorem\":\n  \"∀ {P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme},\\n  AlgebraicGeometry.PropertyIsLocalAtTarget P →\\n    ∀ {X Y : AlgebraicGeometry.Scheme} (f : X ⟶ Y) (U : TopologicalSpace.Opens ↑↑Y.toPresheafedSpace), P f → P (f ∣_ U)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `P` holds for `f : X ⟶ Y`, then `P` holds for `f ∣_ U` for any `U`. \"},\n {\"theorem\":\n  \"∀ {F : Type u_1} {α : outParam (Type u_2)} {β : outParam (Type u_3)} [inst : HeytingAlgebra α]\\n  [inst_1 : HeytingAlgebra β] [self : HeytingHomClass F α β] (f : F) (a b : α), ↑f (a ⇨ b) = ↑f a ⇨ ↑f b\",\n  \"isProp\": true,\n  \"docString\":\n  \"The proposition that a Heyting homomorphism preserves the Heyting implication.\"},\n {\"theorem\":\n  \"∀ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M] (S T : Submodule R M),\\n  T ≤ S →\\n    ∀ [inst_3 : DecidablePred fun x => x ∈ Submodule.map (Submodule.mkQ T) S] [inst_4 : Fintype (M ⧸ S)]\\n      [inst_5 : Fintype (M ⧸ T)],\\n      Fintype.card { x // x ∈ Submodule.map (Submodule.mkQ T) S } * Fintype.card (M ⧸ S) = Fintype.card (M ⧸ T)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Corollary of the third isomorphism theorem: `[S : T] [M : S] = [M : T]` \"},\n {\"theorem\":\n  \"∀ {M : Type u_1} [inst : Add M] (c : AddCon M) {x y : M}, ↑c x y → ↑c y x\",\n  \"isProp\": true,\n  \"docString\": \"Additive congruence relations are symmetric.\"},\n {\"theorem\":\n  \"∀ {C : Type u} [inst : CategoryTheory.Category C] {A B : C} {f g : A ⟶ B} [inst_1 : CategoryTheory.IsReflexivePair f g],\\n  CategoryTheory.IsReflexivePair g f\",\n  \"isProp\": true,\n  \"docString\": \"If `f,g` is reflexive, then `g,f` is reflexive. \"},\n {\"theorem\":\n  \"∀ {F : Type u_1} {α : outParam (Type u_2)} {β : outParam (Type u_3)} [inst : BiheytingAlgebra α]\\n  [inst_1 : BiheytingAlgebra β] [self : BiheytingHomClass F α β] (f : F) (a b : α), ↑f (a ⇨ b) = ↑f a ⇨ ↑f b\",\n  \"isProp\": true,\n  \"docString\":\n  \"The proposition that a bi-Heyting homomorphism preserves the Heyting implication.\"},\n {\"theorem\":\n  \"∀ {α : Type u_2} {n : Type u_1} [inst : AddGroup n] {v : n → α},\\n  Matrix.IsSymm (Matrix.circulant v) → ∀ (i : n), v (-i) = v i\",\n  \"isProp\": true,\n  \"docString\": \"If `circulant v` is symmetric, `∀ i j : I, v (- i) = v i`. \"}]\n", "prompt_cons": "/-- Implication `→` is transitive. If `P → Q` and `Q → R` then `P → R`. -/\ntheorem ∀ {p q r : Prop}, (p → q) → (q → r) → p → r :=\n\n/-- An equivalence relation is symmetric: `x ~ y` implies `y ~ x` -/\ntheorem ∀ {α : Sort u} {r : α → α → Prop}, Equivalence r → ∀ {x y : α}, r x y → r y x :=\n\n/-- `(P ⟶ P⁺)⁺ = P⁺ ⟶ P⁺⁺` -/\ntheorem ∀ {C : Type u} [inst : CategoryTheory.Category C] (J : CategoryTheory.GrothendieckTopology C) {D : Type w}\n  [inst_1 : CategoryTheory.Category D]\n  [inst_2 :\n    ∀ (P : CategoryTheory.Functor Cᵒᵖ D) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover J X),\n      CategoryTheory.Limits.HasMultiequalizer (CategoryTheory.GrothendieckTopology.Cover.index S P)]\n  (P : CategoryTheory.Functor Cᵒᵖ D)\n  [inst_3 : ∀ (X : C), CategoryTheory.Limits.HasColimitsOfShape (CategoryTheory.GrothendieckTopology.Cover J X)ᵒᵖ D],\n  CategoryTheory.GrothendieckTopology.plusMap J (CategoryTheory.GrothendieckTopology.toPlus J P) =\n    CategoryTheory.GrothendieckTopology.toPlus J (CategoryTheory.GrothendieckTopology.plusObj J P) :=\n\n/-- If `p` and `q` are irreducible, then `p ∣ q` implies `q ∣ p`. -/\ntheorem ∀ {α : Type u_1} [inst : Monoid α] {p q : α}, Irreducible p → Irreducible q → p ∣ q → q ∣ p :=\n\n/-- `P` respects isomorphisms. -/\ntheorem ∀ {P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme},\n  AlgebraicGeometry.PropertyIsLocalAtTarget P → CategoryTheory.MorphismProperty.RespectsIso P :=\n\n/-- An equivalence relation is transitive: `x ~ y` and `y ~ z` implies `x ~ z` -/\ntheorem ∀ {α : Sort u} {r : α → α → Prop}, Equivalence r → ∀ {x y z : α}, r x y → r y z → r x z :=\n\n/-- An equivalence relation is reflexive: `x ~ x` -/\ntheorem ∀ {α : Sort u} {r : α → α → Prop}, Equivalence r → ∀ (x : α), r x x :=\n\n/-- If `∀ I > J, P I` implies `P J`, then `P` holds for all submodules. -/\ntheorem ∀ {R : Type u_1} {M : Type u_2} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\n  [inst_3 : IsNoetherian R M] {P : Submodule R M → Prop},\n  (∀ (I : Submodule R M), (∀ (J : Submodule R M), J > I → P J) → P I) → ∀ (I : Submodule R M), P I :=\n\n/-- monotonicity of `≤` with respect to `→` -/\ntheorem ∀ {α : Type u} {a b c d : α} [inst : Preorder α], c ≤ a → b ≤ d → a ≤ b → c ≤ d :=\n\n/-- An antisymmetric relation `(·≤·)` satisfies `a ≤ b → b ≤ a → a = b`. -/\ntheorem ∀ {α : Sort u} {r : α → α → Prop} [self : Antisymm r] {a b : α}, r a b → r b a → a = b :=\n\n/-- `x ⇨ y` is equal to `y ⊔ xᶜ` -/\ntheorem ∀ {α : Type u} [self : BooleanAlgebra α] (x y : α), x ⇨ y = y ⊔ xᶜ :=\n\n/-- `P` as a morphism property respects isomorphisms -/\ntheorem ∀ {P : AlgebraicGeometry.AffineTargetMorphismProperty},\n  AlgebraicGeometry.AffineTargetMorphismProperty.IsLocal P →\n    CategoryTheory.MorphismProperty.RespectsIso (AlgebraicGeometry.AffineTargetMorphismProperty.toProperty P) :=\n\n/-- Congruence relations are symmetric. -/\ntheorem ∀ {M : Type u_1} [inst : Mul M] (c : Con M) {x y : M}, ↑c x y → ↑c y x :=\n\n/-- If `P` holds for `f : X ⟶ Y`, then `P` holds for `f ∣_ U` for any `U`. -/\ntheorem ∀ {P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme},\n  AlgebraicGeometry.PropertyIsLocalAtTarget P →\n    ∀ {X Y : AlgebraicGeometry.Scheme} (f : X ⟶ Y) (U : TopologicalSpace.Opens ↑↑Y.toPresheafedSpace), P f → P (f ∣_ U) :=\n\n/-- The proposition that a Heyting homomorphism preserves the Heyting implication. -/\ntheorem ∀ {F : Type u_1} {α : outParam (Type u_2)} {β : outParam (Type u_3)} [inst : HeytingAlgebra α]\n  [inst_1 : HeytingAlgebra β] [self : HeytingHomClass F α β] (f : F) (a b : α), ↑f (a ⇨ b) = ↑f a ⇨ ↑f b :=\n\n/-- Corollary of the third isomorphism theorem: `[S : T] [M : S] = [M : T]` -/\ntheorem ∀ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M] (S T : Submodule R M),\n  T ≤ S →\n    ∀ [inst_3 : DecidablePred fun x => x ∈ Submodule.map (Submodule.mkQ T) S] [inst_4 : Fintype (M ⧸ S)]\n      [inst_5 : Fintype (M ⧸ T)],\n      Fintype.card { x // x ∈ Submodule.map (Submodule.mkQ T) S } * Fintype.card (M ⧸ S) = Fintype.card (M ⧸ T) :=\n\n/-- Additive congruence relations are symmetric. -/\ntheorem ∀ {M : Type u_1} [inst : Add M] (c : AddCon M) {x y : M}, ↑c x y → ↑c y x :=\n\n/-- If `f,g` is reflexive, then `g,f` is reflexive. -/\ntheorem ∀ {C : Type u} [inst : CategoryTheory.Category C] {A B : C} {f g : A ⟶ B} [inst_1 : CategoryTheory.IsReflexivePair f g],\n  CategoryTheory.IsReflexivePair g f :=\n\n/-- The proposition that a bi-Heyting homomorphism preserves the Heyting implication. -/\ntheorem ∀ {F : Type u_1} {α : outParam (Type u_2)} {β : outParam (Type u_3)} [inst : BiheytingAlgebra α]\n  [inst_1 : BiheytingAlgebra β] [self : BiheytingHomClass F α β] (f : F) (a b : α), ↑f (a ⇨ b) = ↑f a ⇨ ↑f b :=\n\n/-- If `circulant v` is symmetric, `∀ i j : I, v (- i) = v i`. -/\ntheorem ∀ {α : Type u_2} {n : Type u_1} [inst : AddGroup n] {v : n → α},\n  Matrix.IsSymm (Matrix.circulant v) → ∀ (i : n), v (-i) = v i :=\n\n/-- Implication `→` is symmetric. If `P → Q` then `Q → P`. -/\ntheorem", "choices": ["Sorry, but the statement \"Implication `→` is symmetric. If `P → Q` then `Q → P`.\" is not true. The correct statement would be \"Implication `→` is contrapositive. If `P → Q`, then `¬Q → ¬P`.\"", "This statement is incorrect. Implication `→` is not symmetric.", "Implication is not symmetric. This statement is incorrect and cannot be proved.", "Sorry, but the given statement is incorrect. Implication `→` is not symmetric. If `P → Q`, it doesn't necessarily mean that `Q → P`.", "Sorry, but the statement \"Implication `→` is symmetric. If `P → Q` then `Q → P`.\" is incorrect. Implication `→` is not symmetric in general. The correct property for implication is: if `P → Q` and `P` then `Q`.", "This statement is incorrect. Implication is not symmetric. There is no theorem for this.", "Sorry, but the statement \"Implication `→` is symmetric. If `P → Q` then `Q → P`.\" is incorrect. Implication `→` is not symmetric in general.", "This statement is incorrect, as implication is not symmetric. Implication is only transitive and right-distributive over conjunction.", "This statement is incorrect, as implication `→` is not symmetric. However, I can provide you with a theorem stating that if `P ↔ Q` then `Q ↔ P`:\n\n/-- If `P ↔ Q` then `Q ↔ P` -/\ntheorem ∀ {p q : Prop}, (p ↔ q) → (q ↔ p) ", "This statement is incorrect. Implication `→` is not symmetric. Please provide a correct statement to prove."]}
{"docString": "Two natural numbers are equal if and only if they are both divisible by some prime number.", "prompts": "[{\"theorem\": \"∀ {m n : ℕ}, (∀ (a : ℕ), a ∣ m ↔ a ∣ n) ↔ m = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two natural numbers are equal if and only if they have the same divisors. \"},\n {\"theorem\": \"∀ {m n : ℕ}, (∀ (a : ℕ), m ∣ a ↔ n ∣ a) ↔ m = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two natural numbers are equal if and only if they have the same multiples. \"},\n {\"theorem\": \"∀ {a b : ℕ}, a ∣ b → b < a → b = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a small natural number is divisible by a larger natural number,\\nthe small number is zero. \"},\n {\"theorem\": \"∀ {m n : ℕ}, m ∣ m + n ↔ m ∣ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"A natural number `m` divides the sum `m + n` if and only if `m` divides `n`.\"},\n {\"theorem\": \"Set.InjOn Nat.factorization {x | x ≠ 0}\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every nonzero natural number has a unique prime factorization \"},\n {\"theorem\": \"∀ {m n : ℕ}, m ∣ n + m ↔ m ∣ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"A natural number `m` divides the sum `n + m` if and only if `m` divides `n`.\"},\n {\"theorem\": \"∀ (p : ℕ) [inst : Fact (Nat.Prime p)], Prime ↑p ↔ p % 4 = 3\",\n  \"isProp\": true,\n  \"docString\":\n  \"A prime natural number is prime in `ℤ[i]` if and only if it is `3` mod `4` \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : CancelCommMonoidWithZero α] [dec_irr : (p : Associates α) → Decidable (Irreducible p)]\\n  [inst_1 : UniqueFactorizationMonoid α] [dec : DecidableEq α] [dec' : DecidableEq (Associates α)] {a p : Associates α},\\n  Irreducible p →\\n    ∀ [inst_2 : (n : ℕ) → Decidable (a ∣ p ^ n)] {n : ℕ} (h : a ∣ p ^ n),\\n      a = p ^ Nat.find (_ : ∃ n, (fun n => a ∣ p ^ n) n)\",\n  \"isProp\": true,\n  \"docString\": \"The only divisors of prime powers are prime powers. \"},\n {\"theorem\":\n  \"∀ {a b c : ℤ}, a % b = c → Int.natAbs (a - c) < Int.natAbs b → a = c\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two integers are congruent to a sufficiently large modulus,\\nthey are equal. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : CancelCommMonoidWithZero α] [self : GCDMonoid α] {a b c : α}, a ∣ c → a ∣ b → a ∣ gcd c b\",\n  \"isProp\": true,\n  \"docString\": \"Any common divisor of both elements is a divisor of the GCD. \"},\n {\"theorem\":\n  \"∀ {a b x y u v : ℕ}, a = x ^ 2 + y ^ 2 → b = u ^ 2 + v ^ 2 → ∃ r s, a * b = r ^ 2 + s ^ 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of natural numbers that are sums of two squares is closed under multiplication. \"},\n {\"theorem\":\n  \"∀ (a b : ℕ), a ≠ 0 → b ≠ 0 → (a = b ↔ ∀ (p : ℕ), Nat.Prime p → padicValNat p a = padicValNat p b)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two positive naturals are equal if their prime padic valuations are equal \"},\n {\"theorem\":\n  \"∀ {n : ℕ}, n ≠ 0 → ∀ (d : ℕ), ∃ᶠ (m : ℕ) in Filter.atTop, m ≡ d [MOD n]\",\n  \"isProp\": true,\n  \"docString\": \"Infinitely many natural numbers are equal to `d` mod `n`. \"},\n {\"theorem\": \"∀ (self : ℚ), Nat.coprime (Int.natAbs self.num) self.den\",\n  \"isProp\": true,\n  \"docString\":\n  \"The numerator and denominator are coprime: it is in \\\"reduced form\\\". \"},\n {\"theorem\": \"∀ (n : ℕ), Nat.factorization n = 0 ↔ n = 0 ∨ n = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The only numbers with empty prime factorization are `0` and `1` \"},\n {\"theorem\": \"∀ (n : ℕ), PGame.Numeric ↑n\",\n  \"isProp\": true,\n  \"docString\": \"Pre-games defined by natural numbers are numeric. \"},\n {\"theorem\":\n  \"∀ {c d : Cardinal.{u_1}}, c < Cardinal.aleph0 → d < Cardinal.aleph0 → (↑Cardinal.toNat c = ↑Cardinal.toNat d ↔ c = d)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two finite cardinals are equal iff they are equal their to_nat are equal \"},\n {\"theorem\": \"∀ {a b : ℤ}, a ∣ b → Int.natAbs b < Int.natAbs a → b = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If an integer with larger absolute value divides an integer, it is\\nzero. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : CommRing R] [inst_1 : Fintype R] (p : ℕ) [inst_2 : Fact (Nat.Prime p)],\\n  p ∣ ringChar R ↔ p ∣ Fintype.card R\",\n  \"isProp\": true,\n  \"docString\":\n  \"The prime divisors of the characteristic of a finite commutative ring are exactly\\nthe prime divisors of its cardinality. \"},\n {\"theorem\": \"∀ {α : Type u_1} [inst : Ring α] {a b : α}, a ∣ a + b ↔ a ∣ b\",\n  \"isProp\": true,\n  \"docString\":\n  \"An element a divides the sum a + b if and only if a divides b.\"}]\n", "prompt_cons": "/-- Two natural numbers are equal if and only if they have the same divisors. -/\ntheorem ∀ {m n : ℕ}, (∀ (a : ℕ), a ∣ m ↔ a ∣ n) ↔ m = n :=\n\n/-- Two natural numbers are equal if and only if they have the same multiples. -/\ntheorem ∀ {m n : ℕ}, (∀ (a : ℕ), m ∣ a ↔ n ∣ a) ↔ m = n :=\n\n/-- If a small natural number is divisible by a larger natural number,\nthe small number is zero. -/\ntheorem ∀ {a b : ℕ}, a ∣ b → b < a → b = 0 :=\n\n/-- A natural number `m` divides the sum `m + n` if and only if `m` divides `n`. -/\ntheorem ∀ {m n : ℕ}, m ∣ m + n ↔ m ∣ n :=\n\n/-- Every nonzero natural number has a unique prime factorization -/\ntheorem Set.InjOn Nat.factorization {x | x ≠ 0} :=\n\n/-- A natural number `m` divides the sum `n + m` if and only if `m` divides `n`. -/\ntheorem ∀ {m n : ℕ}, m ∣ n + m ↔ m ∣ n :=\n\n/-- A prime natural number is prime in `ℤ[i]` if and only if it is `3` mod `4` -/\ntheorem ∀ (p : ℕ) [inst : Fact (Nat.Prime p)], Prime ↑p ↔ p % 4 = 3 :=\n\n/-- The only divisors of prime powers are prime powers. -/\ntheorem ∀ {α : Type u_1} [inst : CancelCommMonoidWithZero α] [dec_irr : (p : Associates α) → Decidable (Irreducible p)]\n  [inst_1 : UniqueFactorizationMonoid α] [dec : DecidableEq α] [dec' : DecidableEq (Associates α)] {a p : Associates α},\n  Irreducible p →\n    ∀ [inst_2 : (n : ℕ) → Decidable (a ∣ p ^ n)] {n : ℕ} (h : a ∣ p ^ n),\n      a = p ^ Nat.find (_ : ∃ n, (fun n => a ∣ p ^ n) n) :=\n\n/-- If two integers are congruent to a sufficiently large modulus,\nthey are equal. -/\ntheorem ∀ {a b c : ℤ}, a % b = c → Int.natAbs (a - c) < Int.natAbs b → a = c :=\n\n/-- Any common divisor of both elements is a divisor of the GCD. -/\ntheorem ∀ {α : Type u_1} [inst : CancelCommMonoidWithZero α] [self : GCDMonoid α] {a b c : α}, a ∣ c → a ∣ b → a ∣ gcd c b :=\n\n/-- The set of natural numbers that are sums of two squares is closed under multiplication. -/\ntheorem ∀ {a b x y u v : ℕ}, a = x ^ 2 + y ^ 2 → b = u ^ 2 + v ^ 2 → ∃ r s, a * b = r ^ 2 + s ^ 2 :=\n\n/-- Two positive naturals are equal if their prime padic valuations are equal -/\ntheorem ∀ (a b : ℕ), a ≠ 0 → b ≠ 0 → (a = b ↔ ∀ (p : ℕ), Nat.Prime p → padicValNat p a = padicValNat p b) :=\n\n/-- Infinitely many natural numbers are equal to `d` mod `n`. -/\ntheorem ∀ {n : ℕ}, n ≠ 0 → ∀ (d : ℕ), ∃ᶠ (m : ℕ) in Filter.atTop, m ≡ d [MOD n] :=\n\n/-- The numerator and denominator are coprime: it is in \"reduced form\". -/\ntheorem ∀ (self : ℚ), Nat.coprime (Int.natAbs self.num) self.den :=\n\n/-- The only numbers with empty prime factorization are `0` and `1` -/\ntheorem ∀ (n : ℕ), Nat.factorization n = 0 ↔ n = 0 ∨ n = 1 :=\n\n/-- Pre-games defined by natural numbers are numeric. -/\ntheorem ∀ (n : ℕ), PGame.Numeric ↑n :=\n\n/-- Two finite cardinals are equal iff they are equal their to_nat are equal -/\ntheorem ∀ {c d : Cardinal.{u_1}}, c < Cardinal.aleph0 → d < Cardinal.aleph0 → (↑Cardinal.toNat c = ↑Cardinal.toNat d ↔ c = d) :=\n\n/-- If an integer with larger absolute value divides an integer, it is\nzero. -/\ntheorem ∀ {a b : ℤ}, a ∣ b → Int.natAbs b < Int.natAbs a → b = 0 :=\n\n/-- The prime divisors of the characteristic of a finite commutative ring are exactly\nthe prime divisors of its cardinality. -/\ntheorem ∀ {R : Type u_1} [inst : CommRing R] [inst_1 : Fintype R] (p : ℕ) [inst_2 : Fact (Nat.Prime p)],\n  p ∣ ringChar R ↔ p ∣ Fintype.card R :=\n\n/-- An element a divides the sum a + b if and only if a divides b. -/\ntheorem ∀ {α : Type u_1} [inst : Ring α] {a b : α}, a ∣ a + b ↔ a ∣ b :=\n\n/-- Two natural numbers are equal if and only if they are both divisible by some prime number. -/\ntheorem", "choices": ["∀ {m n : ℕ}, (∃ (p : ℕ), Nat.Prime p ∧ p ∣ m ∧ p ∣ n) ↔ m = n ", "∀ {m n : ℕ}, (∃ (p : ℕ), Nat.Prime p ∧ p ∣ m ∧ p ∣ n) ↔ m = n ", "∀ {m n : ℕ}, (∃ (p : ℕ), Nat.Prime p ∧ p ∣ m ∧ p ∣ n) ↔ m = n ", "∀ {m n : ℕ}, (∃ (p : ℕ), Nat.Prime p ∧ p ∣ m ∧ p ∣ n) ↔ m = n ", "∀ {m n : ℕ}, (∃ (p : ℕ), Nat.Prime p ∧ p ∣ m ∧ p ∣ n) ↔ m = n ", "∀ {m n : ℕ}, (∃ (p : ℕ), Nat.Prime p ∧ (p ∣ m ↔ p ∣ n)) ↔ m = n ", "∀ {m n : ℕ}, (∃ (p : ℕ), Nat.Prime p ∧ p ∣ m ∧ p ∣ n) ↔ m = n ", "∀ {m n : ℕ}, (∃ (p : ℕ), Nat.Prime p ∧ p ∣ m ∧ p ∣ n) ↔ m = n ", "∀ {m n : ℕ}, (∃ (p : ℕ), Nat.Prime p ∧ p ∣ m ∧ p ∣ n) ↔ m = n ", "∀ {m n : ℕ}, (∃ (p : ℕ), Nat.Prime p ∧ p ∣ m ∧ p ∣ n) ↔ m = n "]}
