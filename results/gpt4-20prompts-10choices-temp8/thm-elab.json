{"total-prompts": 40,
 "temperature": 0.8,
 "query-number": 5,
 "number-similar-sentences": 10,
 "include-fixed": false,
 "failures":
 ["The number of partitions with odd parts is equal to the number of partitions with distinct parts.",
  "A group whose automorphism group is cyclic is Abelian.",
  "Every matrix satisfies its own characteristic polynomial.",
  "If the direct product of two groups is torsion free then each of the groups is torsion free."],
 "elaborated-prompts":
 [{"theorem":
   "∀ {α : Type u} [inst : TopologicalSpace α], (∀ (s : Set α), IsClosed s → s ≠ ⊤ → IsCompact s) → CompactSpace α",
   "some-correct": null,
   "prompt":
   "If every proper closed subset of a topological space is compact, then the space itself is compact.",
   "groups":
   [["∀ {α : Type u} [inst : TopologicalSpace α], (∀ (s : Set α), IsClosed s → s ≠ ⊤ → IsCompact s) → CompactSpace α"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u} [inst : TopologicalSpace α], (∀ (s : Set α), IsClosed s → s ≠ ⊤ → IsCompact s) → CompactSpace α "]},
  {"theorem":
   "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 4 = 1 → ∃ a b, a ^ 2 + b ^ 2 = p",
   "some-correct": null,
   "prompt":
   "Every prime that is `1` greater than a multiple of `4` can be expressed as the sum of two squares.",
   "groups":
   [["∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 4 = 1 → ∃ a b, a ^ 2 + b ^ 2 = p",
     "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 4 = 1 → ∃ a b, a ^ 2 + b ^ 2 = p",
     "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 4 = 1 → ∃ a b, a ^ 2 + b ^ 2 = p",
     "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 4 = 1 → ∃ a b, a ^ 2 + b ^ 2 = p",
     "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 4 = 1 → ∃ a b, a ^ 2 + b ^ 2 = p",
     "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 4 = 1 → ∃ a b, a ^ 2 + b ^ 2 = p",
     "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 4 = 1 → ∃ a b, a ^ 2 + b ^ 2 = p",
     "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 4 = 1 → ∃ a b, a ^ 2 + b ^ 2 = p",
     "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 4 = 1 → ∃ a b, a ^ 2 + b ^ 2 = p",
     "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 4 = 1 → ∃ a b, a ^ 2 + b ^ 2 = p"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   ["∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 4 = 1 → ∃ a b, a ^ 2 + b ^ 2 = p ",
    "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 4 = 1 → ∃ a b, a ^ 2 + b ^ 2 = p ",
    "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 4 = 1 → ∃ a b, a ^ 2 + b ^ 2 = p ",
    "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 4 = 1 → ∃ a b, a ^ 2 + b ^ 2 = p ",
    "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 4 = 1 → ∃ a b, a ^ 2 + b ^ 2 = p ",
    "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 4 = 1 → ∃ a b, a ^ 2 + b ^ 2 = p ",
    "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 4 = 1 → ∃ a b, a ^ 2 + b ^ 2 = p ",
    "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 4 = 1 → ∃ a b, a ^ 2 + b ^ 2 = p ",
    "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 4 = 1 → ∃ a b, a ^ 2 + b ^ 2 = p ",
    "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 4 = 1 → ∃ a b, a ^ 2 + b ^ 2 = p "]},
  {"theorem":
   "∀ {a b x y u v r s : ℕ},\n  a = x ^ 2 + y ^ 2 + r ^ 2 + s ^ 2 →\n    b = u ^ 2 + v ^ 2 + r ^ 2 + s ^ 2 → ∃ p q t w, a * b = p ^ 2 + q ^ 2 + t ^ 2 + w ^ 2",
   "some-correct": null,
   "prompt":
   "The product of two numbers, each of which is the sum of four squares, is itself a sum of four squares.",
   "groups":
   [["∀ {a b x y u v r s : ℕ},\n  a = x ^ 2 + y ^ 2 + r ^ 2 + s ^ 2 →\n    b = u ^ 2 + v ^ 2 + r ^ 2 + s ^ 2 → ∃ p q t w, a * b = p ^ 2 + q ^ 2 + t ^ 2 + w ^ 2",
     "∀ {a b x y u v r s : ℕ},\n  a = x ^ 2 + y ^ 2 + r ^ 2 + s ^ 2 →\n    b = u ^ 2 + v ^ 2 + r ^ 2 + s ^ 2 → ∃ p q r s, a * b = p ^ 2 + q ^ 2 + r ^ 2 + s ^ 2",
     "∀ {a b r s x y u v : ℕ},\n  a = x ^ 2 + y ^ 2 + r ^ 2 + s ^ 2 →\n    b = u ^ 2 + v ^ 2 + r ^ 2 + s ^ 2 → ∃ w x y z, a * b = w ^ 2 + x ^ 2 + y ^ 2 + z ^ 2"],
    ["∀ {a b x y u v : ℕ},\n  a = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 →\n    b = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 → ∃ r s t w, a * b = r ^ 2 + s ^ 2 + t ^ 2 + w ^ 2",
     "∀ {a b x y u v : ℕ},\n  a = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 →\n    b = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 → ∃ r s t w, a * b = r ^ 2 + s ^ 2 + t ^ 2 + w ^ 2",
     "∀ {a b x y u v : ℕ},\n  a = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 →\n    b = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 → ∃ r s t w, a * b = r ^ 2 + s ^ 2 + t ^ 2 + w ^ 2"],
    ["∀ {a b : ℕ}, ∃ x y z w, a * b = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2",
     "∀ (a b : ℕ), ∃ x y z w, a * b = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2"],
    ["∀ {m n : ℕ},\n  ∃ a b c d x y z w,\n    m = a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 ∧ n = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 →\n      m * n =\n        (a * x + b * y + c * z + d * w) ^ 2 + (a * y - b * x - c * w + d * z) ^ 2 +\n            (a * z + b * w - c * x - d * y) ^ 2 +\n          (a * w - b * z + c * y - d * x) ^ 2"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   ["forall {m n : ℕ}, ∃ a b c d x y z w,\n  m = a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 ∧ n = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 →\n  m * n = (a * x + b * y + c * z + d * w) ^ 2 + (a * y - b * x - c * w + d * z) ^ 2 +\n          (a * z + b * w - c * x - d * y) ^ 2 + (a * w - b * z + c * y - d * x) ^ 2 ",
    "∀ {a b x y u v : ℕ}, a = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 → b = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 → ∃ r s t w, a * b = r ^ 2 + s ^ 2 + t ^ 2 + w ^ 2 ",
    "∀ {a b x y u v : ℕ}, a = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 → b = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 → ∃ r s t w, a * b = r ^ 2 + s ^ 2 + t ^ 2 + w ^ 2 ",
    "∀ {a b : ℕ}, ∃ x y z w, a * b = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 ",
    "∀ {a b x y u v r s : ℕ},\n  a = x ^ 2 + y ^ 2 + r ^ 2 + s ^ 2 → b = u ^ 2 + v ^ 2 + r ^ 2 + s ^ 2 →\n  ∃ p q t w, a * b = p ^ 2 + q ^ 2 + t ^ 2 + w ^ 2 ",
    "∀ {a b x y u v r s : ℕ}, a = x ^ 2 + y ^ 2 + r ^ 2 + s ^ 2 → b = u ^ 2 + v ^ 2 + r ^ 2 + s ^ 2 → ∃ p q r s, a * b = p ^ 2 + q ^ 2 + r ^ 2 + s ^ 2 ",
    "∀ (a b : ℕ), ∃ x y z w, a * b = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 ",
    "∀ {a b x y u v : ℕ}, a = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 → b = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 → ∃ r s t w, a * b = r ^ 2 + s ^ 2 + t ^ 2 + w ^ 2 ",
    "forall {a₀ a₁ a₂ a₃ b₀ b₁ b₂ b₃ : ℤ}, ∃ c₀ c₁ c₂ c₃, (a₀ ^ 2 + a₁ ^ 2 + a₂ ^ 2 + a₃ ^ 2) * (b₀ ^ 2 + b₁ ^ 2 + b₂ ^ 2 + b₃ ^ 2) = c₀ ^ 2 + c₁ ^ 2 + c₂ ^ 2 + c₃ ^ 2 ",
    "∀ {a b r s x y u v : ℕ},\n  a = x ^ 2 + y ^ 2 + r ^ 2 + s ^ 2 →\n  b = u ^ 2 + v ^ 2 + r ^ 2 + s ^ 2 →\n  ∃ w x y z, a * b = w ^ 2 + x ^ 2 + y ^ 2 + z ^ 2 "]},
  {"theorem":
   "∀ {R : Type u_1} [inst : Ring R], (∀ (a : R), a * a = a) → ∀ (x y : R), x * y = y * x",
   "some-correct": null,
   "prompt": "A ring with all elements idempotent is commutative.",
   "groups":
   [["∀ {R : Type u_1} [inst : Ring R], (∀ (a : R), a * a = a) → ∀ (x y : R), x * y = y * x"],
    ["∀ {α : Type u_1} [self : BooleanRing α] (x y : α), x * y = y * x"],
    ["∀ {α : Type u_1} [self : Mul α] [inst : Add α], (∀ (a : α), a * a = a) → ∀ (x y : α), x * y = y * x"],
    ["∀ {R : Type u_1} [inst : MulOneClass R] [inst_1 : HasDistribNeg R] [inst_2 : Add R] [inst_3 : AddCommMonoid R],\n  (∀ (x : R), x * x = x) → ∀ (x y : R), x * y = y * x"],
    ["∀ {R : Type u_1} [self : Semiring R], (∀ (x : R), x * x = x) → ∀ (x y : R), x * y = y * x"],
    ["∀ {R : Type u_1} [inst : Mul R] [inst_1 : Add R] [inst_2 : One R] [inst_3 : Zero R],\n  (∀ (a : R), a * a = a) → ∀ (a b : R), a * b = b * a"],
    ["∀ {α : Type u_1} [self : MulOneClass α] [inst_1 : AddCommGroup α], (∀ (a : α), a * a = a) → ∀ (x y : α), x * y = y * x"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u_1} [self : BooleanRing α], ∀ (x y : α), x * y = y * x ",
    "∀ {α : Type u_1} [self : Mul α] [inst : Add α] (h : ∀ (a : α), a * a = a), ∀ (x y : α), x * y = y * x ",
    "∀ {R : Type u_1} [inst : MulOneClass R] [inst_1 : HasDistribNeg R] [inst_2 : Add R] [inst_3 : AddCommMonoid R],\n  (∀ (x : R), x * x = x) → (∀ (x y : R), x * y = y * x) ",
    "∀ {R : Type u_1} [self : Semiring R], (∀ (x : R), x * x = x) → ∀ (x y : R), x * y = y * x ",
    "∀ {R : Type u_1} [inst : Mul R] [inst_1 : Add R] [inst_2 : One R] [inst_3 : Zero R],\n  (∀ (a : R), a * a = a) → ∀ (a b : R), a * b = b * a ",
    "∀ {α : Type u_1} [self : MulOneClass α] [inst_1 : AddCommGroup α] (h : ∀ (a : α), a * a = a), ∀ (x y : α), x * y = y * x ",
    "∀ {R : Type u_1} [inst : Ring R], (∀ (a : R), a * a = a) → ∀ (x y : R), x * y = y * x "]},
  {"theorem": "Set.Infinite {p | Nat.Prime p ∧ Nat.Prime (p + 2)}",
   "some-correct": null,
   "prompt":
   "There are infinitely many pairs of primes that differ exactly by `2`.",
   "groups":
   [["Set.Infinite {p | Nat.Prime p ∧ Nat.Prime (p + 2)}",
     "Set.Infinite {p | Nat.Prime p ∧ Nat.Prime (p + 2)}",
     "Set.Infinite {p | Nat.Prime p ∧ ∃ q, Nat.Prime q ∧ p + 2 = q}",
     "Set.Infinite {p | Nat.Prime p ∧ Nat.Prime (p + 2)}",
     "Set.Infinite {p | Nat.Prime p ∧ Nat.Prime (p + 2)}",
     "Set.Infinite {p | Nat.Prime p ∧ Nat.Prime (p + 2)}"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   ["Set.Infinite {p : ℕ | Nat.Prime p ∧ Nat.Prime (p + 2)} ",
    "Set.Infinite {p | Nat.Prime p ∧ Nat.Prime (p + 2)} ",
    "Set.Infinite {p | Nat.Prime p ∧ ∃ q, Nat.Prime q ∧ p + 2 = q} ",
    "Set.Infinite {p : ℕ | Nat.Prime p ∧ Nat.Prime (p + 2)} ",
    "Set.Infinite {p | Nat.Prime p ∧ Nat.Prime (p + 2)} ",
    "Set.Infinite {p | Nat.Prime p ∧ Nat.Prime (p + 2)} "]},
  {"theorem":
   "{K : Type u_1} → [inst : DivisionRing K] → [inst_1 : Fintype K] → Field K",
   "some-correct": null,
   "prompt": "Every finite division ring is a field.",
   "groups":
   [["{K : Type u_1} → [inst : DivisionRing K] → [inst_1 : Fintype K] → Field K",
     "{K : Type u_1} → [inst : DivisionRing K] → [inst_1 : Fintype K] → Field K",
     "{K : Type u_1} → [inst : DivisionRing K] → [inst_1 : Fintype K] → Field K",
     "{K : Type u_1} → [inst : DivisionRing K] → [inst_1 : Fintype K] → Field K"],
    ["(K : Type u) → [inst : DivisionRing K] → [inst_1 : Fintype K] → Field K",
     "(K : Type u) → [inst : DivisionRing K] → [inst_1 : Fintype K] → Field K"],
    ["{K : Type u} → [inst : DivisionRing K] → [inst_1 : Fintype K] → Field K"],
    ["(K : Type u_1) → [inst : DivisionRing K] → [inst_1 : Finite K] → Field K"],
    ["(K : Type u_1) → [inst : DivisionRing K] → [inst_1 : Fintype K] → Field K"],
    ["∀ {K : Type u_1} [inst : Fintype K] [inst_1 : DivisionRing K], IsField K"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   ["∀ (K : Type u) [inst : DivisionRing K] [inst_1 : Fintype K], Field K ",
    "∀ {K : Type u} [inst : DivisionRing K] [inst_1 : Fintype K], Field K ",
    "∀ {K : Type u_1} [inst : DivisionRing K] [inst_1 : Fintype K], Field K ",
    "∀ {K : Type u_1} [inst : DivisionRing K] [inst_1 : Fintype K], Field K ",
    "∀ {K : Type u_1} [inst : DivisionRing K] [inst_1 : Fintype K], Field K ",
    "∀ (K : Type u_1) [inst : DivisionRing K] [inst_1 : Fintype K], Field K ",
    "∀ {K : Type u_1} [inst : Fintype K] [inst_1 : DivisionRing K], IsField K ",
    "∀ {K : Type u_1} [inst : DivisionRing K] [inst_1 : Fintype K], Field K ",
    "∀ (K : Type u_1) [inst : DivisionRing K] [inst_1 : Finite K], Field K ",
    "∀ (K : Type u) [inst : DivisionRing K] [inst_1 : Fintype K], Field K "]},
  {"theorem":
   "∀ {α : Type u_1} {β : Type u_2}, (∃ f, Function.Injective f) → (∃ g, Function.Injective g) → Nonempty (α ≃ β)",
   "some-correct": null,
   "prompt":
   "If each of two types can be mapped injectively into the other, then there is a bijection between them.",
   "groups":
   [["∀ {α : Type u_1} {β : Type u_2}, (∃ f, Function.Injective f) → (∃ g, Function.Injective g) → Nonempty (α ≃ β)",
     "∀ {α : Type u_1} {β : Type u_2} (f : α → β) (g : β → α), Function.Injective f → Function.Injective g → Nonempty (α ≃ β)",
     "∀ {α : Type u_1} {β : Type u_2} {e₁ : α → β} {e₂ : β → α},\n  Function.Injective e₁ → Function.Injective e₂ → Nonempty (α ≃ β)"],
    ["∀ {α : Sort u_1} {β : Sort u_2} (f : α → β) (g : β → α), Function.Injective f → Function.Injective g → Nonempty (α ≃ β)",
     "∀ {α : Sort u_1} {β : Sort u_2} (f₁ : α → β) (f₂ : β → α),\n  Function.Injective f₁ → Function.Injective f₂ → Nonempty (α ≃ β)"],
    ["∀ {α β : Type u}, Nonempty (α ↪ β) → Nonempty (β ↪ α) → Nonempty (α ≃ β)"],
    ["∀ {α : Sort u} {β : Sort v}, (∃ f, Function.Injective f) → (∃ g, Function.Injective g) → Nonempty (α ≃ β)"],
    ["∀ {α : Sort u_1} {β : Sort u_2},\n  (Nonempty (α → β) ∧ ∀ (f : α → β), Function.Injective f) →\n    (Nonempty (β → α) ∧ ∀ (f : β → α), Function.Injective f) → Nonempty (α ≃ β)"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   ["∀ {α : Sort u_1} {β : Sort u_2} (f : α → β) (g : β → α),\n  Function.Injective f → Function.Injective g → Nonempty (α ≃ β) ",
    "∀ {α β : Type u} (h₁ : Nonempty (α ↪ β)) (h₂ : Nonempty (β ↪ α)), Nonempty (α ≃ β) ",
    "∀ {α : Type u_1} {β : Type u_2},\n  (∃ (f : α → β), Function.Injective f) → (∃ (g : β → α), Function.Injective g) → Nonempty (α ≃ β) ",
    "∀ {α : Type u_1} {β : Type u_2} (f : α → β) (g : β → α),\n  Function.Injective f → Function.Injective g → Nonempty (α ≃ β) ",
    "∀ {α : Type u_1} {β : Type u_2} {e₁ : α → β} {e₂ : β → α},\n  Function.Injective e₁ → Function.Injective e₂ → Nonempty (α ≃ β) ",
    "∀ {α : Sort u_1} {β : Sort u_2},\n  (Nonempty (α → β) ∧ (∀ (f : α → β), Function.Injective f)) →\n  (Nonempty (β → α) ∧ (∀ (f : β → α), Function.Injective f)) →\n  Nonempty (Equiv α β) ",
    "∀ {α : Sort u_1} {β : Sort u_2} (f₁ : α → β) (f₂ : β → α), Function.Injective f₁ → Function.Injective f₂ → Nonempty (α ≃ β) ",
    "∀ {α : Sort u} {β : Sort v},\n  (∃ (f : α → β), Function.Injective f) → (∃ (g : β → α), Function.Injective g) →\n  Nonempty (α ≃ β) "]},
  {"theorem":
   "∀ {V : Type u} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj],\n  (∀ (v w : V), v ≠ w → ∃! u, SimpleGraph.Adj G v u ∧ SimpleGraph.Adj G w u) →\n    ∃ v, ∀ (w : V), w ≠ v → SimpleGraph.Adj G v w",
   "some-correct": null,
   "prompt":
   "A finite graph in which every pair of vertices have precisely one common neighbour contains a vertex that is adjacent to all other vertices.",
   "groups":
   [["∀ {V : Type u} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj],\n  (∀ (v w : V), v ≠ w → ∃! u, SimpleGraph.Adj G v u ∧ SimpleGraph.Adj G w u) →\n    ∃ v, ∀ (w : V), w ≠ v → SimpleGraph.Adj G v w",
     "∀ {V : Type u} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj],\n  (∀ (v w : V), v ≠ w → ∃! x, SimpleGraph.Adj G v x ∧ SimpleGraph.Adj G w x) →\n    ∃ v, ∀ (w : V), w ≠ v → SimpleGraph.Adj G v w"],
    ["∀ {V : Type u} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj],\n  (∀ (v w : V), v ≠ w → ∃! x, SimpleGraph.Adj G x v ∧ SimpleGraph.Adj G x w) →\n    ∃ x, ∀ (v : V), v ≠ x → SimpleGraph.Adj G x v"],
    ["∀ {V : Type u} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj],\n  (∀ (v w : V), v ≠ w → ∃! u, SimpleGraph.Adj G v u ∧ SimpleGraph.Adj G w u) →\n    ∃ x, ∀ (y : V), x ≠ y → SimpleGraph.Adj G x y"],
    ["∀ {V : Type} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj],\n  (∀ (v w : V), v ≠ w → ∃! u, SimpleGraph.Adj G v u ∧ SimpleGraph.Adj G w u) →\n    ∃ v, ∀ (w : V), w ≠ v → SimpleGraph.Adj G v w"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   ["∀ {V : Type u} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj],\n  (∀ (v w : V), v ≠ w → SimpleGraph.commonNeighbors G v w = 1) → ∃ v, SimpleGraph.degree G v = Fintype.card V - 1 ",
    "∀ {V : Type} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj],\n  (∀ (v w : V), v ≠ w → ∃! (u : V), SimpleGraph.Adj G v u ∧ SimpleGraph.Adj G w u) →\n  ∃ (v : V), ∀ (w : V), w ≠ v → SimpleGraph.Adj G v w ",
    "∀ {V : Type u} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj],\n  (∀ (v w : V), v ≠ w → ∃! u, SimpleGraph.Adj G v u ∧ SimpleGraph.Adj G w u) → ∃ x, ∀ y, x ≠ y → SimpleGraph.Adj G x y ",
    "∀ {V : Type u} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj],\n  (∀ (v w : V), v ≠ w → ∃! (u : V), SimpleGraph.Adj G v u ∧ SimpleGraph.Adj G w u) → ∃ (v : V), ∀ (w : V), w ≠ v → SimpleGraph.Adj G v w ",
    "∀ {V : Type u} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj],\n  (∀ (v w : V), v ≠ w → ∃! (x : V), SimpleGraph.Adj G x v ∧ SimpleGraph.Adj G x w) → ∃ (x : V), ∀ (v : V), v ≠ x → SimpleGraph.Adj G x v ",
    "∀ {V : Type u} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj],\n  (∀ (v w : V), v ≠ w → ∃! (x : V), SimpleGraph.Adj G v x ∧ SimpleGraph.Adj G w x) →\n  ∃ (v : V), ∀ (w : V), w ≠ v → SimpleGraph.Adj G v w "]},
  {"theorem":
   "∀ {α : Type u_1} {r : α → α → Prop} [inst : PartialOrder α] [inst_1 : Nonempty α],\n  (∀ (c : Set α), IsChain r c → Set.Nonempty c → ∃ ub, ∀ (a : α), a ∈ c → r a ub) → ∃ m, ∀ (a : α), r m a → r a m",
   "some-correct": null,
   "prompt":
   "Every non-empty poset in which every chain has an upper bound contains a maximal element.",
   "groups":
   [["∀ {α : Type u_1} {r : α → α → Prop} [inst : PartialOrder α] [inst_1 : Nonempty α],\n  (∀ (c : Set α), IsChain r c → Set.Nonempty c → ∃ ub, ∀ (a : α), a ∈ c → r a ub) → ∃ m, ∀ (a : α), r m a → r a m",
     "∀ {α : Type u_1} {r : α → α → Prop} [inst : PartialOrder α] [inst_1 : Nonempty α],\n  (∀ (c : Set α), IsChain r c → Set.Nonempty c → ∃ ub, ∀ (a : α), a ∈ c → r a ub) → ∃ m, ∀ (a : α), r m a → r a m"],
    ["∀ {α : Type u_1} {r : α → α → Prop},\n  (∀ (c : Set α), IsChain r c → Set.Nonempty c → ∃ ub, ∀ (a : α), a ∈ c → r a ub) →\n    (∀ {a b c : α}, r a b → r b c → r a c) → ∃ m, ∀ (a : α), r m a → r a m",
     "∀ {α : Type u_1} {r : α → α → Prop},\n  (∀ (c : Set α), IsChain r c → Set.Nonempty c → ∃ ub, ∀ (a : α), a ∈ c → r a ub) →\n    (∀ {a b c : α}, r a b → r b c → r a c) → ∃ m, ∀ (a : α), r m a → r a m"],
    ["∀ {α : Type u_1} {r : α → α → Prop} [inst : PartialOrder α],\n  (∀ (c : Set α), IsChain r c → Set.Nonempty c → ∃ ub, ∀ (a : α), a ∈ c → r a ub) → ∃ m, ∀ (a : α), r m a → r a m"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u_1} {r : α → α → Prop},\n  (∀ (c : Set α), IsChain r c → Set.Nonempty c → ∃ ub, ∀ (a : α), a ∈ c → r a ub) →\n    (∀ {a b c : α}, r a b → r b c → r a c) → ∃ m, ∀ (a : α), r m a → r a m ",
    "∀ {α : Type u_1} {r : α → α → Prop} [inst : PartialOrder α] [inst_1 : Nonempty α],\n  (∀ (c : Set α), IsChain r c → Set.Nonempty c → ∃ ub, ∀ (a : α), a ∈ c → r a ub) →\n    ∃ m, ∀ (a : α), r m a → r a m ",
    "∀ {α : Type u_1} {r : α → α → Prop} [inst : PartialOrder α] [inst_1 : Nonempty α],\n  (∀ (c : Set α), IsChain r c → Set.Nonempty c → ∃ ub, ∀ (a : α), a ∈ c → r a ub) →\n    ∃ m, ∀ (a : α), r m a → r a m ",
    "∀ {α : Type u_1} {r : α → α → Prop} [inst : PartialOrder α],\n  (∀ (c : Set α), IsChain r c → Set.Nonempty c → ∃ ub, ∀ (a : α), a ∈ c → r a ub) →\n    ∃ m, ∀ (a : α), r m a → r a m ",
    "∀ {α : Type u_1} {r : α → α → Prop},\n  (∀ (c : Set α), IsChain r c → Set.Nonempty c → ∃ ub, ∀ (a : α), a ∈ c → r a ub) →\n    (∀ {a b c : α}, r a b → r b c → r a c) → (∃ m, ∀ (a : α), r m a → r a m) "]},
  {"theorem":
   "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β]\n  [inst_2 : UniformSpace γ] (f : α → β) (g : β → γ),\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)",
   "some-correct": null,
   "prompt":
   "A uniformly continuous function of a uniformly continuous function is uniformly continuous.",
   "groups":
   [["∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β]\n  [inst_2 : UniformSpace γ] (f : α → β) (g : β → γ),\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)",
     "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β]\n  [inst_2 : UniformSpace γ] {f : α → β} {g : β → γ},\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)",
     "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β]\n  [inst_2 : UniformSpace γ] {f : α → β} {g : β → γ},\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)",
     "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β]\n  [inst_2 : UniformSpace γ] {f : α → β} {g : β → γ},\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)",
     "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β]\n  [inst_2 : UniformSpace γ] {f : α → β} {g : β → γ},\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)",
     "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β]\n  [inst_2 : UniformSpace γ] {f : α → β} {g : β → γ},\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)",
     "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β]\n  [inst_2 : UniformSpace γ] (f : α → β) (g : β → γ),\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)",
     "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β]\n  [inst_2 : UniformSpace γ] {f : α → β} {g : β → γ},\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   ["forall {α : Type u_1} {β : Type u_2} {γ : Type u_3}\n  [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  (f : α → β) (g : β → γ),\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f) ",
    "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {f : α → β} {g : β → γ},\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f) ",
    "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {f : α → β} {g : β → γ}, UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f) ",
    "forall {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {f : α → β} {g : β → γ},\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f) ",
    "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {f : α → β} {g : β → γ},\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f) ",
    "forall {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {f : α → β} {g : β → γ},\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f) ",
    "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  (f : α → β) (g : β → γ), UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f) ",
    "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {f : α → β} {g : β → γ}, UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f) "]},
  {"theorem":
   "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β]\n  [inst_2 : UniformSpace γ] (f : α → β) (g : β → γ),\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)",
   "some-correct": null,
   "prompt":
   "A uniformly continuous function of a uniformly continuous function is uniformly continuous.",
   "groups":
   [["∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β]\n  [inst_2 : UniformSpace γ] (f : α → β) (g : β → γ),\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)",
     "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β]\n  [inst_2 : UniformSpace γ] {f : α → β} {g : β → γ},\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)",
     "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β]\n  [inst_2 : UniformSpace γ] {f : α → β} {g : β → γ},\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)",
     "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β]\n  [inst_2 : UniformSpace γ] {f : α → β} {g : β → γ},\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)",
     "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β]\n  [inst_2 : UniformSpace γ] {f : α → β} {g : β → γ},\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)",
     "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β]\n  [inst_2 : UniformSpace γ] {f : α → β} {g : β → γ},\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)",
     "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β]\n  [inst_2 : UniformSpace γ] (f : α → β) (g : β → γ),\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)",
     "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β]\n  [inst_2 : UniformSpace γ] {f : α → β} {g : β → γ},\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   ["forall {α : Type u_1} {β : Type u_2} {γ : Type u_3}\n  [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  (f : α → β) (g : β → γ),\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f) ",
    "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {f : α → β} {g : β → γ},\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f) ",
    "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {f : α → β} {g : β → γ}, UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f) ",
    "forall {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {f : α → β} {g : β → γ},\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f) ",
    "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {f : α → β} {g : β → γ},\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f) ",
    "forall {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {f : α → β} {g : β → γ},\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f) ",
    "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  (f : α → β) (g : β → γ), UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f) ",
    "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {f : α → β} {g : β → γ}, UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f) "]},
  {"theorem":
   "∀ {α : Type u} [inst : TopologicalSpace α],\n  NormalSpace α ↔\n    ∀ (s t : Set α),\n      IsClosed s →\n        IsClosed t → Disjoint s t → ∃ f, Continuous f ∧ ∀ (x : α), x ∈ s → f x = 0 ∧ ∀ (x : α), x ∈ t → f x = 1",
   "some-correct": null,
   "prompt":
   "A topological space is normal if and only if any two disjoint closed subsets can be separated by a continuous function.",
   "groups":
   [["∀ {α : Type u} [inst : TopologicalSpace α],\n  NormalSpace α ↔\n    ∀ (s t : Set α),\n      IsClosed s →\n        IsClosed t → Disjoint s t → ∃ f, Continuous f ∧ ∀ (x : α), x ∈ s → f x = 0 ∧ ∀ (x : α), x ∈ t → f x = 1"],
    ["∀ {X : Type u_1} [inst : TopologicalSpace X],\n  NormalSpace X ↔\n    ∀ (A B : Set X),\n      IsClosed A →\n        IsClosed B → Disjoint A B → ∃ f, Continuous f ∧ (∀ (x : X), x ∈ A → f x = 0) ∧ ∀ (x : X), x ∈ B → f x = 1"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   ["∀ {X : Type u_1} [inst : TopologicalSpace X],\n  NormalSpace X ↔ ∀ (A B : Set X), IsClosed A → IsClosed B → Disjoint A B → ∃ f, Continuous f ∧ f A ⊆ ⊥ ∧ f B ⊇ ⊤ ",
    "∀ {α : Type u_1} [inst : TopologicalSpace α], NormalSpace α ↔\n  ∀ (s t : Set α), IsClosed s → IsClosed t → Disjoint s t → ∃ f, Continuous f ∧ ∀ x, 0 ≤ f x ∧ f x ≤ 1 ∧ (x ∈ s → f x = 0) ∧ (x ∈ t → f x = 1) ",
    "∀ {X : Type u_1} [inst : TopologicalSpace X], NormalSpace X ↔\n  ∀ (A B : Set X), IsClosed A → IsClosed B → Disjoint A B →\n    ∃ f : X → ℝ, Continuous f ∧ (∀ (x : X), x ∈ A → f x = 0) ∧ (∀ (x : X), x ∈ B → f x = 1) ",
    "∀ {α : Type u} [inst : TopologicalSpace α],\n  NormalSpace α ↔ ∀ (s t : Set α), IsClosed s → IsClosed t → Disjoint s t → ∃ (f : α → ℝ), Continuous f ∧ ∀ (x : α), x ∈ s → f x = 0 ∧ ∀ (x : α), x ∈ t → f x = 1 ",
    "∀ {α : Type u_1} [inst : TopologicalSpace α],\n  NormalSpace α ↔ ∀ (s t : Set α), IsClosed s → IsClosed t → Disjoint s t → ∃ f, ContinuousOn f s ∧ ContinuousOn f t ∧ ∀ x, x ∈ s → f x = 0 ∧ ∀ y, y ∈ t → f y = 1 "]},
  {"theorem":
   "∀ {α : Type u_1} {f : α → α} {x : α}, Function.IsPeriodicPt f 3 x → ∀ (n : ℕ), 0 < n → ∃ y, Function.IsPeriodicPt f n y",
   "some-correct": null,
   "prompt":
   "If a function from the unit interval to itself has a point of period three, then it has points of all positive periods.",
   "groups":
   [["∀ {α : Type u_1} {f : α → α} {x : α}, Function.IsPeriodicPt f 3 x → ∀ (n : ℕ), 0 < n → ∃ y, Function.IsPeriodicPt f n y",
     "∀ {α : Type u_1} {f : α → α} {x : α}, Function.IsPeriodicPt f 3 x → ∀ (n : ℕ), 0 < n → ∃ y, Function.IsPeriodicPt f n y"],
    ["∀ {α : Type u_1} (f : α → α) [inst : LinearOrderedField α] [inst_1 : TopologicalSpace α] [inst_2 : OrderTopology α]\n  [inst_3 : FloorRing α], (∃ x, Function.IsPeriodicPt f 3 x) → ∀ (n : ℕ), ∃ x, Function.IsPeriodicPt f n x"],
    ["∀ {α : Type u_1} (f : α → α) [inst : LinearOrder α] [inst_1 : Nonempty α] [inst_2 : TopologicalSpace α]\n  [inst_3 : OrderTopology α], (∃ x, Function.IsPeriodicPt f 3 x) → ∀ (n : ℕ), ∃ x, Function.IsPeriodicPt f n x"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u_1} {f : α → α} {x : α},\n  Function.IsPeriodicPt f 3 x → ∀ (n : ℕ), 0 < n → ∃ y, Function.IsPeriodicPt f n y ",
    "∀ {α : Type u_1} (f : α → α) [inst : LinearOrder α] [inst_1 : Nonempty α]\n  [inst_2 : TopologicalSpace α] [inst_3 : OrderTopology α],\n  (∃ x, Function.IsPeriodicPt f 3 x) → ∀ n, ∃ x, Function.IsPeriodicPt f n x ",
    "∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : LinearOrderedAddCommGroup α] [inst_2 : TopologicalAddGroup α] [inst_3 : Archimedean α]\n  (f : α → α) {x : α},\n  f x ∈ Set.Icc 0 1 →\n  Function.IsPeriodicPt f 3 x →\n  ∀ (n : ℕ), 0 < n → ∃ y, Function.IsPeriodicPt f n y ∧ y ∈ Set.Icc 0 1 ",
    "∀ {α : Type u_1} (f : α → α) [inst : LinearOrderedField α] [inst_1 : TopologicalSpace α] [inst_2 : OrderTopology α] [inst_3 : FloorRing α],\n  (∃ x, Function.IsPeriodicPt f 3 x) → ∀ n, ∃ x, Function.IsPeriodicPt f n x ",
    "∀ {α : Type u_1} {f : α → α} {x : α},\n  Function.IsPeriodicPt f 3 x → ∀ (n : ℕ), 0 < n → ∃ y, Function.IsPeriodicPt f n y "]},
  {"theorem":
   "{C : Type u₁} →\n  [inst : CategoryTheory.Category.{?u.20560571, u₁} C] →\n    [inst_1 : CategoryTheory.Limits.HasTerminal C] →\n      {A B : C} → CategoryTheory.Limits.IsTerminal A → CategoryTheory.Limits.IsTerminal B → Unique (A ≅ B)",
   "some-correct": null,
   "prompt":
   "A terminal object in a category is unique up to unique isomorphism.",
   "groups":
   [["{C : Type u₁} →\n  [inst : CategoryTheory.Category.{?u.20560571, u₁} C] →\n    [inst_1 : CategoryTheory.Limits.HasTerminal C] →\n      {A B : C} → CategoryTheory.Limits.IsTerminal A → CategoryTheory.Limits.IsTerminal B → Unique (A ≅ B)"],
    ["{C : Type u₁} →\n  [inst : CategoryTheory.Category.{?u.20552429, u₁} C] →\n    CategoryTheory.Limits.HasTerminal C →\n      (P Q : C) → CategoryTheory.Limits.IsTerminal P → CategoryTheory.Limits.IsTerminal Q → (P ≅ Q)"],
    ["{C : Type u₁} →\n  [inst : CategoryTheory.Category.{?u.20554472, u₁} C] →\n    [inst_1 : CategoryTheory.Limits.HasTerminal C] →\n      (X Y : C) → CategoryTheory.Limits.IsTerminal X → CategoryTheory.Limits.IsTerminal Y → (X ≅ Y)"],
    ["∀ {C : Type u₁} [inst : CategoryTheory.Category.{?u.20555694, u₁} C] {X Y : C},\n  CategoryTheory.Limits.IsTerminal X → CategoryTheory.Limits.IsTerminal Y → Nonempty (X ≅ Y)"],
    ["{C : Type u₁} →\n  [inst : CategoryTheory.Category.{?u.20556903, u₁} C] →\n    {X Y : C} → CategoryTheory.Limits.IsTerminal X → CategoryTheory.Limits.IsTerminal Y → (X ≅ Y)"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   ["{C : Type u₁} →\n  [inst : CategoryTheory.Category C] →\n    CategoryTheory.Limits.HasTerminal C → (P Q : C) → CategoryTheory.Limits.IsTerminal P → CategoryTheory.Limits.IsTerminal Q → (P ≅ Q) ",
    "∀ {C : Type u₁} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasTerminal C] (X Y : C),\n  CategoryTheory.Limits.IsTerminal X → CategoryTheory.Limits.IsTerminal Y → (X ≅ Y) ",
    "∀ {C : Type u₁} [inst : CategoryTheory.Category C] {X Y : C} (hX : CategoryTheory.Limits.IsTerminal X) (hY : CategoryTheory.Limits.IsTerminal Y),\n  Nonempty (X ≅ Y) ",
    "∀ {C : Type u₁} [inst : CategoryTheory.Category C] {X Y : C}, CategoryTheory.Limits.IsTerminal X → CategoryTheory.Limits.IsTerminal Y → (X ≅ Y) ",
    "∀ {C : Type u₁} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasTerminal C] {A B : C}\n  (hA : CategoryTheory.Limits.IsTerminal A) (hB : CategoryTheory.Limits.IsTerminal B), Unique (A ≅ B) "]},
  {"theorem": "∀ {α : Type u} (s t : Set α), sᶜ ∩ tᶜ = (s ∪ t)ᶜ",
   "some-correct": null,
   "prompt":
   "The complement of the union of two sets is the intersection of their complements.",
   "groups":
   [["∀ {α : Type u} (s t : Set α), sᶜ ∩ tᶜ = (s ∪ t)ᶜ",
     "∀ {α : Type u} (s t : Set α), (s ∪ t)ᶜ = sᶜ ∩ tᶜ",
     "∀ {α : Type u} (s t : Set α), sᶜ ∩ tᶜ = (s ∪ t)ᶜ",
     "∀ {α : Type u} (s t : Set α), (s ∪ t)ᶜ = sᶜ ∩ tᶜ",
     "∀ {α : Type u} (s t : Set α), sᶜ ∩ tᶜ = (s ∪ t)ᶜ",
     "∀ {α : Type u} (s t : Set α), (s ∪ t)ᶜ = sᶜ ∩ tᶜ",
     "∀ {α : Type u} (s t : Set α), sᶜ ∩ tᶜ = (s ∪ t)ᶜ",
     "∀ {α : Type u} (s t : Set α), sᶜ ∩ tᶜ = (s ∪ t)ᶜ",
     "∀ {α : Type u} (s t : Set α), sᶜ ∩ tᶜ = (s ∪ t)ᶜ",
     "∀ {α : Type u} (s t : Set α), (s ∪ t)ᶜ = sᶜ ∩ tᶜ"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u} (s t : Set α), sᶜ ∩ tᶜ = (s ∪ t)ᶜ ",
    "∀ {α : Type u} (s t : Set α), (s ∪ t)ᶜ = sᶜ ∩ tᶜ ",
    "∀ {α : Type u} (s t : Set α), sᶜ ∩ tᶜ = (s ∪ t)ᶜ ",
    "∀ {α : Type u} (s t : Set α), (s ∪ t)ᶜ = sᶜ ∩ tᶜ ",
    "∀ {α : Type u} (s t : Set α), sᶜ ∩ tᶜ = (s ∪ t)ᶜ ",
    "∀ {α : Type u} (s t : Set α), (s ∪ t)ᶜ = sᶜ ∩ tᶜ ",
    "∀ {α : Type u} (s t : Set α), sᶜ ∩ tᶜ = (s ∪ t)ᶜ ",
    "∀ {α : Type u} (s t : Set α), sᶜ ∩ tᶜ = (s ∪ t)ᶜ ",
    "∀ {α : Type u} (s t : Set α), sᶜ ∩ tᶜ = (s ∪ t)ᶜ ",
    "∀ {α : Type u} (s t : Set α), (s ∪ t)ᶜ = sᶜ ∩ tᶜ "]},
  {"theorem": "∀ {x y z : ℕ}, x > 0 → y > 0 → x ^ 3 + y ^ 3 ≠ z ^ 3",
   "some-correct": null,
   "prompt":
   "The sum of the cubes of two positive integers is never equal to the cube of a third integer.",
   "groups":
   [["∀ {x y z : ℕ}, x > 0 → y > 0 → x ^ 3 + y ^ 3 ≠ z ^ 3",
     "∀ {x y z : ℕ}, 0 < x → 0 < y → x ^ 3 + y ^ 3 ≠ z ^ 3",
     "∀ {x y z : ℕ}, 0 < x → 0 < y → x ^ 3 + y ^ 3 ≠ z ^ 3",
     "∀ {x y z : ℕ}, 0 < x → 0 < y → x ^ 3 + y ^ 3 ≠ z ^ 3",
     "∀ {x y z : ℕ}, 0 < x → 0 < y → x ^ 3 + y ^ 3 ≠ z ^ 3",
     "∀ {x y z : ℕ}, x > 0 → y > 0 → x ^ 3 + y ^ 3 ≠ z ^ 3",
     "∀ {x y z : ℕ}, 0 < x → 0 < y → x ^ 3 + y ^ 3 ≠ z ^ 3",
     "∀ {x y z : ℕ}, 0 < x → 0 < y → x ^ 3 + y ^ 3 ≠ z ^ 3",
     "∀ {x y z : ℕ}, 0 < x → 0 < y → x ^ 3 + y ^ 3 ≠ z ^ 3",
     "∀ {x y z : ℕ}, 0 < x → 0 < y → x ^ 3 + y ^ 3 ≠ z ^ 3"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   ["∀ {x y z : ℕ}, x > 0 → y > 0 → x ^ 3 + y ^ 3 ≠ z ^ 3 ",
    "∀ {x y z : ℕ}, 0 < x → 0 < y → x^3 + y^3 ≠ z^3 ",
    "∀ {x y z : ℕ}, 0 < x → 0 < y → x ^ 3 + y ^ 3 ≠ z ^ 3 ",
    "∀ {x y z : ℕ}, 0 < x → 0 < y → x ^ 3 + y ^ 3 ≠ z ^ 3 ",
    "∀ {x y z : ℕ}, 0 < x → 0 < y → x ^ 3 + y ^ 3 ≠ z ^ 3 ",
    "∀ {x y z : ℕ}, x > 0 → y > 0 → x ^ 3 + y ^ 3 ≠ z ^ 3 ",
    "∀ {x y z : ℕ}, 0 < x → 0 < y → x ^ 3 + y ^ 3 ≠ z ^ 3 ",
    "∀ {x y z : ℕ}, 0 < x → 0 < y → x ^ 3 + y ^ 3 ≠ z ^ 3 ",
    "∀ {x y z : ℕ}, 0 < x → 0 < y → x ^ 3 + y ^ 3 ≠ z ^ 3 ",
    "∀ {x y z : ℕ}, 0 < x → 0 < y → x ^ 3 + y ^ 3 ≠ z ^ 3 "]},
  {"theorem":
   "∀ {G : Type u_1} [inst : Group G], (∀ (x : G), x * x = 1) → ∀ (x y : G), Commute x y",
   "some-correct": null,
   "prompt":
   "If every element of a group `G` has order `2`, then every pair of elements of `G` commutes.",
   "groups":
   [["∀ {G : Type u_1} [inst : Group G], (∀ (x : G), x * x = 1) → ∀ (x y : G), Commute x y",
     "∀ {G : Type u_1} [inst : Group G], (∀ (x : G), x * x = 1) → ∀ (x y : G), Commute x y",
     "∀ {G : Type u_1} [inst : Group G], (∀ (x : G), x * x = 1) → ∀ (x y : G), Commute x y",
     "∀ {G : Type u_1} [inst : Group G], (∀ (x : G), x * x = 1) → ∀ (x y : G), Commute x y",
     "∀ {G : Type u_1} [inst : Group G], (∀ (x : G), x * x = 1) → ∀ (x y : G), Commute x y",
     "∀ {G : Type u_1} [inst : Group G], (∀ (x : G), x * x = 1) → ∀ (x y : G), Commute x y"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   ["∀ {G : Type u_1} [inst : Group G] (h : ∀ (x : G), x ^ 2 = 1), ∀ (a b : G), Commute a b ",
    "∀ {G : Type u_1} [inst : Group G] (h : ∀ (x : G), x^2 = 1), ∀ (x y : G), Commute x y ",
    "∀ {G : Type u_1} [inst : Group G] (h : ∀ (a : G), a ^ 2 = 1), ∀ (x y : G), Commute x y ",
    "∀ {G : Type u_1} [inst : Group G] (h : ∀ (x : G), x * x = 1), ∀ (x y : G), Commute x y ",
    "∀ {G : Type u_1} [inst : Group G] (h : ∀ (x : G), x * x = 1), ∀ (x y : G), Commute x y ",
    "∀ {G : Type u_1} [inst : Group G] (h : ∀ (x : G), x * x = 1), ∀ (x y : G), Commute x y ",
    "∀ {G : Type u_1} [inst : Group G] (n : G), n ^ 2 = 1 → ∀ (x y : G), Commute x y ",
    "∀ {G : Type u_1} [inst : Group G], (∀ (x : G), x * x = 1) → ∀ (x y : G), Commute x y ",
    "∀ {G : Type u_1} [inst : Group G], (∀ (x : G), x * x = 1) → ∀ (x y : G), Commute x y ",
    "∀ {G : Type u_1} [inst : Group G] (h : ∀ (x : G), x * x = 1), ∀ (x y : G), Commute x y "]},
  {"theorem": "∀ {n : ℕ}, Even (n * (n + 1))",
   "some-correct": null,
   "prompt": "The product of two consecutive natural numbers is even.",
   "groups":
   [["∀ {n : ℕ}, Even (n * (n + 1))",
     "∀ {n : ℕ}, Even (n * (n + 1))",
     "∀ {n : ℕ}, Even (n * (n + 1))",
     "∀ {n : ℕ}, Even (n * (n + 1))",
     "∀ {n : ℕ}, Even (n * (n + 1))",
     "∀ {n : ℕ}, Even (n * (n + 1))",
     "∀ {n : ℕ}, Even (n * (n + 1))",
     "∀ {n : ℕ}, Even (n * (n + 1))",
     "∀ (n : ℕ), Even (n * (n + 1))",
     "∀ {n : ℕ}, Even (n * (n + 1))"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   ["∀ {n : ℕ}, Even (n * (n + 1)) ",
    "∀ {n : ℕ}, Even (n * (n + 1)) ",
    "∀ {n : ℕ}, Even (n * (n + 1)) ",
    "∀ {n : ℕ}, Even (n * (n + 1)) ",
    "∀ {n : ℕ}, Even (n * (n + 1)) ",
    "∀ {n : ℕ}, Even (n * (n + 1)) ",
    "∀ {n : ℕ}, Even (n * (n + 1)) ",
    "∀ {n : ℕ}, Even (n * (n + 1)) ",
    "∀ (n : ℕ), Even (n * (n + 1)) ",
    "∀ {n : ℕ}, Even (n * (n + 1)) "]},
  {"theorem":
   "∀ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.index H = 2 → Subgroup.Normal H",
   "some-correct": null,
   "prompt": "Every index 2 subgroup of a group is normal.",
   "groups":
   [["∀ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.index H = 2 → Subgroup.Normal H",
     "∀ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.index H = 2 → Subgroup.Normal H",
     "∀ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.index H = 2 → Subgroup.Normal H",
     "∀ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.index H = 2 → Subgroup.Normal H",
     "∀ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.index H = 2 → Subgroup.Normal H",
     "∀ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.index H = 2 → Subgroup.Normal H",
     "∀ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.index H = 2 → Subgroup.Normal H",
     "∀ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.index H = 2 → Subgroup.Normal H",
     "∀ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.index H = 2 → Subgroup.Normal H",
     "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Subgroup.index H = 2 → Subgroup.Normal H"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   ["∀ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.index H = 2 → Subgroup.Normal H ",
    "∀ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.index H = 2 → Subgroup.Normal H ",
    "∀ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.index H = 2 → Subgroup.Normal H ",
    "∀ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.index H = 2 → Subgroup.Normal H ",
    "∀ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.index H = 2 → Subgroup.Normal H ",
    "∀ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.index H = 2 → Subgroup.Normal H ",
    "∀ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.index H = 2 → Subgroup.Normal H ",
    "∀ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.index H = 2 → Subgroup.Normal H ",
    "∀ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.index H = 2 → Subgroup.Normal H ",
    "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Subgroup.index H = 2 → Subgroup.Normal H "]},
  {"theorem":
   "∀ {G : Type u_1} [inst : Group G] [inst_1 : IsFreeGroup G], Monoid.IsTorsionFree G",
   "some-correct": null,
   "prompt": "Every free group is torsion free.",
   "groups":
   [["∀ {G : Type u_1} [inst : Group G] [inst_1 : IsFreeGroup G], Monoid.IsTorsionFree G",
     "∀ {G : Type u_1} [inst : Group G] [inst_1 : IsFreeGroup G], Monoid.IsTorsionFree G",
     "∀ {G : Type u_1} [inst : Group G] [inst_1 : IsFreeGroup G], Monoid.IsTorsionFree G"],
    ["∀ {α : Type u_1} {G : Type u_2} [inst : Group G] [inst_1 : Fintype α], (α → G) → Monoid.IsTorsionFree (FreeGroup G)"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u_1} {G : Type u_2} [inst : Group G] [inst_1 : Fintype α] (f : α → G), Monoid.IsTorsionFree (FreeGroup G) ",
    "∀ {G : Type u_1} [inst : Group G] [inst_1 : IsFreeGroup G], Monoid.IsTorsionFree G ",
    "∀ {G : Type u_1} [inst : Group G] [inst_1 : IsFreeGroup G], Monoid.IsTorsionFree G ",
    "forall {G : Type u_1} [inst : Group G] [inst_1 : IsFreeGroup G], Monoid.IsTorsionFree G "]},
  {"theorem": "∀ (n : ℕ), 1 < n → ∃ p, Nat.Prime p ∧ p ∣ n",
   "some-correct": null,
   "prompt":
   "Every natural number greater than `1` is divisible by a prime number.",
   "groups":
   [["∀ (n : ℕ), 1 < n → ∃ p, Nat.Prime p ∧ p ∣ n",
     "∀ (n : ℕ), 1 < n → ∃ p, Nat.Prime p ∧ p ∣ n",
     "∀ (n : ℕ), 1 < n → ∃ p, Nat.Prime p ∧ p ∣ n",
     "∀ (n : ℕ), 1 < n → ∃ p, Nat.Prime p ∧ p ∣ n",
     "∀ (n : ℕ), n > 1 → ∃ p, Nat.Prime p ∧ p ∣ n",
     "∀ (n : ℕ), n > 1 → ∃ p, Nat.Prime p ∧ p ∣ n",
     "∀ (n : ℕ), n > 1 → ∃ p, Nat.Prime p ∧ p ∣ n",
     "∀ (n : ℕ), 1 < n → ∃ p, Nat.Prime p ∧ p ∣ n",
     "∀ (n : ℕ), 1 < n → ∃ p, Nat.Prime p ∧ p ∣ n",
     "∀ (n : ℕ), 1 < n → ∃ p, Nat.Prime p ∧ p ∣ n"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   ["∀ (n : ℕ), 1 < n → ∃ (p : ℕ), Nat.Prime p ∧ p ∣ n ",
    "∀ (n : ℕ), 1 < n → ∃ (p : ℕ), Nat.Prime p ∧ p ∣ n ",
    "∀ (n : ℕ), 1 < n → ∃ (p : ℕ), Nat.Prime p ∧ p ∣ n ",
    "∀ (n : ℕ), 1 < n → ∃ (p : ℕ), Nat.Prime p ∧ p ∣ n ",
    "∀ (n : ℕ), n > 1 → ∃ (p : ℕ), Nat.Prime p ∧ p ∣ n ",
    "∀ (n : ℕ), n > 1 → ∃ (p : ℕ), Nat.Prime p ∧ p ∣ n ",
    "∀ (n : ℕ), n > 1 → ∃ (p : ℕ), Nat.Prime p ∧ p ∣ n ",
    "∀ (n : ℕ), 1 < n → ∃ (p : ℕ), Nat.Prime p ∧ p ∣ n ",
    "∀ (n : ℕ), 1 < n → ∃ (p : ℕ), Nat.Prime p ∧ p ∣ n ",
    "∀ (n : ℕ), 1 < n → ∃ (p : ℕ), Nat.Prime p ∧ p ∣ n "]},
  {"theorem":
   "∀ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsionFree G → Subsingleton G",
   "some-correct": null,
   "prompt": "A finite torsion-free group is trivial",
   "groups":
   [["∀ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsionFree G → Subsingleton G",
     "∀ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsionFree G → Subsingleton G",
     "∀ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsionFree G → Subsingleton G",
     "∀ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsionFree G → Subsingleton G",
     "∀ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsionFree G → Subsingleton G",
     "∀ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsionFree G → Subsingleton G",
     "∀ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsionFree G → Subsingleton G",
     "∀ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsionFree G → Subsingleton G",
     "∀ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsionFree G → Subsingleton G"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   ["∀ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsionFree G → Subsingleton G ",
    "∀ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsionFree G → Subsingleton G ",
    "∀ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsionFree G → Subsingleton G ",
    "∀ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsionFree G → Subsingleton G ",
    "∀ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsionFree G → Subsingleton G ",
    "∀ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsionFree G → Subsingleton G ",
    "∀ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsionFree G → Subsingleton G ",
    "∀ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsionFree G → Subsingleton G ",
    "∀ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsionFree G → Subsingleton G "]},
  {"theorem":
   "{K : Type u_1} → [inst : DivisionRing K] → [inst_1 : Fintype K] → Field K",
   "some-correct": null,
   "prompt": "Every finite division ring is a field.",
   "groups":
   [["{K : Type u_1} → [inst : DivisionRing K] → [inst_1 : Fintype K] → Field K",
     "{K : Type u_1} → [inst : DivisionRing K] → [inst_1 : Fintype K] → Field K",
     "{K : Type u_1} → [inst : DivisionRing K] → [inst_1 : Fintype K] → Field K",
     "{K : Type u_1} → [inst : DivisionRing K] → [inst_1 : Fintype K] → Field K"],
    ["(K : Type u) → [inst : DivisionRing K] → [inst_1 : Fintype K] → Field K",
     "(K : Type u) → [inst : DivisionRing K] → [inst_1 : Fintype K] → Field K"],
    ["{K : Type u} → [inst : DivisionRing K] → [inst_1 : Fintype K] → Field K"],
    ["(K : Type u_1) → [inst : DivisionRing K] → [inst_1 : Finite K] → Field K"],
    ["(K : Type u_1) → [inst : DivisionRing K] → [inst_1 : Fintype K] → Field K"],
    ["∀ {K : Type u_1} [inst : Fintype K] [inst_1 : DivisionRing K], IsField K"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   ["∀ (K : Type u) [inst : DivisionRing K] [inst_1 : Fintype K], Field K ",
    "∀ {K : Type u} [inst : DivisionRing K] [inst_1 : Fintype K], Field K ",
    "∀ {K : Type u_1} [inst : DivisionRing K] [inst_1 : Fintype K], Field K ",
    "∀ {K : Type u_1} [inst : DivisionRing K] [inst_1 : Fintype K], Field K ",
    "∀ {K : Type u_1} [inst : DivisionRing K] [inst_1 : Fintype K], Field K ",
    "∀ (K : Type u_1) [inst : DivisionRing K] [inst_1 : Fintype K], Field K ",
    "∀ {K : Type u_1} [inst : Fintype K] [inst_1 : DivisionRing K], IsField K ",
    "∀ {K : Type u_1} [inst : DivisionRing K] [inst_1 : Fintype K], Field K ",
    "∀ (K : Type u_1) [inst : DivisionRing K] [inst_1 : Finite K], Field K ",
    "∀ (K : Type u) [inst : DivisionRing K] [inst_1 : Fintype K], Field K "]},
  {"theorem":
   "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : Finite α], CompactSpace α",
   "some-correct": null,
   "prompt": "Every finite topological space is compact.",
   "groups":
   [["∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : Finite α], CompactSpace α",
     "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : Finite α], CompactSpace α",
     "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : Finite α], CompactSpace α",
     "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : Finite α], CompactSpace α",
     "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : Finite α], CompactSpace α",
     "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : Finite α], CompactSpace α",
     "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : Finite α], CompactSpace α"],
    ["∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : Fintype α], CompactSpace α",
     "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : Fintype α], CompactSpace α",
     "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : Fintype α], CompactSpace α"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   ["finite_space_compact {α : Type u} [inst : TopologicalSpace α] [inst_1 : Fintype α] : CompactSpace α ",
    "finite_compact_space {α : Type u} [inst : TopologicalSpace α] [inst_1 : Fintype α] : CompactSpace α ",
    "forall {α : Type u} [inst : TopologicalSpace α] [inst_1 : Finite α], CompactSpace α ",
    "finite_space.compact_space {α : Type u} [inst : TopologicalSpace α] [inst_1 : Finite α] : CompactSpace α ",
    "finite_compact {α : Type u} [inst : TopologicalSpace α] [inst_1 : Finite α] : CompactSpace α ",
    "finite_compact_space {α : Type u} [inst : TopologicalSpace α] [inst_1 : Finite α] : CompactSpace α ",
    "forall {α : Type u} [inst : TopologicalSpace α] [inst_1 : Fintype α], CompactSpace α ",
    "finite_compact {α : Type u} [inst : TopologicalSpace α] [inst_1 : Finite α] : CompactSpace α ",
    "finite_compact {α : Type u} [inst : TopologicalSpace α] [inst_1 : Finite α] : CompactSpace α ",
    "finite_compact {α : Type u} [inst : TopologicalSpace α] [inst_1 : Finite α] : CompactSpace α "]},
  {"theorem":
   "∀ {α : Type u} [inst : Fintype α] (f : FreeGroup α →* FreeGroup α), Function.Surjective ↑f → Function.Injective ↑f",
   "some-correct": null,
   "prompt":
   "Every surjective homomorphism from a finitely generated free group to itself is injective.",
   "groups":
   [["∀ {α : Type u} [inst : Fintype α] (f : FreeGroup α →* FreeGroup α), Function.Surjective ↑f → Function.Injective ↑f",
     "∀ {α : Type u} [inst : Fintype α] (f : FreeGroup α →* FreeGroup α), Function.Surjective ↑f → Function.Injective ↑f",
     "∀ {α : Type u} [inst : Fintype α] (f : FreeGroup α →* FreeGroup α), Function.Surjective ↑f → Function.Injective ↑f",
     "∀ {α : Type u} [inst : Fintype α] (f : FreeGroup α →* FreeGroup α), Function.Surjective ↑f → Function.Injective ↑f",
     "∀ {α : Type u} [inst : Fintype α] (f : FreeGroup α →* FreeGroup α), Function.Surjective ↑f → Function.Injective ↑f",
     "∀ {α : Type u} [inst : Fintype α] (f : FreeGroup α →* FreeGroup α), Function.Surjective ↑f → Function.Injective ↑f"],
    ["∀ {α : Type u} (n : ℕ) (f : FreeGroup (Fin n) → FreeGroup (Fin n)), Function.Surjective f → Function.Injective f"],
    ["∀ {α : Type u} [inst : DecidableEq α] [inst_1 : Fintype α] (f : FreeGroup α → FreeGroup α),\n  Function.Surjective f → Function.Injective f"],
    ["∀ {α : Type u} [inst : Fintype α] (f : FreeGroup α → FreeGroup α), Function.Surjective f → Function.Injective f"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u} [inst : Fintype α] (f : FreeGroup α →* FreeGroup α),\n  Function.Surjective ↑f → Function.Injective ↑f ",
    "∀ {α : Type u} [inst : Fintype α] (f : FreeGroup α →* FreeGroup α),\n  Function.Surjective ↑f → Function.Injective ↑f ",
    "∀ {α : Type u} [inst : DecidableEq α] [inst_1 : Fintype α] (f : FreeGroup α → FreeGroup α),\n  Function.Surjective f → Function.Injective f ",
    "∀ {α : Type u} [inst : Fintype α] (f : FreeGroup α →* FreeGroup α),\n  Function.Surjective ↑f → Function.Injective ↑f ",
    "∀ {α : Type u} [inst : Fintype α] (f : FreeGroup α →* FreeGroup α), Function.Surjective ↑f → Function.Injective ↑f ",
    "∀ {α : Type u} [inst : Fintype α] (f : FreeGroup α →* FreeGroup α),\n  Function.Surjective ↑f → Function.Injective ↑f ",
    "∀ {α : Type u} [inst : Fintype α] (f : FreeGroup α → FreeGroup α),\n  Function.Surjective f → Function.Injective f ",
    "∀ {α : Type u} (n : ℕ) (f : FreeGroup (Fin n) → FreeGroup (Fin n)), Function.Surjective f → Function.Injective f ",
    "∀ {α : Type u} [inst : Fintype α] (f : FreeGroup α →* FreeGroup α),\n  Function.Surjective ↑f → Function.Injective ↑f "]},
  {"theorem":
   "∀ (n : ℕ), n ≠ 0 → n % 2 = 0 → ∃ p q, Nat.Prime p ∧ Nat.Prime q ∧ n = p + q",
   "some-correct": null,
   "prompt":
   "Every positive even integer can be written as the sum of two primes.",
   "groups":
   [["∀ (n : ℕ), n ≠ 0 → n % 2 = 0 → ∃ p q, Nat.Prime p ∧ Nat.Prime q ∧ n = p + q",
     "∀ (n : ℕ), n % 2 = 0 → n ≠ 0 → ∃ p q, Nat.Prime p ∧ Nat.Prime q ∧ n = p + q",
     "∀ (n : ℕ), n ≠ 0 → n % 2 = 0 → ∃ p q, Nat.Prime p ∧ Nat.Prime q ∧ n = p + q",
     "∀ (n : ℕ), n ≠ 0 → n % 2 = 0 → ∃ p q, Nat.Prime p ∧ Nat.Prime q ∧ n = p + q"],
    ["∀ (n : ℕ), n % 2 = 0 ∧ n > 2 → ∃ p q, Nat.Prime p ∧ Nat.Prime q ∧ n = p + q"],
    ["∀ (n : ℕ), 2 ≤ n → n % 2 = 0 → ∃ p q, Nat.Prime p ∧ Nat.Prime q ∧ n = p + q"],
    ["∀ (n : ℕ), n ≠ 0 → Even n → ∃ p q, Nat.Prime p ∧ Nat.Prime q ∧ n = p + q"],
    ["∀ (n : ℕ), 0 < n → Even n → ∃ p q, Nat.Prime p ∧ Nat.Prime q ∧ n = p + q"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   ["∀ (n : ℕ), n ≠ 0 → n % 2 = 0 → ∃ p q, Nat.Prime p ∧ Nat.Prime q ∧ n = p + q ",
    "∀ (n : ℕ), n % 2 = 0 → n ≠ 0 → ∃ p q, Nat.Prime p ∧ Nat.Prime q ∧ n = p + q ",
    "∀ (n : ℕ), 2 ≤ n → n % 2 = 0 → ∃ (p q : ℕ), Nat.Prime p ∧ Nat.Prime q ∧ n = p + q ",
    "∀ (n : ℕ), n ≠ 0 → 2 ∣ n → ∃ p q, Nat.Prime p ∧ Nat.Prime q ∧ n = p + q ",
    "∀ (n : ℕ), n ≠ 0 → Even n → ∃ p q, Nat.Prime p ∧ Nat.Prime q ∧ n = p + q ",
    "∀ (n : ℕ), n ≠ 0 → n % 2 = 0 → ∃ p q, Nat.Prime p ∧ Nat.Prime q ∧ n = p + q ",
    "∀ (n : ℕ), n ≠ 0 → n % 2 = 0 → ∃ p q, Nat.Prime p ∧ Nat.Prime q ∧ n = p + q ",
    "∀ (n : ℕ), 0 < n → Even n → ∃ p q, Nat.Prime p ∧ Nat.Prime q ∧ n = p + q ",
    "∀ (n : ℕ), n % 2 = 0 ∧ n > 2 → ∃ (p q : ℕ), Nat.Prime p ∧ Nat.Prime q ∧ n = p + q ",
    "∀ (n : ℕ), n ≠ 0 → 2 ∣ n → ∃ (p q : ℕ), Nat.Prime p ∧ Nat.Prime q ∧ n = p + q "]},
  {"theorem": "∀ {x : ℝ}, Irrational x → Irrational (Real.sqrt x)",
   "some-correct": null,
   "prompt": "The square root of an irrational number is irrational.",
   "groups":
   [["∀ {x : ℝ}, Irrational x → Irrational (Real.sqrt x)",
     "∀ {x : ℝ}, Irrational x → Irrational (Real.sqrt x)",
     "∀ {x : ℝ}, Irrational x → Irrational (Real.sqrt x)",
     "∀ {x : ℝ}, Irrational x → Irrational (Real.sqrt x)",
     "∀ {x : ℝ}, Irrational x → Irrational (Real.sqrt x)",
     "∀ {x : ℝ}, Irrational x → Irrational (Real.sqrt x)",
     "∀ {x : ℝ}, Irrational x → Irrational (Real.sqrt x)",
     "∀ {x : ℝ}, Irrational x → Irrational (Real.sqrt x)",
     "∀ {x : ℝ}, Irrational x → Irrational (Real.sqrt x)",
     "∀ {x : ℝ}, Irrational x → Irrational (Real.sqrt x)"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   ["∀ {x : ℝ}, Irrational x → Irrational (Real.sqrt x) ",
    "∀ {x : ℝ}, Irrational x → Irrational (Real.sqrt x) ",
    "∀ {x : ℝ}, Irrational x → Irrational (Real.sqrt x) ",
    "∀ {x : ℝ}, Irrational x → Irrational (Real.sqrt x) ",
    "∀ {x : ℝ}, Irrational x → Irrational (Real.sqrt x) ",
    "∀ {x : ℝ}, Irrational x → Irrational (Real.sqrt x) ",
    "∀ {x : ℝ}, Irrational x → Irrational (Real.sqrt x) ",
    "∀ {x : ℝ}, Irrational x → Irrational (Real.sqrt x) ",
    "∀ {x : ℝ}, Irrational x → Irrational (Real.sqrt x) ",
    "∀ {x : ℝ}, Irrational x → Irrational (Real.sqrt x) "]},
  {"theorem":
   "∀ {α : Type u} [inst : Semiring α] {x : α}, Even (x * x) → Even x",
   "some-correct": null,
   "prompt": "If the square of a number is even, the number itself is even.",
   "groups":
   [["∀ {α : Type u} [inst : Semiring α] {x : α}, Even (x * x) → Even x"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u} [inst : LinearOrderedRing α] {x : α}, x * x % 2 = 0 ↔ x % 2 = 0 ",
    "∀ {α : Type u} [inst : LinearOrderedRing α] {x : α}, x * x % 2 = 0 ↔ x % 2 = 0 ",
    "∀ {α : Type u} [inst : Semiring α] {x : α}, x * x % 2 = 0 ↔ x % 2 = 0 ",
    "∀ {α : Type u} [inst : LinearOrderedRing α] {x : α}, x * x % 2 = 0 ↔ x % 2 = 0 ",
    "∀ {α : Type u} [inst : LinearOrderedRing α] {x : α}, x * x % 2 = 0 ↔ x % 2 = 0 ",
    "∀ {α : Type u} [inst : Semiring α] {x : α}, Even (x * x) → Even x ",
    "∀ {α : Type u} [inst : CommRing α] {x : α}, (x * x) % 2 = 0 ↔ x % 2 = 0 ",
    " ∀ {α : Type u} [inst : LinearOrderedRing α] {x : α}, x * x % 2 = 0 → x % 2 = 0 ",
    "∀ {α : Type u} [inst : LinearOrderedRing α] {x : α}, x * x % 2 = 0 ↔ x % 2 = 0 ",
    "∀ {α : Type u} [inst : LinearOrderedRing α] {x : α}, x * x % 2 = 0 ↔ x % 2 = 0 "]},
  {"theorem":
   "∀ {R : Type u_1} [inst : CommRing R] [inst_1 : Fintype R] (P : Ideal R), Ideal.IsPrime P → Ideal.IsMaximal P",
   "some-correct": null,
   "prompt": "In a finite commutative ring, all prime ideals are maximal.",
   "groups":
   [["∀ {R : Type u_1} [inst : CommRing R] [inst_1 : Fintype R] (P : Ideal R), Ideal.IsPrime P → Ideal.IsMaximal P",
     "∀ {R : Type u_1} [inst : CommRing R] [inst_1 : Fintype R] (P : Ideal R), Ideal.IsPrime P → Ideal.IsMaximal P",
     "∀ {R : Type u_1} [inst : CommRing R] [inst_1 : Fintype R] {P : Ideal R}, Ideal.IsPrime P → Ideal.IsMaximal P",
     "∀ {R : Type u_1} [inst : CommRing R] [inst_1 : Fintype R] (I : Ideal R), Ideal.IsPrime I → Ideal.IsMaximal I",
     "∀ {R : Type u_1} [inst : CommRing R] [inst_1 : Fintype R] (P : Ideal R), Ideal.IsPrime P → Ideal.IsMaximal P",
     "∀ {R : Type u_1} [inst : CommRing R] [inst_1 : Fintype R] (P : Ideal R), Ideal.IsPrime P → Ideal.IsMaximal P",
     "∀ {R : Type u_1} [inst : CommRing R] [inst_1 : Fintype R] (P : Ideal R), Ideal.IsPrime P → Ideal.IsMaximal P",
     "∀ {R : Type u_1} [inst : CommRing R] [inst_1 : Fintype R] (P : Ideal R), Ideal.IsPrime P → Ideal.IsMaximal P",
     "∀ {R : Type u_1} [inst : CommRing R] [inst_1 : Fintype R] {P : Ideal R}, Ideal.IsPrime P → Ideal.IsMaximal P",
     "∀ {R : Type u_1} [inst : CommRing R] [inst_1 : Fintype R] (P : Ideal R), Ideal.IsPrime P → Ideal.IsMaximal P"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   ["∀ {R : Type u_1} [inst : CommRing R] [inst_1 : Fintype R],\n  (∀ (P : Ideal R), Ideal.IsPrime P → Ideal.IsMaximal P) ",
    "∀ {R : Type u_1} [inst : CommRing R] [inst_1 : Fintype R],\n  ∀ (P : Ideal R), Ideal.IsPrime P → Ideal.IsMaximal P ",
    "∀ {R : Type u_1} [inst : CommRing R] [inst_1 : Fintype R] {P : Ideal R}, Ideal.IsPrime P → Ideal.IsMaximal P ",
    "∀ {R : Type u_1} [inst : CommRing R] [inst_1 : Fintype R] (I : Ideal R), Ideal.IsPrime I → Ideal.IsMaximal I ",
    "∀ {R : Type u_1} [inst : CommRing R] [inst_1 : Fintype R] (P : Ideal R), Ideal.IsPrime P → Ideal.IsMaximal P ",
    "∀ {R : Type u_1} [inst : CommRing R] [inst_1 : Fintype R] (P : Ideal R),\n  Ideal.IsPrime P → Ideal.IsMaximal P ",
    "∀ {R : Type u_1} [inst : CommRing R] [inst_1 : Fintype R] (P : Ideal R), Ideal.IsPrime P → Ideal.IsMaximal P ",
    "∀ {R : Type u_1} [inst : CommRing R] [inst_1 : Fintype R], ∀ (P : Ideal R), Ideal.IsPrime P → Ideal.IsMaximal P ",
    "∀ {R : Type u_1} [inst : CommRing R] [inst_1 : Fintype R] {P : Ideal R}, Ideal.IsPrime P → Ideal.IsMaximal P ",
    "∀ {R : Type u_1} [inst : CommRing R] [inst_1 : Fintype R] (P : Ideal R), Ideal.IsPrime P → Ideal.IsMaximal P "]},
  {"theorem":
   "∀ {α : Type u} [inst : TopologicalSpace α], T2Space α ↔ IsClosed {p | p.fst = p.snd}",
   "some-correct": null,
   "prompt":
   "A topological space $X$ is Hausdorff if and only if the diagonal is a closed set in $X × X$.",
   "groups":
   [["∀ {α : Type u} [inst : TopologicalSpace α], T2Space α ↔ IsClosed {p | p.fst = p.snd}",
     "∀ {α : Type u} [inst : TopologicalSpace α], T2Space α ↔ IsClosed {p | p.fst = p.snd}",
     "∀ {α : Type u} [inst : TopologicalSpace α], T2Space α ↔ IsClosed {p | p.fst = p.snd}"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u} [inst : TopologicalSpace α],\n  T2Space α ↔ IsClosed {p : α × α | p.fst = p.snd} ",
    "∀ {α : Type u} [inst : TopologicalSpace α], T2Space α ↔ IsClosed {p : α × α | p.fst = p.snd} ",
    "∀ {α : Type u} [inst : TopologicalSpace α], T2Space α ↔ IsClosed {p : α × α | p.1 = p.2} "]},
  {"theorem":
   "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, (∀ (x : α), x ∈ s → ∃ U, IsOpen U ∧ x ∈ U ∧ U ⊆ s) → IsOpen s",
   "some-correct": null,
   "prompt":
   "If every point of a subset of a topological space is contained in some open set, the subset itself is open.",
   "groups":
   [["∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, (∀ (x : α), x ∈ s → ∃ U, IsOpen U ∧ x ∈ U ∧ U ⊆ s) → IsOpen s",
     "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, (∀ (x : α), x ∈ s → ∃ U, IsOpen U ∧ x ∈ U ∧ U ⊆ s) → IsOpen s"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, (∀ x ∈ s, ∃ U, IsOpen U ∧ x ∈ U ∧ U ⊆ s) → IsOpen s ",
    "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, (∀ x ∈ s, ∃ U, IsOpen U ∧ x ∈ U) → IsOpen s ",
    "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, (∀ (x : α), x ∈ s → ∃ U, IsOpen U ∧ x ∈ U ∧ U ⊆ s) → IsOpen s ",
    "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, (∀ x ∈ s, ∃ U, IsOpen U ∧ x ∈ U ∧ U ⊆ s) → IsOpen s ",
    "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, (∀ (x : α) (H : x ∈ s), ∃ U, IsOpen U ∧ x ∈ U) → IsOpen s ",
    "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, (∀ x ∈ s, ∃ U, IsOpen U ∧ x ∈ U) → IsOpen s ",
    "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, (∀ (x : α), x ∈ s → ∃ (U : Set α), IsOpen U ∧ x ∈ U ∧ U ⊆ s) → IsOpen s ",
    "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, (∀ x ∈ s, ∃ U, IsOpen U ∧ x ∈ U ∧ U ⊆ s) → IsOpen s ",
    "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, (∀ x ∈ s, ∃ U, IsOpen U ∧ x ∈ U) → IsOpen s ",
    "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, (∀ (x : α), x ∈ s → ∃ (U : Set α), IsOpen U ∧ x ∈ U ∧ U ⊆ s) → IsOpen s "]},
  {"theorem":
   "∀ {G : Type u_1} [inst : Group G], IsFreeGroup G → ∀ (x : G), x ≠ 1 → ¬IsOfFinOrder x",
   "some-correct": null,
   "prompt": "Every non-identity element of a free group is of infinite order.",
   "groups":
   [["∀ {G : Type u_1} [inst : Group G], IsFreeGroup G → ∀ (x : G), x ≠ 1 → ¬IsOfFinOrder x",
     "∀ {α : Type u_1} [inst : Group α] [inst_1 : IsFreeGroup α] (g : α), g ≠ 1 → ¬IsOfFinOrder g",
     "∀ {α : Type u_1} [inst : Group α] [inst_1 : IsFreeGroup α] {x : α}, x ≠ 1 → ¬IsOfFinOrder x",
     "∀ {G : Type u_1} [inst : Group G] [inst_1 : IsFreeGroup G] (g : G), g ≠ 1 → ¬IsOfFinOrder g"],
    ["∀ {α : Type u} (x : FreeGroup α), x ≠ 1 → ¬IsOfFinOrder x"],
    ["∀ {α : Type u} [inst : Group α] (x : FreeGroup α), x ≠ 1 → ¬IsOfFinOrder x"],
    ["∀ {α : Type u} [inst : Group α] [inst_1 : IsFreeGroup α] (a : α), a ≠ 1 → ¬IsOfFinOrder a"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   ["∀ {G : Type u_1} [inst : Group G], IsFreeGroup G → ∀ (x : G), x ≠ 1 → ¬IsOfFinOrder x ",
    "∀ {α : Type u} [inst : Group α] (x : FreeGroup α), x ≠ 1 → ¬IsOfFinOrder x ",
    "∀ {α : Type u_1} [inst : Group α] [inst_1 : IsFreeGroup α], ∀ (g : α), g ≠ 1 → ¬IsOfFinOrder g ",
    "∀ {α : Type u_1} [inst : Group α] [inst_1 : IsFreeGroup α] {x : α},\n  x ≠ 1 → ¬IsOfFinOrder x ",
    "∀ {G : Type u_1} [inst : Group G] [inst_1 : IsFreeGroup G], ∀ g : G, g ≠ 1 → ¬IsOfFinOrder g ",
    "∀ {α : Type u} [inst : Group α] [inst_1 : IsFreeGroup α], ∀ (a : α), a ≠ 1 → ¬IsOfFinOrder a ",
    "∀ {α : Type u} (x : FreeGroup α), x ≠ 1 → ¬IsOfFinOrder x "]},
  {"theorem":
   "∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : DiscreteValuationRing R] (x : R),\n  IsUnit x ↔ ↑(DiscreteValuationRing.addVal R) x = 0",
   "some-correct": null,
   "prompt":
   "An element of a discrete valuation ring is a unit if and only if it has a valuation of zero.",
   "groups":
   [["∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : DiscreteValuationRing R] (x : R),\n  IsUnit x ↔ ↑(DiscreteValuationRing.addVal R) x = 0"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   ["∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : DiscreteValuationRing R]\n  (x : R), IsUnit x ↔ DiscreteValuationRing.addVal R x = 0 "]},
  {"theorem":
   "∀ (a b : ℕ), Nat.coprime a b → ∀ (N : ℕ), ∃ x y, a * x + b * y ≥ N",
   "some-correct": false,
   "prompt":
   "For any two relatively prime positive integers $a$ and $b$, every sufficiently large natural number $N$ can be written as a linear combination $ax + by$ of $a$ and $b$, where both $x$ and $y$ are natural numbers.",
   "groups":
   [["∀ (a b : ℕ), Nat.coprime a b → ∀ (N : ℕ), ∃ x y, a * x + b * y ≥ N",
     "∀ {a b : ℕ}, Nat.coprime a b → ∀ (N : ℕ), ∃ x y, a * x + b * y ≥ N",
     "∀ {a b : ℕ}, Nat.coprime a b → ∀ (N : ℕ), ∃ x y, a * x + b * y ≥ N",
     "∀ {a b : ℕ}, Nat.coprime a b → ∀ (N : ℕ), ∃ x y, N ≤ a * x + b * y",
     "∀ {a b : ℕ}, Nat.coprime a b → ∀ (N : ℕ), ∃ x y, N ≤ a * x + b * y",
     "∀ {a b : ℕ}, Nat.coprime a b → ∀ (N : ℕ), ∃ x y, N ≤ a * x + b * y",
     "∀ {a b : ℕ}, Nat.coprime a b → ∀ (N : ℕ), ∃ x y, N ≤ a * x + b * y",
     "∀ {a b : ℕ}, Nat.coprime a b → ∀ (N : ℕ), ∃ x y, N ≤ a * x + b * y",
     "∀ {a b : ℕ}, Nat.coprime a b → ∀ (N : ℕ), ∃ x y, N ≤ a * x + b * y"],
    ["∀ {a b N : ℕ}, Nat.coprime a b → a ≠ 0 → b ≠ 0 → ∃ x y, N ≤ a * x + b * y"]],
   "correct": false,
   "comments": "",
   "all-elabs":
   ["∀ (a b : ℕ), Nat.coprime a b → ∀ N, ∃ (x y : ℕ), a * x + b * y ≥ N ",
    "forall {a b N : ℕ}, Nat.coprime a b → a ≠ 0 → b ≠ 0 → ∃ x y : ℕ, N ≤ a * x + b * y ",
    "∀ {a b : ℕ}, Nat.coprime a b → ∀ N, ∃ x y : ℕ, a * x + b * y ≥ N ",
    "∀ {a b : ℕ}, Nat.coprime a b → ∀ N, ∃ x y : ℕ, a * x + b * y ≥ N ",
    "∀ {a b : ℕ}, Nat.coprime a b → ∀ (N : ℕ), ∃ x y : ℕ, N ≤ a * x + b * y ",
    "∀ {a b : ℕ}, Nat.coprime a b → ∀ N, ∃ x y : ℕ, N ≤ a * x + b * y ",
    "∀ {a b : ℕ}, Nat.coprime a b → ∀ N, ∃ x y : ℕ, N ≤ a * x + b * y ",
    "∀ {a b : ℕ}, Nat.coprime a b → ∀ N, ∃ x y : ℕ, N ≤ a * x + b * y ",
    "∀ {a b : ℕ}, Nat.coprime a b → ∀ N, ∃ x y : ℕ, N ≤ a * x + b * y ",
    "forall {a b : ℕ}, Nat.coprime a b → ∀ N, ∃ x y : ℕ, N ≤ a * x + b * y "]},
  {"theorem": "(K : Type u) → [inst : Field K] → Ring K",
   "some-correct": null,
   "prompt": "Every field is a ring.",
   "groups":
   [["(K : Type u) → [inst : Field K] → Ring K",
     "(K : Type u) → [inst : Field K] → Ring K",
     "(K : Type u) → [inst : Field K] → Ring K",
     "(K : Type u) → [inst : Field K] → Ring K",
     "(K : Type u) → [inst : Field K] → Ring K",
     "(K : Type u) → [inst : Field K] → Ring K"],
    ["(F : Type u) → [inst : Field F] → Ring F",
     "(F : Type u) → [inst : Field F] → Ring F",
     "(F : Type u) → [inst : Field F] → Ring F"],
    ["{K : Type u} → [inst : Field K] → Ring K"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   ["∀ (K : Type u) [inst : Field K], Ring K ",
    "∀ (F : Type u) [inst : Field F], Ring F ",
    "∀ (F : Type u) [inst : Field F], Ring F ",
    "∀ (K : Type u) [inst : Field K], Ring K ",
    "∀ {K : Type u} [inst : Field K], Ring K ",
    "∀ (K : Type u) [inst : Field K], Ring K ",
    "∀ (F : Type u) [inst : Field F], Ring F ",
    "∀ (K : Type u) [inst : Field K], Ring K ",
    "∀ (K : Type u) [inst : Field K], Ring K ",
    "∀ (K : Type u) [inst : Field K], Ring K "]},
  {"theorem": "{R : Type u_1} → [inst : Ring R] → Group Rˣ",
   "some-correct": null,
   "prompt": "The set of units in a ring forms a group.",
   "groups":
   [["{R : Type u_1} → [inst : Ring R] → Group Rˣ",
     "{R : Type u_1} → [inst : Ring R] → Group Rˣ",
     "{R : Type u_1} → [inst : Ring R] → Group Rˣ",
     "{R : Type u_1} → [inst : Ring R] → Group Rˣ",
     "{R : Type u_1} → [inst : Ring R] → Group Rˣ",
     "{R : Type u_1} → [inst : Ring R] → Group Rˣ"],
    ["{R : Type u} → [inst : Ring R] → Group Rˣ"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   ["∀ {R : Type u} [inst : Ring R], Group Rˣ ",
    "∀ {R : Type u_1} [inst : Ring R], Group Rˣ ",
    "∀ {R : Type u_1} [inst : Ring R], Group Rˣ ",
    "∀ {R : Type u_1} [inst : Ring R], Group Rˣ ",
    "∀ {R : Type u_1} [inst : Ring R], Group Rˣ ",
    "∀ {R : Type u_1} [inst : Ring R], Group Rˣ ",
    "∀ {R : Type u_1} [inst : Ring R], Group Rˣ "]}],
 "elaborated": 36}