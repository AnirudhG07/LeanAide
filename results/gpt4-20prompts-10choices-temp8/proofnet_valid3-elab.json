{"total-prompts": 25,
 "temperature": 0.8,
 "query-number": 5,
 "number-similar-sentences": 10,
 "include-fixed": false,
 "failures":
 ["Show that if `X` is a Hausdorff space that is locally compact at the point `x`, then for each neighborhood `U` of `x`, there is a neighborhood `V` of `x` such that `∪ V` is compact and `∪ V ⊆ U`.",
  "Let `X` be completely regular. Show that `X` is connected if and only if the Stone-Čech compactification of `X` is connected.",
  "Suppose that `S, T ∈ L(V)` are such that `S T = T S`. Prove that `null (T - λ I)` is invariant under `S` for every `λ ∈ F`.",
  "Suppose `u, v ∈ V`. Prove that `⟨u, v⟩ = 0` if and only if `||u|| ≤ ||u + a v||` for all `a ∈ F`.",
  "Prove that if `V` is a complex inner-product space, then `⟨u, v⟩ = (||u + v||^2 - ||u - v||^2 + ||u + i v||^2 i - ||u - i v||^2 i) / 4` for all `u, v ∈ V`.",
  "Prove that if `T ∈ L(V)` is normal, then `range T = range T*`.",
  "Suppose `V` is a complex inner-product space and `T ∈ L(V)` is a normal operator such that `T^9 = T^8`. Prove that `T` is self-adjoint and `T^2 = T`.",
  "Suppose `T ∈ L(V)` is self-adjoint, `λ ∈ F`, and `ε > 0`. Prove that if there exists `v ∈ V` such that `||v|| = 1` and `||T v - λ v|| < ε`, then `T` has an eigenvalue `λ'` such that `|λ - λ'| < ε`."],
 "elaborated-prompts":
 [{"theorem": "¬LocallyCompactSpace ℚ",
   "some-correct": null,
   "prompt": "Show that the rationals `ℚ` are not locally compact.",
   "groups":
   [["¬LocallyCompactSpace ℚ",
     "¬LocallyCompactSpace ℚ",
     "¬LocallyCompactSpace ℚ",
     "¬LocallyCompactSpace ℚ",
     "¬LocallyCompactSpace ℚ",
     "¬LocallyCompactSpace ℚ",
     "¬LocallyCompactSpace ℚ",
     "¬LocallyCompactSpace ℚ",
     "¬LocallyCompactSpace ℚ",
     "¬LocallyCompactSpace ℚ"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   ["¬LocallyCompactSpace ℚ ",
    "¬LocallyCompactSpace ℚ ",
    "¬LocallyCompactSpace ℚ ",
    "¬LocallyCompactSpace ℚ ",
    "¬LocallyCompactSpace ℚ ",
    "¬LocallyCompactSpace ℚ ",
    "¬LocallyCompactSpace ℚ ",
    "¬LocallyCompactSpace ℚ ",
    "¬LocallyCompactSpace ℚ ",
    "¬LocallyCompactSpace ℚ "]},
  {"theorem":
   "∀ {α : Type u} [t : TopologicalSpace α] [inst : TopologicalSpace.SeparableSpace α] {ι : Type u_1} {s : ι → Set α}\n  {a : Set ι},\n  Set.PairwiseDisjoint a s →\n    (∀ (i : ι), i ∈ a → IsOpen (s i)) → (∀ (i : ι), i ∈ a → Set.Nonempty (s i)) → Set.Countable a",
   "some-correct": null,
   "prompt":
   "Show that if `X` has a countable dense subset, every collection of disjoint open sets in `X` is countable.",
   "groups":
   [["∀ {α : Type u} [t : TopologicalSpace α] [inst : TopologicalSpace.SeparableSpace α] {ι : Type u_1} {s : ι → Set α}\n  {a : Set ι},\n  Set.PairwiseDisjoint a s →\n    (∀ (i : ι), i ∈ a → IsOpen (s i)) → (∀ (i : ι), i ∈ a → Set.Nonempty (s i)) → Set.Countable a",
     "∀ {α : Type u} [t : TopologicalSpace α] [inst : TopologicalSpace.SeparableSpace α] {ι : Type u_1} {s : ι → Set α}\n  {a : Set ι},\n  Set.PairwiseDisjoint a s →\n    (∀ (i : ι), i ∈ a → IsOpen (s i)) → (∀ (i : ι), i ∈ a → Set.Nonempty (s i)) → Set.Countable a",
     "∀ {α : Type u} [t : TopologicalSpace α] [inst : TopologicalSpace.SeparableSpace α] {ι : Type u_1} {s : ι → Set α}\n  {a : Set ι},\n  Set.PairwiseDisjoint a s →\n    (∀ (i : ι), i ∈ a → IsOpen (s i)) → (∀ (i : ι), i ∈ a → Set.Nonempty (s i)) → Set.Countable a"],
    ["∀ {α : Type u} [t : TopologicalSpace α] [inst : TopologicalSpace.SeparableSpace α] {ι : Type u_1} {s : ι → Set α}\n  {a : Set ι}, Set.PairwiseDisjoint a s → (∀ (i : ι), i ∈ a → IsOpen (s i)) → Set.Countable a",
     "∀ {α : Type u} [t : TopologicalSpace α] [inst : TopologicalSpace.SeparableSpace α] {ι : Type u_1} {s : ι → Set α}\n  {a : Set ι}, Set.PairwiseDisjoint a s → (∀ (i : ι), i ∈ a → IsOpen (s i)) → Set.Countable a"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u} [t : TopologicalSpace α] [inst : TopologicalSpace.SeparableSpace α] {ι : Type u_1} {s : ι → Set α}\n  {a : Set ι},\n  Set.PairwiseDisjoint a s →\n    (∀ (i : ι), i ∈ a → IsOpen (s i)) → (∀ (i : ι), i ∈ a → Set.Nonempty (s i)) → Set.Countable a ",
    "∀ {α : Type u} [t : TopologicalSpace α] [inst : TopologicalSpace.SeparableSpace α] {ι : Type u_1} {s : ι → Set α}\n  {a : Set ι},\n  Set.PairwiseDisjoint a s →\n    (∀ (i : ι), i ∈ a → IsOpen (s i)) → Set.Countable a ",
    "forall {α : Type u} [t : TopologicalSpace α] [inst : TopologicalSpace.SeparableSpace α] {ι : Type u_1} {s : ι → Set α}\n  {a : Set ι},\n  Set.PairwiseDisjoint a s →\n    (∀ (i : ι), i ∈ a → IsOpen (s i)) → (∀ (i : ι), i ∈ a → Set.Nonempty (s i)) → Set.Countable a ",
    "∀ {α : Type u} [t : TopologicalSpace α] [inst : TopologicalSpace.SeparableSpace α] {ι : Type u_1} {s : ι → Set α}\n  {a : Set ι},\n  Set.PairwiseDisjoint a s →\n    (∀ (i : ι), i ∈ a → IsOpen (s i)) → (∀ (i : ι), i ∈ a → Set.Nonempty (s i)) → Set.Countable a ",
    "∀ {α : Type u} [t : TopologicalSpace α] [inst : TopologicalSpace.SeparableSpace α] {ι : Type u_1} {s : ι → Set α}\n  {a : Set ι},\n  Set.PairwiseDisjoint a s →\n    (∀ (i : ι), i ∈ a → IsOpen (s i)) → Set.Countable a "]},
  {"theorem":
   "∀ {α : Type u} [inst : TopologicalSpace α] [self : NormalSpace α] {s t : Set α},\n  IsClosed s → IsClosed t → Disjoint s t → ∃ u v, IsOpen u ∧ IsOpen v ∧ s ⊆ u ∧ t ⊆ v ∧ Disjoint (closure u) (closure v)",
   "some-correct": false,
   "prompt":
   "Show that if `X` is normal, every pair of disjoint closed sets have neighborhoods whose closures are disjoint.",
   "groups":
   [["∀ {α : Type u} [inst : TopologicalSpace α] [self : NormalSpace α] {s t : Set α},\n  IsClosed s → IsClosed t → Disjoint s t → ∃ u v, IsOpen u ∧ IsOpen v ∧ s ⊆ u ∧ t ⊆ v ∧ Disjoint (closure u) (closure v)",
     "∀ {α : Type u} [inst : TopologicalSpace α] [self : NormalSpace α] ⦃s t : Set α⦄,\n  IsClosed s →\n    IsClosed t → Disjoint s t → ∃ U₁ U₂, IsOpen U₁ ∧ IsOpen U₂ ∧ s ⊆ U₁ ∧ t ⊆ U₂ ∧ Disjoint (closure U₁) (closure U₂)",
     "∀ {α : Type u} [inst : TopologicalSpace α] [self : NormalSpace α] (A B : Set α),\n  IsClosed A → IsClosed B → Disjoint A B → ∃ U V, IsOpen U ∧ IsOpen V ∧ A ⊆ U ∧ B ⊆ V ∧ Disjoint (closure U) (closure V)",
     "∀ {α : Type u} [inst : TopologicalSpace α] [self : NormalSpace α] ⦃s t : Set α⦄,\n  IsClosed s → IsClosed t → Disjoint s t → ∃ u v, IsOpen u ∧ IsOpen v ∧ s ⊆ u ∧ t ⊆ v ∧ Disjoint (closure u) (closure v)",
     "∀ {α : Type u} [inst : TopologicalSpace α] [self : NormalSpace α] {s t : Set α},\n  IsClosed s → IsClosed t → Disjoint s t → ∃ U V, IsOpen U ∧ IsOpen V ∧ s ⊆ U ∧ t ⊆ V ∧ Disjoint (closure U) (closure V)",
     "∀ {α : Type u} [inst : TopologicalSpace α] [self : NormalSpace α] ⦃s t : Set α⦄,\n  IsClosed s → IsClosed t → Disjoint s t → ∃ u v, IsOpen u ∧ IsOpen v ∧ s ⊆ u ∧ t ⊆ v ∧ Disjoint (closure u) (closure v)",
     "∀ {α : Type u} [inst : TopologicalSpace α] [self : NormalSpace α] ⦃s t : Set α⦄,\n  IsClosed s → IsClosed t → Disjoint s t → ∃ u v, IsOpen u ∧ IsOpen v ∧ s ⊆ u ∧ t ⊆ v ∧ Disjoint (closure u) (closure v)",
     "∀ {α : Type u} [inst : TopologicalSpace α] [self : NormalSpace α] ⦃s t : Set α⦄,\n  IsClosed s → IsClosed t → Disjoint s t → ∃ u v, IsOpen u ∧ IsOpen v ∧ s ⊆ u ∧ t ⊆ v ∧ Disjoint (closure u) (closure v)"]],
   "correct": false,
   "comments": "This is for open neighborhoods. Same for others.",
   "all-elabs":
   ["∀ {α : Type u} [inst : TopologicalSpace α] [self : NormalSpace α] {s t : Set α},\n  IsClosed s → IsClosed t → Disjoint s t → ∃ u v, IsOpen u ∧ IsOpen v ∧ s ⊆ u ∧ t ⊆ v ∧ Disjoint (closure u) (closure v) ",
    "∀ {α : Type u} [inst : TopologicalSpace α] [self : NormalSpace α] ⦃s t : Set α⦄,\n  IsClosed s → IsClosed t → Disjoint s t → ∃ U₁ U₂, IsOpen U₁ ∧ IsOpen U₂ ∧ s ⊆ U₁ ∧ t ⊆ U₂ ∧ Disjoint (closure U₁) (closure U₂) ",
    "forall {α : Type u} [inst : TopologicalSpace α] [self : NormalSpace α] (A B : Set α),\n  IsClosed A → IsClosed B → Disjoint A B → ∃ U V, IsOpen U ∧ IsOpen V ∧ A ⊆ U ∧ B ⊆ V ∧ Disjoint (closure U) (closure V) ",
    "∀ {α : Type u} [inst : TopologicalSpace α] [self : NormalSpace α] ⦃s t : Set α⦄,\n  IsClosed s → IsClosed t → Disjoint s t → ∃ u v, IsOpen u ∧ IsOpen v ∧ s ⊆ u ∧ t ⊆ v ∧ Disjoint (closure u) (closure v) ",
    "∀ {α : Type u} [inst : TopologicalSpace α] [self : NormalSpace α] {s t : Set α},\n  IsClosed s → IsClosed t → Disjoint s t → ∃ U V, IsOpen U ∧ IsOpen V ∧ s ⊆ U ∧ t ⊆ V ∧ Disjoint (closure U) (closure V) ",
    "∀ {α : Type u} [inst : TopologicalSpace α] [self : NormalSpace α] ⦃s t : Set α⦄,\n  IsClosed s → IsClosed t → Disjoint s t → ∃ u v, IsOpen u ∧ IsOpen v ∧ s ⊆ u ∧ t ⊆ v ∧ Disjoint (closure u) (closure v) ",
    "∀ {α : Type u} [inst : TopologicalSpace α] [self : NormalSpace α] ⦃s t : Set α⦄,\n  IsClosed s → IsClosed t → Disjoint s t → ∃ u v, IsOpen u ∧ IsOpen v ∧ s ⊆ u ∧ t ⊆ v ∧ Disjoint (closure u) (closure v) ",
    "∀ {α : Type u} [inst : TopologicalSpace α] [self : NormalSpace α] ⦃s t : Set α⦄,\n  IsClosed s → IsClosed t → Disjoint s t → ∃ u v, IsOpen u ∧ IsOpen v ∧ s ⊆ u ∧ t ⊆ v ∧ Disjoint (closure u) (closure v) "]},
  {"theorem":
   "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : NormalSpace α] {s : Set α}, IsClosed s → NormalSpace { x // x ∈ s }",
   "some-correct": null,
   "prompt": "Show that a closed subspace of a normal space is normal.",
   "groups":
   [["∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : NormalSpace α] {s : Set α}, IsClosed s → NormalSpace { x // x ∈ s }",
     "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : NormalSpace α] {S : Set α}, IsClosed S → NormalSpace { x // x ∈ S }",
     "∀ {α : Type u} [inst : TopologicalSpace α] [self : NormalSpace α] (s : Set α), IsClosed s → NormalSpace { x // x ∈ s }",
     "∀ {α : Type u} [inst : TopologicalSpace α] [self : NormalSpace α] {s : Set α}, IsClosed s → NormalSpace { x // x ∈ s }",
     "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : NormalSpace α] (A : Set α), IsClosed A → NormalSpace { x // x ∈ A }",
     "∀ {α : Type u} [inst : TopologicalSpace α] [self : NormalSpace α] (s : Set α), IsClosed s → NormalSpace { x // x ∈ s }",
     "∀ {α : Type u} [inst : TopologicalSpace α] [self : NormalSpace α] (s : Set α), IsClosed s → NormalSpace { x // x ∈ s }"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : NormalSpace α] {s : Set α},\n  IsClosed s → NormalSpace {x // x ∈ s} ",
    "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : NormalSpace α] {S : Set α},\n  IsClosed S → NormalSpace { x // x ∈ S } ",
    "∀ {α : Type u} [inst : TopologicalSpace α] [self : NormalSpace α] (s : Set α),\n  IsClosed s → NormalSpace { x // x ∈ s } ",
    "∀ {α : Type u} [inst : TopologicalSpace α] [self : NormalSpace α] {s : Set α},\n  IsClosed s → NormalSpace { x // x ∈ s } ",
    "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : NormalSpace α] (A : Set α),\n  IsClosed A → NormalSpace {x // x ∈ A} ",
    "∀ {α : Type u} [inst : TopologicalSpace α] [self : NormalSpace α] (s : Set α),\n  IsClosed s → NormalSpace { x // x ∈ s } ",
    "∀ {α : Type u} [inst : TopologicalSpace α] [self : NormalSpace α] (s : Set α),\n  IsClosed s → NormalSpace { x // x ∈ s } "]},
  {"theorem":
   "∀ {α : Type u_1} {X_α : α → Type u_2} [inst : (a : α) → TopologicalSpace (X_α a)] [inst_1 : ∀ (a : α), Nonempty (X_α a)]\n  [inst_2 : RegularSpace ((a : α) → X_α a)] (a : α), RegularSpace (X_α a)",
   "some-correct": null,
   "prompt":
   "Show that if `Π X_α` is regular, then so is `X_α`. Assume that each `X_α` is nonempty.",
   "groups":
   [["∀ {α : Type u_1} {X_α : α → Type u_2} [inst : (a : α) → TopologicalSpace (X_α a)] [inst_1 : ∀ (a : α), Nonempty (X_α a)]\n  [inst_2 : RegularSpace ((a : α) → X_α a)] (a : α), RegularSpace (X_α a)",
     "∀ {ι : Type u_1} {X : ι → Type u_2} [inst : (i : ι) → TopologicalSpace (X i)] [inst_1 : ∀ (i : ι), Nonempty (X i)]\n  [inst_1 : RegularSpace ((i : ι) → X i)] (i : ι), RegularSpace (X i)"],
    ["∀ {ι : Type u_1} {X : ι → Type u_2} [inst : (i : ι) → TopologicalSpace (X i)] [inst_1 : ∀ (i : ι), T2Space (X i)]\n  [inst_2 : Nonempty ι] [inst_3 : ∀ (i : ι), Nonempty (X i)] [inst_4 : RegularSpace ((i : ι) → X i)] (i : ι),\n  RegularSpace (X i)"],
    ["∀ {ι : Type u_1} {X : ι → Type u_2} [inst : (i : ι) → TopologicalSpace (X i)] [inst_1 : ∀ (i : ι), Nonempty (X i)]\n  [inst_2 : ∀ (i : ι), RegularSpace (X i)], RegularSpace ((i : ι) → X i)"],
    ["∀ {ι : Type u_1} {X : ι → Type u_2} [inst : (i : ι) → TopologicalSpace (X i)] [inst_1 : ∀ (i : ι), Nonempty (X i)]\n  [inst_1 : ∀ (i : ι), T2Space (X i)] [inst_2 : TopologicalSpace.SecondCountableTopology ((i : ι) → X i)],\n  RegularSpace ((i : ι) → X i) → ∀ (i : ι), RegularSpace (X i)"],
    ["∀ {ι : Type u_1} {X : ι → Type u_2} [inst : (i : ι) → TopologicalSpace (X i)] [inst_1 : ∀ (i : ι), Nonempty (X i)]\n  [inst_1 : ∀ (i : ι), T2Space (X i)] [inst_2 : ∀ (i : ι), RegularSpace (X i)], RegularSpace ((i : ι) → X i)"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   ["forall {ι : Type u_1} {X : ι → Type u_2} [inst : (i : ι) → TopologicalSpace (X i)]\n  [inst : (i : ι) → Nonempty (X i)] [inst_1 : (i : ι) → T2Space (X i)] [inst_2 : (i : ι) → RegularSpace (X i)],\n  RegularSpace ((i : ι) → X i) ",
    "∀ {ι : Type u_1} {X : ι → Type u_2} [inst : (i : ι) → TopologicalSpace (X i)] [inst : (i : ι) → Nonempty (X i)] [inst : (i : ι) → RegularSpace (X i)],\n  RegularSpace ((i : ι) → X i) ",
    "∀ {ι : Type u_1} {X : ι → Type u_2} [inst : ∀ (i : ι), TopologicalSpace (X i)] [inst : ∀ (i : ι), Nonempty (X i)]\n  [inst_1 : ∀ (i : ι), T2Space (X i)] [inst_2 : TopologicalSpace.SecondCountableTopology (Π i, X i)],\n  RegularSpace (Π i, X i) → ∀ (i : ι), RegularSpace (X i) ",
    "∀ {α : Type u_1} {X_α : α → Type u_2} [inst : (a : α) → TopologicalSpace (X_α a)] [inst_1 : (∀ (a : α), Nonempty (X_α a))]\n  [inst_2 : RegularSpace ((a : α) → X_α a)], (a : α) → RegularSpace (X_α a) ",
    "∀ {ι : Type u_1} {X : ι → Type u_2} [inst : ∀ (i : ι), TopologicalSpace (X i)] [inst_1 : ∀ (i : ι), T2Space (X i)]\n  [inst_2 : Nonempty ι] [inst_3 : ∀ (i : ι), Nonempty (X i)] [inst_4 : RegularSpace ((i : ι) → X i)],\n  ∀ (i : ι), RegularSpace (X i) ",
    "forall {ι : Type u_1} {X : ι → Type u_2} [inst : (i : ι) → TopologicalSpace (X i)]\n  [inst : (i : ι) → Nonempty (X i)] [inst_1 : RegularSpace ((i : ι) → X i)],\n  forall (i : ι), RegularSpace (X i) "]},
  {"theorem":
   "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] [inst_2 : T2Space α], RegularSpace α",
   "some-correct": null,
   "prompt": "Show that every locally compact Hausdorff space is regular.",
   "groups":
   [["∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] [inst_2 : T2Space α], RegularSpace α",
     "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] [inst_2 : T2Space α], RegularSpace α",
     "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] [inst_2 : T2Space α], RegularSpace α",
     "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] [inst_2 : T2Space α], RegularSpace α",
     "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] [inst_2 : T2Space α], RegularSpace α",
     "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] [inst_2 : T2Space α], RegularSpace α",
     "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] [inst_2 : T2Space α], RegularSpace α",
     "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T2Space α] [inst_2 : LocallyCompactSpace α], RegularSpace α",
     "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] [inst_2 : T2Space α], RegularSpace α",
     "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] [inst_2 : T2Space α], RegularSpace α"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] [inst_2 : T2Space α], RegularSpace α ",
    "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] [inst_2 : T2Space α],\n  RegularSpace α ",
    "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] [inst_2 : T2Space α],\n  RegularSpace α ",
    "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] [inst_2 : T2Space α], RegularSpace α ",
    "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] [inst_2 : T2Space α], RegularSpace α ",
    "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] [inst_2 : T2Space α],\n  RegularSpace α ",
    "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] [inst_2 : T2Space α], RegularSpace α ",
    "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T2Space α] [inst_2 : LocallyCompactSpace α], RegularSpace α ",
    "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] [inst_2 : T2Space α],\n  RegularSpace α ",
    "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] [inst_2 : T2Space α],\n  RegularSpace α "]},
  {"theorem":
   "∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : NormalSpace X] {A B : Set X},\n  IsClosed A →\n    IsClosed B →\n      Disjoint A B → IsCompact A → ∃ f, Set.EqOn f 0 A ∧ Set.EqOn f 1 B ∧ ∀ (x : X), ?m.2980018 f x ∈ Set.Icc 0 1",
   "some-correct": false,
   "prompt":
   "Let `X` be completely regular, let `A` and `B` be disjoint closed subsets of `X`. Show that if `A` is compact, there is a continuous function `f: X → [0, 1]` such that `f(A) = {0}` and `f(B) = {1}`.",
   "groups":
   [["∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : NormalSpace X] {A B : Set X},\n  IsClosed A →\n    IsClosed B →\n      Disjoint A B → IsCompact A → ∃ f, Set.EqOn f 0 A ∧ Set.EqOn f 1 B ∧ ∀ (x : X), ?m.2980018 f x ∈ Set.Icc 0 1"],
    ["∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : NormalSpace X] [inst_2 : T1Space X] {A B : Set X},\n  IsCompact A →\n    IsClosed B → Disjoint A B → ∃ f, Set.EqOn f 0 A ∧ Set.EqOn f 1 B ∧ ∀ (x : X), ?m.2963658 f x ∈ Set.Icc 0 1"],
    ["∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : T0Space X] [inst_2 : LocallyCompactSpace X] {A B : Set X},\n  IsCompact A →\n    IsClosed A →\n      IsClosed B → Disjoint A B → ∃ f, Set.EqOn f 0 A ∧ Set.EqOn f 1 B ∧ ∀ (x : X), ?m.2971849 f x ∈ Set.Icc 0 1"]],
   "correct": false,
   "comments": "Undefined extra term, not sure if the assumptions imply the space is completely regular. Coercion error in the rest, `↑f`. Last output seems most accurate.",
   "all-elabs":
   ["∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : NormalSpace X] [inst_2 : T1Space X] {A B : Set X},\n  IsCompact A → IsClosed B → Disjoint A B → ∃ f, Set.EqOn (↑f) 0 A ∧ Set.EqOn (↑f) 1 B ∧ ∀ (x : X), ↑f x ∈ Set.Icc 0 1 ",
    "∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : T0Space X] [inst_2 : LocallyCompactSpace X] {A B : Set X},\n  IsCompact A → IsClosed A → IsClosed B → Disjoint A B → ∃ f, Set.EqOn (↑f) 0 A ∧ Set.EqOn (↑f) 1 B ∧ ∀ (x : X), ↑f x ∈ Set.Icc 0 1 ",
    "∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : NormalSpace X] {A B : Set X},\n  IsClosed A → IsClosed B → Disjoint A B → IsCompact A →\n    ∃ f, Set.EqOn (↑f) 0 A ∧ Set.EqOn (↑f) 1 B ∧ ∀ (x : X), ↑f x ∈ Set.Icc 0 1 "]},
  {"theorem": "∀ {V : Type u_1} [inst : AddGroup V] (v : V), - -v = v",
   "some-correct": null,
   "prompt": "Prove that `-(-v) = v` for every `v ∈ V`.",
   "groups":
   [["∀ {V : Type u_1} [inst : AddGroup V] (v : V), - -v = v",
     "∀ {V : Type u_1} [inst : AddGroup V] (v : V), - -v = v",
     "∀ {V : Type u_1} [inst : AddGroup V] (v : V), - -v = v",
     "∀ {V : Type u_1} [inst : AddGroup V] (v : V), - -v = v",
     "∀ {α : Type u_1} [inst : AddGroup α] (v : α), - -v = v",
     "∀ {V : Type u_1} [inst : AddGroup V] (v : V), - -v = v",
     "∀ {V : Type u_1} [inst : AddGroup V] (v : V), - -v = v",
     "∀ {V : Type u_2} [inst : AddGroup V] (v : V), - -v = v",
     "∀ {V : Type u_1} [inst : AddGroup V] (v : V), - -v = v"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   ["∀ {V : Type u_1} [inst : AddGroup V] (v : V), -(-v) = v ",
    "∀ {V : Type u_1} [inst : AddGroup V] (v : V), -(-v) = v ",
    "∀ {V : Type u_1} [inst : AddGroup V] (v : V), -(-v) = v ",
    "∀ {V : Type u_1} [inst : AddGroup V] (v : V), -(-v) = v ",
    "∀ {α : Type u_1} [inst : AddGroup α] (v : α), -(-v) = v ",
    "forall {V : Type u_1} [inst : AddGroup V] (v : V), -(-v) = v ",
    "∀ {V : Type u_1} [inst : AddGroup V] (v : V), -(-v) = v ",
    "∀ {V : Type u_2} [inst : AddGroup V] (v : V), -(-v) = v ",
    "∀ {V : Type u_1} [inst : AddGroup V] (v : V), -(-v) = v "]},
  {"theorem":
   "∃ U,\n  (∀ (u v : ℝ × ℝ), u ∈ U → v ∈ U → u + v ∈ U) ∧\n    (∀ (u : ℝ × ℝ), u ∈ U → -u ∈ U) ∧ ¬∀ (a : ℝ) (u : ℝ × ℝ), u ∈ U → (a * u.fst, a * u.snd) ∈ U",
   "some-correct": false,
   "prompt":
   "Give an example of a nonempty subset `U` of `ℝ^2` such that `U` is closed under addition and under taking additive inverses (meaning `-u ∈ U` whenever `u ∈ U`), but `U` is not a subspace of `ℝ^2`.",
   "groups":
   [["∃ U,\n  (∀ (u v : ℝ × ℝ), u ∈ U → v ∈ U → u + v ∈ U) ∧\n    (∀ (u : ℝ × ℝ), u ∈ U → -u ∈ U) ∧ ¬∀ (a : ℝ) (u : ℝ × ℝ), u ∈ U → (a * u.fst, a * u.snd) ∈ U"]],
   "correct": false,
   "comments": "Nonempty condition not present. Also `U` is not recognized as a subspace of `ℝ × ℝ`. Other output has everything except nonempty condition.",
   "all-elabs":
   ["example : ∃ (U : Set (ℝ × ℝ)), (∀ (u v : ℝ × ℝ), u ∈ U → v ∈ U → u + v ∈ U) ∧ (∀ (u : ℝ × ℝ), u ∈ U → -u ∈ U) ∧ ¬(∀ (a : ℝ) (u : ℝ × ℝ), u ∈ U → (a * u.1, a * u.2) ∈ U) "]},
  {"theorem":
   "{K : Type u} →\n  {V : Type v} →\n    [inst : Field K] →\n      [inst_1 : AddCommGroup V] → [inst_2 : Module K V] → {ι : Sort u_1} → (ι → Submodule K V) → Submodule K V",
   "some-correct": null,
   "prompt":
   "Prove that the intersection of any collection of subspaces of `V` is a subspace of `V`.",
   "groups":
   [["{K : Type u} →\n  {V : Type v} →\n    [inst : Field K] →\n      [inst_1 : AddCommGroup V] → [inst_2 : Module K V] → {ι : Sort u_1} → (ι → Submodule K V) → Submodule K V"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   ["∀ {K : Type u} {V : Type v} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Sort u_1}\n  (s : ι → Submodule K V), Submodule K V "]},
  {"theorem":
   "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V], Module.rank K V = 1 → ∀ (T : V →ₗ[K] V), ∃ a, ∀ (v : V), ↑T v = a • v",
   "some-correct": true,
   "prompt":
   "Show that every linear map from a one-dimensional vector space to itself is multiplication by some scalar. More precisely, prove that if `dim V = 1` and `T ∈ L(V, V)`, then there exists `a ∈ F` such that `T v = a v` for all `v ∈ V`.",
   "groups":
   [["∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V], Module.rank K V = 1 → ∀ (T : V →ₗ[K] V), ∃ a, ∀ (v : V), ↑T v = a • v",
     "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V], Module.rank K V = 1 → ∀ (T : V →ₗ[K] V), ∃ a, ∀ (v : V), ↑T v = a • v",
     "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V], Module.rank K V = 1 → ∀ (T : V →ₗ[K] V), ∃ a, ∀ (v : V), ↑T v = a • v",
     "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V], Module.rank K V = 1 → ∀ (T : V →ₗ[K] V), ∃ a, ∀ (v : V), ↑T v = a • v",
     "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V], Module.rank K V = 1 → ∀ (T : V →ₗ[K] V), ∃ a, ∀ (v : V), ↑T v = a • v"],
    ["∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 1 → ∀ (T : V →ₗ[K] V), ∃ a, ∀ (v : V), ↑T v = a • v"]],
   "correct": false,
   "comments": "Scalar multiplication not recognized since `a` is not specified to be an element of `K`, also coercion of `T` not recognized. Also it is a generalization since `K` is not a field. Same with other outputs, third output is accurate.",
   "all-elabs":
   ["∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] [inst_3 : FiniteDimensional K V],\n  Module.rank K V = 1 → ∀ (f : V →ₗ[K] V), ∃ (a : K), ∀ (v : V), ↑f v = a • v ",
    "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V], Module.rank K V ≤ 1 → ∀ (T : V →ₗ[K] V), ∃ a, ∀ (v : V), ↑T v = a • v ",
    "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V], Module.rank K V = 1 → ∀ (T : V →ₗ[K] V), ∃ a : K, ∀ (v : V), T v = a • v ",
    "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V], Module.rank K V = 1 → ∀ (T : V →ₗ[K] V), ∃ (a : K), ∀ (v : V), T v = a • v ",
    "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V], Module.rank K V = 1 → ∀ (f : V →ₗ[K] V), ∃ (a : K), ∀ (v : V), ↑f v = a • v ",
    "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 1 → ∀ (T : V →ₗ[K] V), ∃ a : K, ∀ (v : V), T v = a • v ",
    "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V], Module.rank K V = 1 → ∀ (T : V →ₗ[K] V), ∃ a : K, ∀ (v : V), T v = a • v ",
    "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V], Module.rank K V = 1 → ∀ (T : V →ₗ[K] V), ∃ a : K, ∀ v : V, T v = a • v ",
    "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V] {f : V →ₗ[K] V}, Module.rank K V = 1 → ∃ a, ∀ (v : V), ↑f v = a • v ",
    "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V], Module.rank K V = 1 → ∀ (T : V →ₗ[K] V), ∃ a : K, ∀ v : V, T v = a • v "]},
  {"theorem":
   "∀ {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R] {p : Polynomial R},\n  Polynomial.natDegree p = ↑Multiset.card (Polynomial.roots p) ↔ ∀ (a : R), Polynomial.rootMultiplicity a p ≤ 1",
   "some-correct": false,
   "prompt":
   "Suppose `p ∈ P(ℂ)` has degree `m`. Prove that `p` has `m` distinct roots if and only if `p` and its derivative `p'` have no roots in common.",
   "groups":
   [["∀ {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R] {p : Polynomial R},\n  Polynomial.natDegree p = ↑Multiset.card (Polynomial.roots p) ↔ ∀ (a : R), Polynomial.rootMultiplicity a p ≤ 1"]],
   "correct": false,
   "comments": "No mention of derivative. Third output is most correct, there seems to be an issue with `Polynomial.derivative`.",
   "all-elabs":
   ["∀ {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R] {p : Polynomial R},\n  Polynomial.natDegree p = Multiset.card (Polynomial.roots p) ↔\n    ∀ (a : R), Polynomial.rootMultiplicity a p ≤ 1 ",
    "∀ {p : Polynomial ℂ} {m : ℕ},\n  Polynomial.natDegree p = m →\n    (p ≠ 0 →\n       (∀ a, Polynomial.IsRoot p a ↔ Polynomial.IsRoot (↑Polynomial.derivative p) a → False) ↔\n         m = Multiset.card (Polynomial.roots p)) ",
    "∀ {p : Polynomial ℂ},\n  Polynomial.natDegree p = Finset.card (Multiset.toFinset (Polynomial.roots p)) ↔\n  Multiset.Disjoint (Polynomial.roots p) (Polynomial.roots (↑Polynomial.derivative p)) ",
    "∀ {m : ℕ} {p : Polynomial ℂ},\n  Polynomial.natDegree p = m →\n    ((∀ a : ℂ, Polynomial.rootMultiplicity a p ≤ 1) ↔\n     ∀ a : ℂ, ¬Polynomial.IsRoot p a ∨ ¬Polynomial.IsRoot (↑Polynomial.derivative p) a) "]},
  {"theorem":
   "∀ {K : Type u_1} {V : Type u_2} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (T : Module.End K V),\n  (∀ (v : V), v ≠ 0 → ∃ c, ↑T v = c • v) → ∃ c, ∀ (v : V), ↑T v = c • v",
   "some-correct": null,
   "prompt":
   "Suppose `T ∈ L(V)` is such that every vector in `V` is an eigenvector of `T`. Prove that `T` is a scalar multiple of the identity operator.",
   "groups":
   [["∀ {K : Type u_1} {V : Type u_2} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (T : Module.End K V),\n  (∀ (v : V), v ≠ 0 → ∃ c, ↑T v = c • v) → ∃ c, ∀ (v : V), ↑T v = c • v"]],
   "correct": false,
   "comments": "Coercion problem, and cannot identify type of `c`. Second last output is correct.",
   "all-elabs":
   ["∀ {K : Type v} {V : Type w} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (T : Module.End K V),\n  (∀ (v : V), v ≠ 0 → ∃ (c : K), Module.End.HasEigenvector T c v) → ∃ (c : K), T = c • LinearMap.id ",
    "∀ {K : Type u} {V : Type v} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (T : Module.End K V)\n  (h_eigvec : ∀ (v : V), v ≠ 0 → ∃ (μ : K), T v = μ • v),\n  ∃ (c : K), T = c • LinearMap.id ",
    "∀ {K : Type u_1} {V : Type u_2} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (T : Module.End K V),\n  (∀ (v : V), ∃ (c : K), T v = c • v) → (∃ (c : K), T = c • LinearMap.id) ",
    "forall {K : Type u_1} [inst : Field K] {V : Type u_2} [inst_1 : AddCommGroup V] [inst_2 : Module K V] (T : Module.End K V),\n  (∀ (v : V), v ≠ 0 → ∃ c, T v = c • v) → (∃ c, T = c • (LinearMap.id : Module.End K V)) ",
    "∀ {K : Type u_1} {V : Type u_2} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (T : Module.End K V),\n  (∀ (v : V), v ≠ 0 → ∃ (c : K), T v = c • v) → (∃ (c : K), ∀ (v : V), T v = c • v) ",
    "∀ {K : Type u_1} {V : Type u_2} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {T : Module.End K V},\n  (∀ (v : V), v ≠ 0 → ∃ c, T v = c • v) → (∃ c, T = c • 1) "]},
  {"theorem":
   "∀ {𝕜 : Type u_1} [inst : Field 𝕜] {V : Type u_2} [inst_1 : AddCommGroup V] [inst_2 : Module 𝕜 V]\n  [inst_3 : FiniteDimensional 𝕜 V] {T S : V →ₗ[𝕜] V},\n  Fintype.card (Module.End.Eigenvalues T) = FiniteDimensional.finrank 𝕜 V →\n    (∀ (x : V) (μ : 𝕜), x ∈ Module.End.eigenspace S μ ↔ x ∈ Module.End.eigenspace T μ) →\n      LinearMap.comp S T = LinearMap.comp T S",
   "some-correct": null,
   "prompt":
   "Suppose that `T ∈ L(V)` has `dim V` distinct eigenvalues and that `S ∈ L(V)` has the same eigenvectors as `T` (not necessarily with the same eigenvalues). Prove that `S T = T S`.",
   "groups":
   [["∀ {𝕜 : Type u_1} [inst : Field 𝕜] {V : Type u_2} [inst_1 : AddCommGroup V] [inst_2 : Module 𝕜 V]\n  [inst_3 : FiniteDimensional 𝕜 V] {T S : V →ₗ[𝕜] V},\n  Fintype.card (Module.End.Eigenvalues T) = FiniteDimensional.finrank 𝕜 V →\n    (∀ (x : V) (μ : 𝕜), x ∈ Module.End.eigenspace S μ ↔ x ∈ Module.End.eigenspace T μ) →\n      LinearMap.comp S T = LinearMap.comp T S"]],
   "correct": false,
   "comments": "Get the following error : failed to synthesize instance `Fintype (Module.End.Eigenvalues T)`. Same for other outputs.",
   "all-elabs":
   ["∀ {𝕜 : Type u_1} [inst : Field 𝕜] {V : Type u_2} [inst_1 : AddCommGroup V] [inst_2 : Module 𝕜 V] [inst_3 : FiniteDimensional 𝕜 V]\n  {T S : V →ₗ[𝕜] V},\n  Fintype.card (Module.End.Eigenvalues T) = FiniteDimensional.finrank 𝕜 V →\n    (∀ (x : V) (μ : 𝕜), x ∈ Module.End.eigenspace S μ ↔ x ∈ Module.End.eigenspace T μ) → S.comp T = T.comp S "]},
  {"theorem":
   "∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {U V : Submodule 𝕜 E}, U ≤ V → (Uᗮ = ⊥ ↔ U = V)",
   "some-correct": null,
   "prompt":
   "Suppose `U` is a subspace of `V`. Prove that `U⊥ = {0}` if and only if `U = V`.",
   "groups":
   [["∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {U V : Submodule 𝕜 E}, U ≤ V → (Uᗮ = ⊥ ↔ U = V)",
     "∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {U V : Submodule 𝕜 E}, U ≤ V → (Uᗮ = ⊥ ↔ U = V)",
     "∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {U V : Submodule 𝕜 E}, U ≤ V → (Uᗮ = ⊥ ↔ U = V)"],
    ["∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {U V : Submodule 𝕜 E}, Uᗮ = ⊥ ↔ U = V",
     "∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {U V : Submodule 𝕜 E}, Uᗮ = ⊥ ↔ U = V"],
    ["∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {U V : Submodule 𝕜 E}, U ≤ V → Uᗮ = ⊥ ↔ U = V"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   ["∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {U V : Submodule 𝕜 E}, U ≤ V → (Uᗮ = ⊥ ↔ U = V) ",
    "∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {U V : Submodule 𝕜 E} ,\n  Uᗮ = ⊥ ↔ U = V ",
    "∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {U V : Submodule 𝕜 E}, U ≤ V → Uᗮ = ⊥ ↔ U = V ",
    "∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {U V : Submodule 𝕜 E}, U ≤ V → (Uᗮ = ⊥ ↔ U = V) ",
    "∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {U V : Submodule 𝕜 E}, U ≤ V → (Uᗮ = ⊥ ↔ U = V) ",
    "∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {U V : Submodule 𝕜 E},\n  Uᗮ = ⊥ ↔ U = V "]},
  {"theorem": "∀ {n : ℕ}, Odd n → 8 ∣ n ^ 2 - 1",
   "some-correct": null,
   "prompt": "For all odd `n` show that `8 | n^2 - 1`.",
   "groups":
   [["∀ {n : ℕ}, Odd n → 8 ∣ n ^ 2 - 1",
     "∀ {n : ℕ}, Odd n → 8 ∣ n ^ 2 - 1",
     "∀ {n : ℕ}, Odd n → 8 ∣ n ^ 2 - 1",
     "∀ {n : ℕ}, Odd n → 8 ∣ n ^ 2 - 1",
     "∀ {n : ℕ}, Odd n → 8 ∣ n ^ 2 - 1",
     "∀ {n : ℕ}, Odd n → 8 ∣ n ^ 2 - 1",
     "∀ {n : ℕ}, Odd n → 8 ∣ n ^ 2 - 1",
     "∀ {n : ℕ}, Odd n → 8 ∣ n ^ 2 - 1",
     "∀ {n : ℕ}, Odd n → 8 ∣ n ^ 2 - 1",
     "∀ {n : ℕ}, Odd n → 8 ∣ n ^ 2 - 1"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   ["forall_odd_n_eight_divides_pow_minus_one : ∀ {n : ℕ}, Odd n → 8 ∣ n ^ 2 - 1 ",
    "∀ {n : ℕ}, Odd n → 8 ∣ (n ^ 2 - 1) ",
    "forall {n : ℕ}, Odd n → 8 ∣ (n ^ 2 - 1) ",
    "∀ {n : ℕ}, Odd n → 8 ∣ n ^ 2 - 1 ",
    "forall_odd_n_8_dvd_n_squared_minus_one : ∀ {n : ℕ}, Odd n → 8 ∣ (n ^ 2 - 1) ",
    "∀ {n : ℕ}, Odd n → 8 ∣ n ^ 2 - 1 ",
    "forall_odd_n_eight_divides_nsq_minus_one : ∀ {n : ℕ}, Odd n → 8 ∣ n ^ 2 - 1 ",
    "∀ {n : ℕ}, Odd n → 8 ∣ (n^2 - 1) ",
    "∀ {n : ℕ}, Odd n → 8 ∣ (n ^ 2 - 1) ",
    "∀ {n : ℕ}, Odd n → 8 ∣ (n ^ 2 - 1) "]},
  {"theorem": "IsSquare 2",
   "some-correct": false,
   "prompt": "Show that 2 is divisible by `(1 + i)^2` in `ℤ[i]`.",
   "groups": [["IsSquare 2"]],
   "correct": false,
   "comments": "No information captured.",
   "all-elabs": ["IsSquare 2 "]}],
 "elaborated": 17}