{"total-prompts": 40,
 "temperature": 0.8,
 "query-number": 5,
 "number-similar-sentences": 10,
 "include-fixed": false,
 "failures": ["There is no field of order `10`."],
 "elaborated-prompts":
 [{"theorem": "∀ {p : ℕ}, Nat.Prime p → p = 2 ∨ p % 2 = 1",
   "some-correct": null,
   "prompt": "Every prime number is `2` or odd.",
   "groups":
   [["∀ {p : ℕ}, Nat.Prime p → p = 2 ∨ p % 2 = 1",
     "∀ {p : ℕ}, Nat.Prime p → p = 2 ∨ p % 2 = 1",
     "∀ {p : ℕ}, Nat.Prime p → p = 2 ∨ p % 2 = 1",
     "∀ (p : ℕ), Nat.Prime p → p = 2 ∨ p % 2 = 1",
     "∀ {p : ℕ}, Nat.Prime p → p = 2 ∨ p % 2 = 1",
     "∀ {p : ℕ}, Nat.Prime p → p = 2 ∨ p % 2 = 1",
     "∀ {p : ℕ}, Nat.Prime p → p = 2 ∨ p % 2 = 1",
     "∀ {p : ℕ}, Nat.Prime p → p = 2 ∨ p % 2 = 1",
     "∀ {p : ℕ}, Nat.Prime p → p = 2 ∨ p % 2 = 1"],
    ["∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p = 2 ∨ p % 2 = 1"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   ["∀ {p : ℕ}, Nat.Prime p → p = 2 ∨ p % 2 = 1 ",
    "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p = 2 ∨ p % 2 = 1 ",
    "∀ {p : ℕ}, Nat.Prime p → p = 2 ∨ p % 2 = 1 ",
    "∀ {p : ℕ}, Nat.Prime p → p = 2 ∨ p % 2 = 1 ",
    "∀ (p : ℕ), Nat.Prime p → p = 2 ∨ p % 2 = 1 ",
    "∀ {p : ℕ}, Nat.Prime p → p = 2 ∨ p % 2 = 1 ",
    "∀ {p : ℕ}, Nat.Prime p → p = 2 ∨ p % 2 = 1 ",
    "∀ {p : ℕ}, Nat.Prime p → p = 2 ∨ p % 2 = 1 ",
    "∀ {p : ℕ}, Nat.Prime p → p = 2 ∨ p % 2 = 1 ",
    "∀ {p : ℕ}, Nat.Prime p → p = 2 ∨ p % 2 = 1 "]},
  {"theorem": "Set.Infinite {n | Odd n}",
   "some-correct": null,
   "prompt": "There are infinitely many odd natural numbers.",
   "groups":
   [["Set.Infinite {n | Odd n}",
     "Set.Infinite {n | Odd n}",
     "Set.Infinite {n | Odd n}",
     "Set.Infinite {x | Odd x}",
     "Set.Infinite {n | Odd n}"],
    ["∃ᶠ (m : ℕ) in Filter.atTop, Odd m"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   ["Set.Infinite {n : ℕ | Odd n} ",
    "Set.Infinite {n : ℕ | Odd n} ",
    "Set.Infinite {n : ℕ | Odd n} ",
    "Set.Infinite {x : ℕ | Odd x} ",
    "∃ᶠ (m : ℕ) in Filter.atTop, Odd m ",
    "Set.Infinite {n : ℕ | Odd n} "]},
  {"theorem": "∀ {p : ℕ}, Nat.Prime p → p % 2 = 1 → p = 3",
   "some-correct": true,
   "prompt": "The smallest odd prime is `3`.",
   "groups": [["∀ {p : ℕ}, Nat.Prime p → p % 2 = 1 → p = 3"]],
   "correct": false,
   "comments": "",
   "all-elabs":
   ["Nat.Prime.min_odd_prime_is_3 : Nat.Prime 3 ∧ ∀ (n : ℕ), Nat.Prime n → n % 2 = 1 → 3 ≤ n ",
    "Nat.min_odd_prime_is_3 : Nat.minFac 9 = 3 ",
    "Nat.min_fac_odd_prime : ∀ {p : ℕ}, Nat.Prime p → p % 2 = 1 → p = 3 "]},
  {"theorem": "Set.Infinite {p | Nat.Prime p ∧ Odd p}",
   "some-correct": null,
   "prompt": "There are infinitely many odd prime numbers.",
   "groups":
   [["Set.Infinite {p | Nat.Prime p ∧ Odd p}",
     "Set.Infinite {p | Nat.Prime p ∧ Odd p}",
     "Set.Infinite {p | Nat.Prime p ∧ Odd p}",
     "Set.Infinite {p | Nat.Prime p ∧ Odd p}",
     "Set.Infinite {p | Nat.Prime p ∧ Odd p}",
     "Set.Infinite {p | Nat.Prime p ∧ Odd p}",
     "Set.Infinite {p | Nat.Prime p ∧ Odd p}",
     "Set.Infinite {p | Nat.Prime p ∧ Odd p}",
     "Set.Infinite {p | Nat.Prime p ∧ Odd p}"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   ["Set.Infinite {p | Nat.Prime p ∧ Odd p} ",
    "Set.Infinite {p : ℕ | Nat.Prime p ∧ Odd p} ",
    "Set.Infinite {p | Nat.Prime p ∧ Odd p} ",
    "Set.Infinite {p | Nat.Prime p ∧ Odd p} ",
    "Set.Infinite {p | Nat.Prime p ∧ Odd p} ",
    "Set.Infinite {p : ℕ | Nat.Prime p ∧ Odd p} ",
    "Set.Infinite {p : ℕ | Nat.Prime p ∧ Odd p} ",
    "Set.Infinite {p | Nat.Prime p ∧ Odd p} ",
    "Set.Infinite {p | Nat.Prime p ∧ Odd p} "]},
  {"theorem":
   "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V",
   "some-correct": null,
   "prompt":
   "If a vector space has dimension `2` then it is finite dimensional.",
   "groups":
   [["∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V",
     "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V",
     "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V",
     "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V",
     "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V",
     "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V",
     "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V",
     "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V",
     "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V",
     "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   ["∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V ",
    "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V ",
    "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V ",
    "forall {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V ",
    "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V ",
    "forall {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V], \n  Module.rank K V = 2 → FiniteDimensional K V ",
    "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V ",
    "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V ",
    "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V ",
    "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V "]},
  {"theorem": "{K : Type u} → [inst : Field K] → DivisionRing K",
   "some-correct": null,
   "prompt": "Every field is a division ring.",
   "groups":
   [["{K : Type u} → [inst : Field K] → DivisionRing K",
     "{K : Type u} → [inst : Field K] → DivisionRing K",
     "{K : Type u} → [inst : Field K] → DivisionRing K",
     "{K : Type u} → [inst : Field K] → DivisionRing K"],
    ["{K : Type u_1} → [inst : Field K] → DivisionRing K",
     "{K : Type u_1} → [inst : Field K] → DivisionRing K",
     "{K : Type u_1} → [inst : Field K] → DivisionRing K"],
    ["(K : Type u) → [inst : Field K] → DivisionRing K",
     "(K : Type u) → [inst : Field K] → DivisionRing K"],
    ["(K : Type u) → [inst : Field K] → DivisionRing K"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   ["∀ (K : Type u) [inst : Field K], DivisionRing K ",
    "∀ {K : Type u} [inst : Field K], DivisionRing K ",
    "forall (K : Type u) [inst : Field K], DivisionRing K ",
    "∀ (K : Type u) [inst : Field K], DivisionRing K ",
    "∀ {K : Type u_1} [inst : Field K], DivisionRing K ",
    "∀ {K : Type u} [inst : Field K], DivisionRing K ",
    "∀ {K : Type u_1} [inst : Field K], DivisionRing K ",
    "∀ {K : Type u_1} [inst : Field K], DivisionRing K ",
    "∀ {K : Type u} [inst : Field K], DivisionRing K ",
    "∀ {K : Type u} [inst : Field K], DivisionRing K "]},
  {"theorem":
   "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V",
   "some-correct": null,
   "prompt": "If a space has dimension `2` then it is finite dimensional.",
   "groups":
   [["∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V",
     "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V",
     "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V",
     "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V",
     "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V",
     "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V",
     "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V",
     "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V",
     "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V",
     "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   ["forall {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V ",
    "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V ",
    "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V ",
    "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V ",
    "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V], Module.rank K V = 2 → FiniteDimensional K V ",
    "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V ",
    "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V ",
    "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V ",
    "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V ",
    "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V "]},
  {"theorem": "∀ (n : ℕ), ∃ m, m = n + 1",
   "some-correct": null,
   "prompt": "Every natural number has a successor.",
   "groups":
   [["∀ (n : ℕ), ∃ m, m = n + 1",
     "∀ (n : ℕ), ∃ k, n + 1 = k",
     "∀ (n : ℕ), ∃ m, m = n + 1",
     "∀ (n : ℕ), ∃ k, n + 1 = k",
     "∀ (n : ℕ), ∃ k, n + 1 = k",
     "∀ (n : ℕ), ∃ m, m = n + 1",
     "∀ (n : ℕ), ∃ m, m = n + 1",
     "∀ (n : ℕ), ∃ k, n + 1 = k",
     "∀ (n : ℕ), ∃ m, m = n + 1",
     "∀ (n : ℕ), ∃ m, m = n + 1"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   ["∀ (n : ℕ), ∃ m, m = n + 1 ",
    "∀ (n : ℕ), ∃ k, n + 1 = k ",
    "∀ (n : ℕ), ∃ m, m = n + 1 ",
    "∀ (n : ℕ), ∃ k, n + 1 = k ",
    "∀ (n : ℕ), ∃ k, n + 1 = k ",
    "∀ (n : ℕ), ∃ (m : ℕ), m = n + 1 ",
    "∀ (n : ℕ), ∃ m, m = n + 1 ",
    "∀ (n : ℕ), ∃ k, n + 1 = k ",
    "∀ (n : ℕ), ∃ m, m = n + 1 ",
    "∀ (n : ℕ), ∃ (m : ℕ), m = n + 1 "]},
  {"theorem": "∀ {n : ℕ}, n < n + 1",
   "some-correct": null,
   "prompt": "Every natural number is less than its successor.",
   "groups":
   [["∀ {n : ℕ}, n < n + 1",
     "∀ (n : ℕ), n < n + 1",
     "∀ {n : ℕ}, n < n + 1",
     "∀ (n : ℕ), n < n + 1",
     "∀ (n : ℕ), n < n + 1",
     "∀ {n : ℕ}, n < Nat.succ n",
     "∀ {n : ℕ}, n < Nat.succ n",
     "∀ {n : ℕ}, n < n + 1",
     "∀ (n : ℕ), n < Nat.succ n",
     "∀ {n : ℕ}, n < n + 1"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   ["∀ {n : ℕ}, n < n + 1 ",
    "∀ (n : ℕ), n < n + 1 ",
    "∀ {n : ℕ}, n < n + 1 ",
    "∀ n : ℕ, n < n + 1 ",
    "∀ (n : ℕ), n < n + 1 ",
    "∀ {n : ℕ}, n < Nat.succ n ",
    "∀ {n : ℕ}, n < Nat.succ n ",
    "∀ {n : ℕ}, n < n + 1 ",
    "∀ (n : ℕ), n < n.succ ",
    "∀ {n : ℕ}, n < n + 1 "]},
  {"theorem":
   "∀ {α : Type u_1} [inst : MeasurableSpace α] (s : Set α), MeasurableSet s",
   "some-correct": null,
   "prompt": "Every set is Lebesgue measurable.",
   "groups":
   [["∀ {α : Type u_1} [inst : MeasurableSpace α] (s : Set α), MeasurableSet s"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u_1} [inst : MeasurableSpace α], ∀ s : Set α, MeasurableSet s "]},
  {"theorem":
   "∀ {α : Type u_1} [inst : MeasurableSpace α] [inst_1 : TopologicalSpace α]\n  [inst_2 : TopologicalSpace.SecondCountableTopology α] [inst_3 : OpensMeasurableSpace α] (μ : MeasureTheory.Measure α)\n  (s : Set α), ?m.963093 μ s = 0 → MeasurableSet s",
   "some-correct": null,
   "prompt": "Every set of Borel measure zero is Lebesgue measurable.",
   "groups":
   [["∀ {α : Type u_1} [inst : MeasurableSpace α] [inst_1 : TopologicalSpace α]\n  [inst_2 : TopologicalSpace.SecondCountableTopology α] [inst_3 : OpensMeasurableSpace α] (μ : MeasureTheory.Measure α)\n  (s : Set α), ?m.963093 μ s = 0 → MeasurableSet s"],
    ["∀ {α : Type u_1} [inst : MeasurableSpace α] [inst_1 : TopologicalSpace α]\n  [inst_2 : TopologicalSpace.SecondCountableTopology α] [inst_3 : BorelSpace α] (μ : MeasureTheory.Measure α)\n  (s : Set α), ?m.473549 μ s = 0 → MeasurableSet s"],
    ["∀ {α : Type u_1} [inst : MeasurableSpace α] [inst_1 : TopologicalSpace α]\n  [inst_2 : TopologicalSpace.SecondCountableTopology α] [inst_3 : BorelSpace α] (s : Set α)\n  (μ : MeasureTheory.Measure α), ?m.473754 s μ = 0 → MeasurableSet s"],
    ["∀ {α : Type u_1} [inst : MeasurableSpace α] {μ : MeasureTheory.Measure α} {s : Set α}, ?m.473906 = 0 → MeasurableSet s"],
    ["∀ {α : Type u_1} [inst : MeasurableSpace α] [inst_1 : TopologicalSpace α] [inst_2 : BorelSpace α] {s : Set α}\n  (μ : MeasureTheory.Measure α), ?m.474058 μ = 0 → MeasurableSet s"],
    ["∀ {α : Type u_1} [inst : MeasurableSpace α] [inst_1 : TopologicalSpace α]\n  [inst_2 : TopologicalSpace.SecondCountableTopology α] [inst_3 : BorelSpace α] {s : Set α},\n  ?m.474224 = 0 → MeasurableSet s"],
    ["∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : MeasurableSpace α] [inst_2 : BorelSpace α]\n  (μ : MeasureTheory.Measure α) (s : Set α), ?m.962923 μ s = 0 → MeasurableSet s"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   ["forall {α : Type u_1} [inst : MeasurableSpace α] [inst_1 : TopologicalSpace α] [inst_2 : TopologicalSpace.SecondCountableTopology α]\n  [inst_3 : BorelSpace α] (μ : MeasureTheory.Measure α) (s : Set α), ↑↑μ s = 0 → MeasurableSet s ",
    "forall {α : Type u_1} [inst : MeasurableSpace α] [inst_1 : TopologicalSpace α] [inst_2 : TopologicalSpace.SecondCountableTopology α]\n  [inst_3 : BorelSpace α] (s : Set α) (μ : MeasureTheory.Measure α), ↑↑μ s = 0 → MeasurableSet s ",
    "∀ {α : Type u_1} [inst : MeasurableSpace α] {μ : MeasureTheory.Measure α} {s : Set α},\n  ↑↑μ s = 0 → MeasurableSet s ",
    "∀ {α : Type u_1} [inst : MeasurableSpace α] [inst_1 : TopologicalSpace α] [inst_2 : BorelSpace α] {s : Set α}\n  (μ : MeasureTheory.Measure α), ↑↑μ s = 0 → MeasurableSet s ",
    "∀ {α : Type u_1} [inst : MeasurableSpace α] [inst_1 : TopologicalSpace α] [inst_2 : TopologicalSpace.SecondCountableTopology α]\n  [inst_3 : BorelSpace α] {s : Set α}, ↑↑(MeasureTheory.volume : MeasureTheory.Measure α) s = 0 → MeasurableSet s ",
    "∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : MeasurableSpace α] [inst_2 : BorelSpace α]\n  (μ : MeasureTheory.Measure α) (s : Set α), ↑↑μ s = 0 → MeasurableSet s ",
    "∀ {α : Type u_1} [inst : MeasurableSpace α] [inst_1 : TopologicalSpace α] [inst_2 : TopologicalSpace.SecondCountableTopology α]\n  [inst_3 : OpensMeasurableSpace α] (μ : MeasureTheory.Measure α) (s : Set α),\n  ↑↑μ s = 0 → MeasurableSet s "]},
  {"theorem": "∀ {p : ℕ}, Nat.Prime p → ¬∃ t, t * t = p",
   "some-correct": null,
   "prompt": "No prime number is a perfect square.",
   "groups":
   [["∀ {p : ℕ}, Nat.Prime p → ¬∃ t, t * t = p",
     "∀ {p : ℕ}, Nat.Prime p → ¬∃ t, t * t = p",
     "∀ {p : ℕ}, Nat.Prime p → ¬∃ t, t * t = p",
     "∀ {n : ℕ}, Nat.Prime n → ¬∃ t, t * t = n",
     "∀ {p : ℕ}, Nat.Prime p → ¬∃ a, a * a = p",
     "∀ {n : ℕ}, Nat.Prime n → ¬∃ t, t * t = n",
     "∀ {p : ℕ}, Nat.Prime p → ¬∃ t, t * t = p"],
    ["∀ (p : ℕ) [inst : Fact (Nat.Prime p)], ¬∃ t, t * t = p",
     "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], ¬∃ t, t * t = p",
     "∀ (p : ℕ) [inst : Fact (Nat.Prime p)], ¬∃ t, t * t = p"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   ["∀ {p : ℕ}, Nat.Prime p → ¬∃ t, t * t = p ",
    "∀ {p : ℕ}, Nat.Prime p → ¬∃ t, t * t = p ",
    "∀ (p : ℕ) [inst : Fact (Nat.Prime p)], ¬∃ t, t * t = p ",
    "∀ {p : ℕ}, Nat.Prime p → ¬∃ t, t * t = p ",
    "∀ {p : ℕ} [Fact (Nat.Prime p)], ¬∃ t, t * t = p ",
    "∀ (p : ℕ) [inst : Fact (Nat.Prime p)], ¬∃ t, t * t = p ",
    "∀ {n : ℕ}, Nat.Prime n → ¬∃ t, t * t = n ",
    "∀ {p : ℕ}, Nat.Prime p → ¬∃ a, a * a = p ",
    "∀ {n : ℕ}, Nat.Prime n → ¬∃ t, t * t = n ",
    "∀ {p : ℕ}, Nat.Prime p → ¬∃ t, t * t = p "]},
  {"theorem": "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], Odd p → p > 2",
   "some-correct": null,
   "prompt": "Every odd prime number is greater than `2`.",
   "groups":
   [["∀ {p : ℕ} [inst : Fact (Nat.Prime p)], Odd p → p > 2",
     "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], Odd p → 2 < p",
     "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], Odd p → p > 2",
     "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], Odd p → 2 < p",
     "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], Odd p → p > 2"],
    ["∀ {p : ℕ}, Nat.Prime p → Odd p → p > 2",
     "∀ {p : ℕ}, Nat.Prime p → Odd p → p > 2",
     "∀ {p : ℕ}, Nat.Prime p → Odd p → p > 2",
     "∀ {p : ℕ}, Nat.Prime p → Odd p → p > 2"],
    ["∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 2 = 1 → p > 2"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   ["∀ {p : ℕ} [inst : Fact (Nat.Prime p)], Odd p → p > 2 ",
    "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], Odd p → 2 < p ",
    "∀ {p : ℕ}, Nat.Prime p → Odd p → p > 2 ",
    "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], Odd p → p > 2 ",
    "∀ {p : ℕ}, Nat.Prime p → Odd p → p > 2 ",
    "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], Odd p → 2 < p ",
    "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 2 = 1 → p > 2 ",
    "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], Odd p → p > 2 ",
    "∀ {p : ℕ}, Nat.Prime p → Odd p → p > 2 ",
    "∀ {p : ℕ}, Nat.Prime p → Odd p → p > 2 "]},
  {"theorem":
   "∀ {a b x y u v : ℕ},\n  a = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 →\n    b = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 → ∃ r s t w, a * b = r ^ 2 + s ^ 2 + t ^ 2 + w ^ 2",
   "some-correct": null,
   "prompt":
   "The product of two numbers, each of which is the sum of four squares, is itself a sum of four squares.",
   "groups":
   [["∀ {a b x y u v : ℕ},\n  a = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 →\n    b = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 → ∃ r s t w, a * b = r ^ 2 + s ^ 2 + t ^ 2 + w ^ 2",
     "∀ {a b x y u v : ℕ},\n  a = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 →\n    b = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 → ∃ r s t w, a * b = r ^ 2 + s ^ 2 + t ^ 2 + w ^ 2",
     "∀ {a b x y u v : ℕ},\n  a = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 →\n    b = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 → ∃ r s t w, a * b = r ^ 2 + s ^ 2 + t ^ 2 + w ^ 2",
     "∀ {a b x y u v : ℕ},\n  a = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 →\n    b = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 → ∃ r s t w, a * b = r ^ 2 + s ^ 2 + t ^ 2 + w ^ 2"],
    ["∀ (a b x y u v r s : ℕ),\n  a = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 →\n    b = r ^ 2 + s ^ 2 + u ^ 2 + v ^ 2 → ∃ m n p q, a * b = m ^ 2 + n ^ 2 + p ^ 2 + q ^ 2",
     "∀ {a b x y u v w z : ℕ},\n  a = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 →\n    b = w ^ 2 + z ^ 2 + u ^ 2 + v ^ 2 → ∃ r s t q, a * b = r ^ 2 + s ^ 2 + t ^ 2 + q ^ 2"],
    ["∀ {x₀ x₁ x₂ x₃ y₀ y₁ y₂ y₃ : ℕ},\n  ∃ a b c d, (x₀ ^ 2 + x₁ ^ 2 + x₂ ^ 2 + x₃ ^ 2) * (y₀ ^ 2 + y₁ ^ 2 + y₂ ^ 2 + y₃ ^ 2) = a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2"],
    ["∀ {a b x y u v w s t : ℕ},\n  a = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 →\n    b = w ^ 2 + s ^ 2 + t ^ 2 → ∃ r1 r2 r3 r4, a * b = r1 ^ 2 + r2 ^ 2 + r3 ^ 2 + r4 ^ 2"],
    ["∀ {a b x y u v : ℕ},\n  a = x ^ 2 + y ^ 2 → b = u ^ 2 + v ^ 2 → ∃ r s, a * b = r ^ 2 + s ^ 2 + (u * x + v * y) ^ 2 + (u * y - v * x) ^ 2"],
    ["∀ (a b c d u v w x : ℕ),\n  (a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2) * (u ^ 2 + v ^ 2 + w ^ 2 + x ^ 2) =\n    (a * u + b * v + c * w + d * x) ^ 2 + (a * v - b * u - c * x + d * w) ^ 2 + (a * w + b * x - c * u - d * v) ^ 2 +\n      (a * x - b * w + c * v - d * u) ^ 2"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   ["∀ {a b x y u v w s t : ℕ}, a = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 → b = w ^ 2 + s ^ 2 + t ^ 2 → ∃ r1 r2 r3 r4, a * b = r1 ^ 2 + r2 ^ 2 + r3 ^ 2 + r4 ^ 2 ",
    "∀ {x₀ x₁ x₂ x₃ y₀ y₁ y₂ y₃ : ℕ},\n  ∃ a b c d,\n    (x₀ ^ 2 + x₁ ^ 2 + x₂ ^ 2 + x₃ ^ 2) * (y₀ ^ 2 + y₁ ^ 2 + y₂ ^ 2 + y₃ ^ 2) = a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 ",
    "∀ {a b x y u v : ℕ}, a = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 → b = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 → ∃ r s t w, a * b = r ^ 2 + s ^ 2 + t ^ 2 + w ^ 2 ",
    "∀ {a b x y u v : ℕ},\n  a = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 →\n  b = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 →\n  ∃ r s t w, a * b = r ^ 2 + s ^ 2 + t ^ 2 + w ^ 2 ",
    "∀ {a b x y u v : ℕ}, a = x ^ 2 + y ^ 2 → b = u ^ 2 + v ^ 2 → ∃ r s, a * b = r ^ 2 + s ^ 2 + (u * x + v * y) ^ 2 + (u * y - v * x) ^ 2 ",
    "∀ (a b c d u v w x : ℕ),\n  (a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2) * (u ^ 2 + v ^ 2 + w ^ 2 + x ^ 2) =\n    (a * u + b * v + c * w + d * x) ^ 2 + (a * v - b * u - c * x + d * w) ^ 2 +\n      (a * w + b * x - c * u - d * v) ^ 2 + (a * x - b * w + c * v - d * u) ^ 2 ",
    "∀ (a b x y u v r s : ℕ),\n  a = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 → b = r ^ 2 + s ^ 2 + u ^ 2 + v ^ 2 → ∃ m n p q, a * b = m ^ 2 + n ^ 2 + p ^ 2 + q ^ 2 ",
    "∀ {a b x y u v : ℕ}, a = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 → b = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 → ∃ r s t w, a * b = r ^ 2 + s ^ 2 + t ^ 2 + w ^ 2 ",
    "∀ {a b x y u v : ℕ}, a = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 → b = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 → ∃ r s t w, a * b = r ^ 2 + s ^ 2 + t ^ 2 + w ^ 2 ",
    "∀ {a b x y u v w z : ℕ},\n  a = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 →\n  b = w ^ 2 + z ^ 2 + u ^ 2 + v ^ 2 →\n  ∃ r s t q, a * b = r ^ 2 + s ^ 2 + t ^ 2 + q ^ 2 "]},
  {"theorem":
   "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α], LocallyCompactSpace α",
   "some-correct": null,
   "prompt": "Every compact topological space is locally compact.",
   "groups":
   [["∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α], LocallyCompactSpace α",
     "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α], LocallyCompactSpace α",
     "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α], LocallyCompactSpace α",
     "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α], LocallyCompactSpace α",
     "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α], LocallyCompactSpace α",
     "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α], LocallyCompactSpace α",
     "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α], LocallyCompactSpace α",
     "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α], LocallyCompactSpace α",
     "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α], LocallyCompactSpace α",
     "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α], LocallyCompactSpace α"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α], LocallyCompactSpace α ",
    "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α], LocallyCompactSpace α ",
    "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α], LocallyCompactSpace α ",
    "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α], LocallyCompactSpace α ",
    "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α], LocallyCompactSpace α ",
    "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α], LocallyCompactSpace α ",
    "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α], LocallyCompactSpace α ",
    "forall {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α], LocallyCompactSpace α ",
    "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α], LocallyCompactSpace α ",
    "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α], LocallyCompactSpace α "]},
  {"theorem":
   "∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : CompactSpace α] (f : α → β),\n  Continuous f → UniformContinuous f",
   "some-correct": null,
   "prompt": "Every continuous function is uniformly continuous.",
   "groups":
   [["∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : CompactSpace α] (f : α → β),\n  Continuous f → UniformContinuous f",
     "∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : CompactSpace α] {f : α → β},\n  Continuous f → UniformContinuous f",
     "∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : CompactSpace α] (f : α → β),\n  Continuous f → UniformContinuous f",
     "∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : CompactSpace α] {f : α → β},\n  Continuous f → UniformContinuous f",
     "∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : CompactSpace α] [inst_2 : UniformSpace β] (f : α → β),\n  Continuous f → UniformContinuous f",
     "∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : CompactSpace α] (f : α → β),\n  Continuous f → UniformContinuous f"],
    ["∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] (self : α ≃ᵤ β),\n  UniformContinuous self.toFun"],
    ["∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] {f : α → β},\n  Continuous f → UniformContinuous f"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] {f : α → β},\n  Continuous f → UniformContinuous f ",
    "∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : CompactSpace α]\n  (f : α → β), Continuous f → UniformContinuous f ",
    "∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : CompactSpace α]\n  {f : α → β}, Continuous f → UniformContinuous f ",
    "∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : CompactSpace α] (f : α → β),\n  Continuous f → UniformContinuous f ",
    "∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : CompactSpace α] {f : α → β},\n  Continuous f → UniformContinuous f ",
    "∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] (self : α ≃ᵤ β),\n  UniformContinuous self.toFun ",
    "forall {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : CompactSpace α] [inst_2 : UniformSpace β] (f : α → β),\n  Continuous f → UniformContinuous f ",
    "forall {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : CompactSpace α],\n  ∀ (f : α → β), Continuous f → UniformContinuous f "]},
  {"theorem": "∀ {p q : ℕ}, Nat.Prime p → Nat.Prime q → p ≠ q → p + q ≠ 6",
   "some-correct": null,
   "prompt": "`6` is not the sum of two distinct prime numbers.",
   "groups":
   [["∀ {p q : ℕ}, Nat.Prime p → Nat.Prime q → p ≠ q → p + q ≠ 6",
     "∀ {a b : ℕ}, Nat.Prime a → Nat.Prime b → a ≠ b → a + b ≠ 6"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   ["¬∃ (a b : ℕ), Nat.Prime a ∧ Nat.Prime b ∧ a ≠ b ∧ a + b = 6 ",
    "¬∃ (x y : ℕ), Nat.Prime x ∧ Nat.Prime y ∧ x ≠ y ∧ x + y = 6 ",
    "¬∃ (p₁ p₂ : ℕ), Nat.Prime p₁ ∧ Nat.Prime p₂ ∧ p₁ ≠ p₂ ∧ p₁ + p₂ = 6 ",
    "¬∃ (p q : ℕ), Nat.Prime p ∧ Nat.Prime q ∧ p ≠ q ∧ p + q = 6 ",
    "¬∃ p q : ℕ, Nat.Prime p ∧ Nat.Prime q ∧ p ≠ q ∧ p + q = 6 ",
    "¬∃ (p q : ℕ), Nat.Prime p ∧ Nat.Prime q ∧ p ≠ q ∧ 6 = p + q ",
    "¬∃ (a b : ℕ), a ≠ b ∧ Nat.Prime a ∧ Nat.Prime b ∧ a + b = 6 ",
    "∀ {p q : ℕ}, Nat.Prime p → Nat.Prime q → p ≠ q → p + q ≠ 6 ",
    "¬∃ x y : ℕ, Nat.Prime x ∧ Nat.Prime y ∧ x ≠ y ∧ x + y = 6 ",
    "∀ {a b : ℕ}, Nat.Prime a → Nat.Prime b → a ≠ b → a + b ≠ 6 "]},
  {"theorem": "∀ (n : ℤ), ¬Irrational ↑n",
   "some-correct": null,
   "prompt": "No integer is irrational.",
   "groups":
   [["∀ (n : ℤ), ¬Irrational ↑n",
     "∀ (z : ℤ), ¬Irrational ↑z",
     "∀ (z : ℤ), ¬Irrational ↑z",
     "∀ (z : ℤ), ¬Irrational ↑z",
     "∀ (n : ℤ), ¬Irrational ↑n",
     "∀ (n : ℤ), ¬Irrational ↑n",
     "∀ (z : ℤ), ¬Irrational ↑z",
     "∀ (z : ℤ), ¬Irrational ↑z",
     "∀ (z : ℤ), ¬Irrational ↑z",
     "∀ (z : ℤ), ¬Irrational ↑z"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   ["∀ (n : ℤ), ¬Irrational ↑n ",
    "∀ (z : ℤ), ¬Irrational ↑z ",
    "∀ (z : ℤ), ¬Irrational (↑z) ",
    "∀ (z : ℤ), ¬Irrational (↑z) ",
    "∀ (n : ℤ), ¬Irrational ↑n ",
    "∀ (n : ℤ), ¬Irrational ↑n ",
    "∀ (z : ℤ), ¬Irrational (↑z) ",
    "∀ (z : ℤ), ¬Irrational (↑z) ",
    "∀ (z : ℤ), ¬Irrational ↑z ",
    "∀ (z : ℤ), ¬Irrational ↑z "]},
  {"theorem": "∀ {R : Type u} [inst : Ring R], IsUnit 1",
   "some-correct": null,
   "prompt": "The identity element in a ring is a unit.",
   "groups":
   [["∀ {R : Type u} [inst : Ring R], IsUnit 1",
     "∀ {R : Type u} [inst : Ring R], IsUnit 1",
     "∀ {R : Type u} [inst : Ring R], IsUnit 1",
     "∀ {R : Type u} [inst : Ring R], IsUnit 1",
     "∀ {R : Type u} [inst : MonoidWithZero R], IsUnit 1",
     "∀ {R : Type u} [inst : Ring R], IsUnit 1",
     "∀ {R : Type u} [inst : Ring R], IsUnit 1",
     "∀ {R : Type u} [inst : Ring R], IsUnit 1",
     "∀ {α : Type u} [inst : MonoidWithZero α], IsUnit 1",
     "∀ {R : Type u} [inst : Ring R], IsUnit 1"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   ["∀ {R : Type u} [inst : Ring R], IsUnit (1 : R) ",
    "∀ {R : Type u} [inst : Ring R], IsUnit (1 : R) ",
    "∀ {R : Type u} [inst : Ring R], IsUnit (1 : R) ",
    "∀ {R : Type u} [inst : Ring R], IsUnit (1 : R) ",
    "∀ {R : Type u} [inst : MonoidWithZero R], IsUnit (1 : R) ",
    "∀ {R : Type u} [inst : Ring R], IsUnit (1 : R) ",
    "∀ {R : Type u} [inst : Ring R], IsUnit (1 : R) ",
    "∀ {R : Type u} [inst : Ring R], IsUnit (1 : R) ",
    "∀ {α : Type u} [inst : MonoidWithZero α], IsUnit (1 : α) ",
    "∀ {R : Type u} [inst : Ring R], IsUnit (1 : R) "]},
  {"theorem":
   "{G : Type u_1} → [inst : Group G] → (H : Subgroup G) → Group { x // x ∈ H }",
   "some-correct": null,
   "prompt": "Every subgroup of a group is a group.",
   "groups":
   [["{G : Type u_1} → [inst : Group G] → (H : Subgroup G) → Group { x // x ∈ H }",
     "{G : Type u_1} → [inst : Group G] → (H : Subgroup G) → Group { x // x ∈ H }",
     "{G : Type u_1} → [inst : Group G] → (H : Subgroup G) → Group { x // x ∈ H }",
     "{G : Type u_1} → [inst : Group G] → (H : Subgroup G) → Group { x // x ∈ H }",
     "{G : Type u_1} → [inst : Group G] → (H : Subgroup G) → Group { x // x ∈ H }",
     "{G : Type u_1} → [inst : Group G] → (H : Subgroup G) → Group { x // x ∈ H }",
     "{G : Type u_1} → [inst : Group G] → (H : Subgroup G) → Group { x // x ∈ H }",
     "{G : Type u_1} → [inst : Group G] → (H : Subgroup G) → Group { x // x ∈ H }"],
    ["{G : Type u_1} → [inst : Group G] → (H : Subgroup G) → Group { x // x ∈ H }"],
    ["{G : Type u_1} → [inst : Group G] → (H : Subgroup G) → Group { x // x ∈ H }"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   ["forall {G : Type u_1} [inst : Group G] (H : Subgroup G), Group { x // x ∈ H } ",
    "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Group { x // x ∈ H } ",
    "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Group { x // x ∈ H } ",
    "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Group { x // x ∈ H } ",
    "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Group {x // x ∈ H} ",
    "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Group { x // x ∈ H } ",
    "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Group { x // x ∈ H } ",
    "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Group { x // x ∈ H } ",
    "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Group { x // x ∈ H } ",
    "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Group { x // x ∈ H } "]},
  {"theorem": "∀ (a b : ℕ), ∃ c, a + b = c",
   "some-correct": null,
   "prompt": "The sum of two natural numbers is a natural number.",
   "groups":
   [["∀ (a b : ℕ), ∃ c, a + b = c",
     "∀ (a b : ℕ), ∃ c, a + b = c",
     "∀ (a b : ℕ), ∃ c, a + b = c",
     "∀ (a b : ℕ), ∃ c, c = a + b",
     "∀ (a b : ℕ), ∃ c, a + b = c",
     "∀ (a b : ℕ), ∃ c, a + b = c",
     "∀ (a b : ℕ), ∃ c, a + b = c",
     "∀ (m n : ℕ), ∃ k, m + n = k",
     "∀ (a b : ℕ), ∃ c, a + b = c"],
    ["ℕ → ℕ → ℕ"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   ["∀ (a b : ℕ), ∃ c, a + b = c ",
    "∀ (a b : ℕ), ∃ (c : ℕ), a + b = c ",
    "∀ (a b : ℕ), ℕ ",
    "∀ (a b : ℕ), ∃ c : ℕ, a + b = c ",
    "∀ (a b : ℕ), ∃ c, c = a + b ",
    "∀ (a b : ℕ), ∃ c : ℕ, a + b = c ",
    "∀ (a b : ℕ), ∃ c : ℕ, a + b = c ",
    "∀ (a b : ℕ), ∃ c, a + b = c ",
    "∀ (m n : ℕ), ∃ k : ℕ, m + n = k ",
    "∀ (a b : ℕ), ∃ c : ℕ, a + b = c "]},
  {"theorem": "∀ {G : Type u_1} [inst : Group G], IsOfFinOrder 1",
   "some-correct": null,
   "prompt": "The identity element of a group has finite order.",
   "groups":
   [["∀ {G : Type u_1} [inst : Group G], IsOfFinOrder 1",
     "∀ {G : Type u_1} [inst : Group G], IsOfFinOrder 1",
     "∀ {G : Type u_1} [inst : Group G], IsOfFinOrder 1"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   ["∀ {G : Type u_1} [inst : Group G], IsOfFinOrder (1 : G) ",
    "∀ {G : Type u_1} [inst : Group G], IsOfFinOrder 1 ",
    "∀ {G : Type u_1} [inst : Group G], IsOfFinOrder 1 ",
    "∀ {G : Type u_1} [inst : Group G], IsOfFinOrder 1 ",
    "∀ {G : Type u_1} [inst : Group G], IsOfFinOrder 1 ",
    "∀ {G : Type u_1} [inst : Group G], IsOfFinOrder 1 ",
    "∀ {G : Type u_1} [inst : Group G], IsOfFinOrder 1 ",
    "∀ {G : Type u_1} [inst : Group G], IsOfFinOrder (1 : G) ",
    "∀ {G : Type u_1} [inst : Group G], IsOfFinOrder 1 ",
    "∀ {G : Type u_1} [inst : Group G], IsOfFinOrder (1 : G) "]},
  {"theorem": "Fact (Nat.Prime 7)",
   "some-correct": null,
   "prompt": "`7` is a prime number.",
   "groups":
   [["Fact (Nat.Prime 7)",
     "Fact (Nat.Prime 7)",
     "Fact (Nat.Prime 7)",
     "Fact (Nat.Prime 7)",
     "Fact (Nat.Prime 7)",
     "Fact (Nat.Prime 7)",
     "Fact (Nat.Prime 7)",
     "Fact (Nat.Prime 7)",
     "Fact (Nat.Prime 7)",
     "Fact (Nat.Prime 7)"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   ["Fact (Nat.Prime 7) ",
    "Fact (Nat.Prime 7) ",
    "Fact (Nat.Prime 7) ",
    "Fact (Nat.Prime 7) ",
    "Fact (Nat.Prime 7) ",
    "Fact (Nat.Prime 7) ",
    "Fact (Nat.Prime 7) ",
    "Fact (Nat.Prime 7) ",
    "Fact (Nat.Prime 7) ",
    "Fact (Nat.Prime 7) "]},
  {"theorem": "Finset.card (Finset.filter Nat.Prime (Finset.range 8)) = 3",
   "some-correct": null,
   "prompt": "There are `3` prime numbers below `8`.",
   "groups":
   [["Finset.card (Finset.filter Nat.Prime (Finset.range 8)) = 3"],
    ["Fact (Finset.card (Finset.filter Nat.Prime (Finset.range 8)) = 3)"],
    ["Nat.card { x // x ∈ Finset.filter Nat.Prime (Finset.range 8) } = 3"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   ["Fact (Finset.card (Finset.filter Nat.Prime (Finset.range 8)) = 3) ",
    "Nat.card (Finset.filter Nat.Prime (Finset.range 8)) = 3 ",
    "Finset.card (Finset.filter Nat.Prime (Finset.range 8)) = 3 "]},
  {"theorem": "∀ {α : Type u} {s : Set α}, Set.Finite s → ∅ ⊆ s",
   "some-correct": null,
   "prompt": "The empty set is contained in every finite set.",
   "groups":
   [["∀ {α : Type u} {s : Set α}, Set.Finite s → ∅ ⊆ s",
     "∀ {α : Type u} {s : Set α}, Set.Finite s → ∅ ⊆ s",
     "∀ {α : Type u} {s : Set α}, Set.Finite s → ∅ ⊆ s",
     "∀ {α : Type u} {a : Set α}, Set.Finite a → ∅ ⊆ a",
     "∀ {α : Type u} {s : Set α}, Set.Finite s → ∅ ⊆ s",
     "∀ {α : Type u} {s : Set α}, Set.Finite s → ∅ ⊆ s",
     "∀ {α : Type u} {A : Finset α}, ∅ ⊆ A",
     "∀ {α : Type u} {s : Set α}, Set.Finite s → ∅ ⊆ s",
     "∀ {α : Type u} {s : Set α}, Set.Finite s → ∅ ⊆ s",
     "∀ {α : Type u} {s : Set α}, Set.Finite s → ∅ ⊆ s"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u} {s : Set α}, Set.Finite s → ∅ ⊆ s ",
    "∀ {α : Type u} {s : Set α}, Set.Finite s → ∅ ⊆ s ",
    "∀ {α : Type u} {s : Set α}, Set.Finite s → ∅ ⊆ s ",
    "∀ {α : Type u} {a : Set α}, Set.Finite a → ∅ ⊆ a ",
    "∀ {α : Type u} {s : Set α}, Set.Finite s → ∅ ⊆ s ",
    "∀ {α : Type u} {s : Set α}, Set.Finite s → ∅ ⊆ s ",
    "∀ {α : Type u} {A : Finset α}, ∅ ⊆ ↑A ",
    "∀ {α : Type u} {s : Set α}, Set.Finite s → ∅ ⊆ s ",
    "∀ {α : Type u} {s : Set α}, Set.Finite s → ∅ ⊆ s ",
    "∀ {α : Type u} {s : Set α}, Set.Finite s → ∅ ⊆ s "]},
  {"theorem":
   "∀ {α : Type u} {s : Set α}, ¬Set.Finite s → ∃ t, Set.Finite t ∧ t ⊆ s",
   "some-correct": null,
   "prompt": "Every infinite set contains a finite set.",
   "groups":
   [["∀ {α : Type u} {s : Set α}, ¬Set.Finite s → ∃ t, Set.Finite t ∧ t ⊆ s",
     "∀ {α : Type u} {s : Set α}, ¬Set.Finite s → ∃ t, Set.Finite t ∧ t ⊆ s"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u} {s : Set α}, ¬Set.Finite s → ∃ t : Finset α, ↑t ⊆ s ",
    "∀ {α : Type u} {s : Set α}, ¬Set.Finite s → ∃ t : Set α, Set.Finite t ∧ t ⊆ s ",
    "∀ {α : Type u} {s : Set α}, ¬Set.Finite s → ∃ t : Set α, Set.Finite t ∧ t ⊆ s ",
    "∀ {α : Type u} {s : Set α}, ¬Set.Finite s → ∃ (t : Finset α), ↑t ⊆ s "]},
  {"theorem": "{R : Type u} → [inst : CommRing R] → Monoid R",
   "some-correct": null,
   "prompt": "Every commutative ring is a monoid.",
   "groups":
   [["{R : Type u} → [inst : CommRing R] → Monoid R",
     "{R : Type u} → [inst : CommRing R] → Monoid R",
     "{R : Type u} → [inst : CommRing R] → Monoid R",
     "{R : Type u} → [inst : CommRing R] → Monoid R",
     "{R : Type u} → [inst : CommRing R] → Monoid R"],
    ["{α : Type u} → [inst : CommRing α] → Monoid α"],
    ["{R : Type u_1} → [inst : CommRing R] → Monoid R"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   ["∀ {R : Type u} [inst : CommRing R], Monoid R ",
    "∀ {R : Type u_1} [inst : CommRing R], Monoid R ",
    "∀ {R : Type u} [inst : CommRing R], Monoid R ",
    "∀ {R : Type u} [inst : CommRing R], Monoid R ",
    "∀ {R : Type u} [inst : CommRing R], Monoid R ",
    "∀ {R : Type u} [inst : CommRing R], Monoid R ",
    "∀ {α : Type u} [inst : CommRing α], Monoid α "]},
  {"theorem": "∀ {n : ℕ}, Odd n → ∃ x y, x ≠ y ∧ n = x + y",
   "some-correct": null,
   "prompt":
   "Every odd natural number is the sum of two distinct natural numbers.",
   "groups":
   [["∀ {n : ℕ}, Odd n → ∃ x y, x ≠ y ∧ n = x + y",
     "∀ (n : ℕ), Odd n → ∃ x y, x ≠ y ∧ n = x + y",
     "∀ (n : ℕ), Odd n → ∃ a b, a ≠ b ∧ n = a + b",
     "∀ (n : ℕ), Odd n → ∃ a b, a ≠ b ∧ n = a + b",
     "∀ (n : ℕ), Odd n → ∃ a b, a ≠ b ∧ n = a + b",
     "∀ {n : ℕ}, Odd n → ∃ a b, a ≠ b ∧ n = a + b",
     "∀ (n : ℕ), Odd n → ∃ a b, a ≠ b ∧ n = a + b",
     "∀ (n : ℕ), Odd n → ∃ a b, a ≠ b ∧ n = a + b",
     "∀ (n : ℕ), Odd n → ∃ a b, a ≠ b ∧ n = a + b"],
    ["∀ (n : ℕ), Odd n → ∃ a b, n = a + b ∧ a ≠ b"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   ["∀ {n : ℕ}, Odd n → ∃ x y : ℕ, x ≠ y ∧ n = x + y ",
    "∀ (n : ℕ), Odd n → ∃ x y, x ≠ y ∧ n = x + y ",
    "∀ (n : ℕ), Odd n → ∃ a b : ℕ, a ≠ b ∧ n = a + b ",
    "∀ (n : ℕ), Odd n → ∃ a b : ℕ, a ≠ b ∧ n = a + b ",
    "∀ (n : ℕ), Odd n → ∃ a b : ℕ, a ≠ b ∧ n = a + b ",
    "∀ {n : ℕ}, Odd n → ∃ a b : ℕ, a ≠ b ∧ n = a + b ",
    "∀ (n : ℕ), Odd n → ∃ a b : ℕ, a ≠ b ∧ n = a + b ",
    "∀ (n : ℕ), Odd n → ∃ a b : ℕ, n = a + b ∧ a ≠ b ",
    "∀ (n : ℕ), Odd n → ∃ a b : ℕ, a ≠ b ∧ n = a + b ",
    "∀ (n : ℕ), Odd n → ∃ a b : ℕ, a ≠ b ∧ n = a + b "]},
  {"theorem": "∀ {G : Type u_1} [inst : Group G], IsOfFinOrder 1",
   "some-correct": true,
   "prompt": "Every element in the trivial group has finite order.",
   "groups":
   [["∀ {G : Type u_1} [inst : Group G], IsOfFinOrder 1",
     "∀ {G : Type u_1} [inst : Group G], IsOfFinOrder 1"],
    ["∀ {G : Type u_1} [inst : Monoid G] (x : Unit), IsOfFinOrder x",
     "∀ {G : Type u_1} [inst : Monoid G] (x : Unit), IsOfFinOrder x"],
    ["∀ {G : Type u_1} [inst : Group G] [inst_1 : Subsingleton G] (x : G), IsOfFinOrder x"],
    ["∀ {G : Type u_1} [inst : Group G] [inst_1 : Unique G] (x : G), IsOfFinOrder x"],
    ["∀ {G : Type u_1} [inst : Monoid G] [inst_1 : Subsingleton G] (x : G), IsOfFinOrder x"]],
   "correct": false,
   "comments": "",
   "all-elabs":
   ["∀ {G : Type u_1} [inst : Monoid G] (x : Unit), IsOfFinOrder x ",
    "∀ {G : Type u_1} [inst : Group G] [inst_1 : Subsingleton G] (x : G), IsOfFinOrder x ",
    "∀ {G : Type u_1} [inst : Group G], IsOfFinOrder (1 : G) ",
    "∀ {G : Type u_1} [inst : Monoid G] (x : Unit), IsOfFinOrder x ",
    "∀ {G : Type u_1} [inst : Monoid G] [Subsingleton G] (x : G), IsOfFinOrder x ",
    "∀ {G : Type u_1} [inst : Group G] [inst_1 : Unique G], ∀ x : G, IsOfFinOrder x ",
    "∀ {G : Type u_1} [inst : Group G], IsOfFinOrder (1 : G) "]},
  {"theorem":
   "∀ {α : Type u} [inst : LinearOrderedRing α] {x : α}, Even x → Even (x * x)",
   "some-correct": null,
   "prompt": "The square of an even number is even.",
   "groups":
   [["∀ {α : Type u} [inst : LinearOrderedRing α] {x : α}, Even x → Even (x * x)",
     "∀ {α : Type u} [inst : LinearOrderedRing α] {x : α}, Even x → Even (x * x)"],
    ["∀ {n : ℕ}, n % 2 = 0 → n * n % 2 = 0",
     "∀ (n : ℕ), n % 2 = 0 → n * n % 2 = 0"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   ["∀ {n : ℕ}, Even n → Even (n ^ 2) ",
    "∀ {n : ℕ}, n % 2 = 0 → (n * n) % 2 = 0 ",
    "∀ (n : ℕ), n % 2 = 0 → (n * n) % 2 = 0 ",
    "∀ {n : ℕ}, even n → even (n ^ 2) ",
    "∀ {α : Type u} [inst : LinearOrderedRing α] {x : α}, Even x → Even (x * x) ",
    "∀ {n : ℕ}, Even n → Even (n ^ 2) ",
    "∀ {n : ℕ}, even n → even (n ^ 2) ",
    "∀ {n : ℕ}, Even n → Even (n ^ 2) ",
    "∀ {α : Type u} [inst : LinearOrderedRing α] {x : α}, Even x → Even (x * x) ",
    "∀ {n : ℕ}, Even n → Even (n ^ 2) "]},
  {"theorem":
   "∀ {K : Type u} [inst : CommRing K] [inst_1 : DivisionSemiring K], IsField K",
   "some-correct": null,
   "prompt": "Every commutative division ring is a field.",
   "groups":
   [["∀ {K : Type u} [inst : CommRing K] [inst_1 : DivisionSemiring K], IsField K",
     "∀ (K : Type u) [inst : CommRing K] [inst_1 : DivisionSemiring K], IsField K",
     "∀ (K : Type u) [inst : CommRing K] [inst_1 : DivisionSemiring K], IsField K"],
    ["∀ (K : Type u) [inst : CommRing K] [inst_1 : DivisionRing K], IsField K",
     "∀ {K : Type u} [inst : CommRing K] [inst_1 : DivisionRing K], IsField K"],
    ["∀ (K : Type u) [inst : CommRing K] [inst_1 : IsDomain K], IsField K"],
    ["∀ {K : Type u} [inst : DivisionSemiring K] [inst_1 : CommSemiring K], IsField K"],
    ["∀ {R : Type u} [inst : CommSemiring R] [inst_1 : DivisionRing R], IsField R"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   ["∀ {K : Type u} [inst : DivisionSemiring K] [inst_1 : CommSemiring K], IsField K ",
    "∀ {K : Type u} [inst : CommRing K] [inst_1 : DivisionSemiring K], IsField K ",
    "∀ (K : Type u) [inst : CommRing K] [inst_1 : DivisionSemiring K], IsField K ",
    "∀ (K : Type u) [inst : CommRing K] [inst_1 : DivisionRing K], IsField K ",
    "∀ {R : Type u} [inst : CommSemiring R] [inst_1 : DivisionRing R], IsField R ",
    "∀ (K : Type u) [inst : CommRing K] [inst_1 : IsDomain K], IsField K ",
    "∀ (K : Type u) [inst : CommRing K] [inst_1 : DivisionSemiring K], IsField K ",
    "∀ {K : Type u} [inst : CommRing K] [inst_1 : DivisionRing K], IsField K "]},
  {"theorem": "∀ {α : Type u} [inst : MulOneClass α], id 1 = 1",
   "some-correct": null,
   "prompt":
   "The image of the identity element under the identity map is the identity element.",
   "groups":
   [["∀ {α : Type u} [inst : MulOneClass α], id 1 = 1",
     "∀ {α : Type u} [inst : Monoid α], id 1 = 1",
     "∀ {α : Type u} [inst : Monoid α], id 1 = 1",
     "∀ {α : Type u} [inst : Monoid α], id 1 = 1",
     "∀ {α : Type u} [inst : Monoid α], id 1 = 1",
     "∀ {α : Type u} [inst : Monoid α], id 1 = 1",
     "∀ {α : Type u} [inst : MulOneClass α], id 1 = 1"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u} [inst : MulOneClass α], id 1 = 1 ",
    "∀ {α : Type u} [inst : MulOneClass α], id (1 : α) = 1 ",
    "∀ {α : Type u} [inst : Monoid α], id (1 : α) = 1 ",
    "forall {α : Type u} [inst : Monoid α], id (1 : α) = 1 ",
    "∀ {α : Type u} [inst : MulOneClass α], id 1 = 1 ",
    "∀ {α : Type u} [inst : Monoid α], id (1 : α) = 1 ",
    "∀ {α : Type u} [inst : Monoid α], id (1 : α) = 1 ",
    "∀ {α : Type u} [inst : Monoid α], id (1 : α) = 1 ",
    "∀ {α : Type u} [inst : MulOneClass α], id (1 : α) = 1 "]},
  {"theorem": "∀ {α : Type u} (x : α), Function.IsFixedPt id x",
   "some-correct": null,
   "prompt":
   "Every point is a fixed point of the identity function on a space.",
   "groups":
   [["∀ {α : Type u} (x : α), Function.IsFixedPt id x",
     "∀ {α : Type u} (x : α), Function.IsFixedPt id x",
     "∀ {α : Type u} (x : α), Function.IsFixedPt id x",
     "∀ {α : Type u} (x : α), Function.IsFixedPt id x",
     "∀ {α : Type u} (x : α), Function.IsFixedPt id x",
     "∀ {α : Type u} (x : α), Function.IsFixedPt id x",
     "∀ {α : Type u} (x : α), Function.IsFixedPt id x",
     "∀ {α : Type u} (x : α), Function.IsFixedPt id x",
     "∀ {α : Type u} (x : α), Function.IsFixedPt id x",
     "∀ {α : Type u} (x : α), Function.IsFixedPt id x"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u} (x : α), Function.IsFixedPt (@id α) x ",
    "∀ {α : Type u} (x : α), Function.IsFixedPt id x ",
    "∀ {α : Type u} (x : α), Function.IsFixedPt id x ",
    "∀ {α : Type u} (x : α), Function.IsFixedPt id x ",
    "∀ {α : Type u} (x : α), Function.IsFixedPt id x ",
    "∀ {α : Type u} (x : α), Function.IsFixedPt id x ",
    "∀ {α : Type u} (x : α), Function.IsFixedPt (@id α) x ",
    "∀ {α : Type u} (x : α), Function.IsFixedPt id x ",
    "∀ {α : Type u} (x : α), Function.IsFixedPt id x ",
    " ∀ {α : Type u} (x : α), Function.IsFixedPt (id : α → α) x "]},
  {"theorem":
   "∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam {x} = 0",
   "some-correct": null,
   "prompt": "The diameter of a singleton space is `0`.",
   "groups":
   [["∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam {x} = 0",
     "∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam {x} = 0",
     "∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam {x} = 0",
     "∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam {x} = 0",
     "∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam {x} = 0",
     "∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam {x} = 0",
     "∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam {x} = 0",
     "∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam {x} = 0",
     "∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam {x} = 0",
     "∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam {x} = 0"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam {x} = 0 ",
    "∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam {x} = 0 ",
    "∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam {x} = 0 ",
    "∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam {x} = 0 ",
    "∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam {x} = 0 ",
    "∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam {x} = 0 ",
    "∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam {x} = 0 ",
    "∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam {x} = 0 ",
    "∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam {x} = 0 ",
    "∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam {x} = 0 "]},
  {"theorem": "∀ {G : Type u_1} [inst : Group G], Nonempty G",
   "some-correct": null,
   "prompt": "Every group is non-empty.",
   "groups":
   [["∀ {G : Type u_1} [inst : Group G], Nonempty G",
     "∀ {α : Type u_1} [inst : Group α], Nonempty α",
     "∀ {G : Type u_1} [inst : Group G], Nonempty G",
     "∀ {α : Type u_1} [inst : Group α], Nonempty α",
     "∀ {G : Type u_1} [inst : Group G], Nonempty G"],
    ["∀ (G : Type u) [inst : Group G], Nonempty G",
     "∀ (G : Type u) [inst : Group G], Nonempty G",
     "∀ {G : Type u} [inst : Group G], Nonempty G",
     "∀ (G : Type u) [inst : Group G], Nonempty G",
     "∀ (G : Type u) [inst : Group G], Nonempty G"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   ["∀ (G : Type u) [inst : Group G], Nonempty G ",
    "∀ {G : Type u_1} [inst : Group G], Nonempty G ",
    "∀ (G : Type u) [inst : Group G], Nonempty G ",
    "∀ {α : Type u_1} [inst : Group α], Nonempty α ",
    "∀ {G : Type u} [inst : Group G], Nonempty G ",
    "∀ {G : Type u_1} [inst : Group G], Nonempty G ",
    "∀ (G : Type u) [inst : Group G], Nonempty G ",
    "∀ {α : Type u_1} [inst : Group α], Nonempty α ",
    "∀ {G : Type u_1} [inst : Group G], Nonempty G ",
    "∀ (G : Type u) [inst : Group G], Nonempty G "]},
  {"theorem":
   "∀ {α : Type u} [inst : TopologicalSpace α] (x : α), IsConnected (connectedComponent x)",
   "some-correct": null,
   "prompt": "All connected components of a topological space are connected.",
   "groups":
   [["∀ {α : Type u} [inst : TopologicalSpace α] (x : α), IsConnected (connectedComponent x)",
     "∀ {α : Type u} [inst : TopologicalSpace α] (x : α), IsConnected (connectedComponent x)",
     "∀ {α : Type u} [inst : TopologicalSpace α] (x : α), IsConnected (connectedComponent x)",
     "∀ {α : Type u} [inst : TopologicalSpace α] (x : α), IsConnected (connectedComponent x)",
     "∀ {α : Type u} [inst : TopologicalSpace α] (x : α), IsConnected (connectedComponent x)",
     "∀ {α : Type u} [inst : TopologicalSpace α] (x : α), IsConnected (connectedComponent x)"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u} [inst : TopologicalSpace α] (x : α), IsConnected (connectedComponent x) ",
    "∀ {α : Type u} [inst : TopologicalSpace α] (x : α),\n  IsConnected (connectedComponent x) ",
    "∀ {α : Type u} [inst : TopologicalSpace α] (x : α), IsConnected (connectedComponent x) ",
    "∀ {α : Type u} [inst : TopologicalSpace α] (x : α), IsConnected (connectedComponent x) ",
    "∀ {α : Type u} [inst : TopologicalSpace α] (x : α), IsConnected (connectedComponent x) ",
    "∀ {α : Type u} [inst : TopologicalSpace α] (x : α), IsConnected (connectedComponent x) "]},
  {"theorem":
   "∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R], ∃ M, Ideal.IsMaximal M",
   "some-correct": false,
   "prompt": "The ring of integers has a maximal ideal.",
   "groups":
   [["∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R], ∃ M, Ideal.IsMaximal M",
     "∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R], ∃ M, Ideal.IsMaximal M"],
    ["∀ {K : Type u} [inst : Field K] [inst_1 : CharZero K] [inst_2 : NumberField K], ∃ M, Ideal.IsMaximal M"],
    ["∀ {K : Type u_1} [inst : Field K], { x // x ∈ NumberField.ringOfIntegers K } → ∃ I, Ideal.IsMaximal I"]],
   "correct": false,
   "comments": "",
   "all-elabs":
   ["∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R], ∃ M, Ideal.IsMaximal M ",
    "∀ {K : Type u_1} [inst : Field K], NumberField.ringOfIntegers K → ∃ I, Ideal.IsMaximal I ",
    "∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R], ∃ M, Ideal.IsMaximal M ",
    "∀ {K : Type u} [inst : Field K] [inst_1 : CharZero K] [inst_2 : NumberField K], ∃ M, Ideal.IsMaximal M "]},
  {"theorem": "PythagoreanTriple 3 4 5",
   "some-correct": null,
   "prompt": "The numbers `3`, `4` and `5` form a Pythagorean triple.",
   "groups":
   [["PythagoreanTriple 3 4 5",
     "PythagoreanTriple 3 4 5",
     "PythagoreanTriple 3 4 5",
     "PythagoreanTriple 3 4 5",
     "PythagoreanTriple 3 4 5",
     "PythagoreanTriple 3 4 5",
     "PythagoreanTriple 3 4 5",
     "PythagoreanTriple 3 4 5",
     "PythagoreanTriple 3 4 5",
     "PythagoreanTriple 3 4 5"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   ["PythagoreanTriple 3 4 5 ",
    "PythagoreanTriple 3 4 5 ",
    "PythagoreanTriple 3 4 5 ",
    "PythagoreanTriple 3 4 5 ",
    "PythagoreanTriple 3 4 5 ",
    "PythagoreanTriple 3 4 5 ",
    "PythagoreanTriple 3 4 5 ",
    "PythagoreanTriple 3 4 5 ",
    "PythagoreanTriple 3 4 5 ",
    "PythagoreanTriple 3 4 5 "]},
  {"theorem":
   "∀ {ι : Type u_1} {K : Type u_2} {V : Type u_3} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Basis ι K V → IsEmpty ι → Subsingleton V",
   "some-correct": null,
   "prompt": "A vector space with the empty set as basis is trivial.",
   "groups":
   [["∀ {ι : Type u_1} {K : Type u_2} {V : Type u_3} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Basis ι K V → IsEmpty ι → Subsingleton V"],
    ["∀ {ι : Type u_1} {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Basis ι K V → (ι → False) → Subsingleton V"],
    ["{ι : Type u_1} →\n  {K : Type u_2} →\n    {V : Type u_3} →\n      [inst : DivisionRing K] → [inst_1 : AddCommGroup V] → [inst_2 : Module K V] → Basis ι K V → ι → False → V"],
    ["∀ {ι : Type u_1} {K : Type u_2} {V : Type u_3} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  IsEmpty ι → Basis ι K V → Subsingleton V"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   ["∀ {ι : Type u_1} {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Basis ι K V → (ι → False) → Subsingleton V ",
    "∀ {ι : Type u} {K : Type v} {V : Type w} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  (b : Basis ι K V), b.repr = 0 → Subsingleton V ",
    "∀ {ι : Type u_1} {K : Type u_2} {V : Type u_3} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  (h : Basis ι K V), ι → False → V ",
    "∀ {ι : Type u_1} {K : Type u_2} {V : Type u_3} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  (h : IsEmpty ι), Basis ι K V → Subsingleton V ",
    "∀ {ι : Type u_1} {K : Type u_2} {V : Type u_3} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Basis ι K V → IsEmpty ι → Subsingleton V "]}],
 "elaborated": 39}