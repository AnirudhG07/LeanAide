{"noDocExamples":[],"kind":"Lean.Parser.Term.app","examples":[{"type":"RingHom.LocalizationPreserves @RingHom.Finite","name":"localization_finite","isProp":true,"doc":"If `S` is a finite `R`-algebra, then `S' = M⁻¹S` is a finite `R' = M⁻¹R`-algebra. ","depth":1},{"type":"Irrational goldenRatio","name":"gold_irrational","isProp":true,"doc":"The golden ratio is irrational. ","depth":1},{"type":"Irrational goldenConj","name":"goldConj_irrational","isProp":true,"doc":"The conjugate of the golden ratio is irrational. ","depth":1}],"count":218088}
{"noDocExamples":[],"kind":"Lean.Parser.Term.type","examples":[{"type":"∀ {R : Type u_1} [inst : MulZeroClass R] {a : R} [inst_1 : Nontrivial R], IsRegular a → a ≠ 0","name":"IsRegular.ne_zero","isProp":true,"doc":"A regular element of a `Nontrivial` `MulZeroClass` is non-zero. ","depth":10},{"type":"AlgebraicGeometry.Scheme → AlgebraicGeometry.Scheme → Type u_1","name":"AlgebraicGeometry.Scheme.Hom","isProp":false,"doc":"A morphism between schemes is a morphism between the underlying locally ringed spaces. ","depth":2},{"type":"∀ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] (J : CategoryTheory.GrothendieckTopology C),\n  (∀ (X : C), CategoryTheory.Presieve.IsSheaf J (CategoryTheory.yoneda.obj X)) → CategoryTheory.Sheaf.Subcanonical J","name":"CategoryTheory.Sheaf.Subcanonical.of_yoneda_isSheaf","isProp":true,"doc":"If every functor `yoneda.obj X` is a `J`-sheaf, then `J` is subcanonical. ","depth":17}],"count":193747}
{"noDocExamples":[],"kind":"Lean.Parser.Term.forall","examples":[{"type":"∀ {α : Prop}, α","name":"lcProof","isProp":true,"doc":"Auxiliary unsafe constant used by the Compiler when erasing proofs from code.\n\nIt may look strange to have an axiom that says \"every proposition is true\",\nsince this is obviously unsound, but the `unsafe` marker ensures that the\nkernel will not let this through into regular proofs. The lower levels of the\ncode generator don't need proofs in terms, so this is used to stub the proofs\nout.\n","depth":1},{"type":"∀ (n : ℕ), Int.NonNeg (Int.ofNat n)","name":"Int.NonNeg.mk","isProp":true,"doc":"Sole constructor, proving that `ofNat n` is positive. ","depth":3},{"type":"∀ (o : Ordinal.{u_1}), SetTheory.PGame.Numeric (Ordinal.toPGame o)","name":"SetTheory.PGame.numeric_toPGame","isProp":true,"doc":"Ordinal games are numeric. ","depth":3}],"count":182029}
{"noDocExamples":[],"kind":"«term_=_»","examples":[{"type":"Cardinal.mk ℂ = Cardinal.continuum","name":"mk_complex","isProp":true,"doc":"The cardinality of the complex numbers, as a type. ","depth":3},{"type":"Cardinal.mk ℝ = Cardinal.continuum","name":"Cardinal.mk_real","isProp":true,"doc":"The cardinality of the reals, as a type. ","depth":3},{"type":"Ordinal.lift.{max u v, u} = Ordinal.lift.{v, u}","name":"Ordinal.lift_umax","isProp":true,"doc":"`lift.{max u v, u}` equals `lift.{v, u}`. ","depth":4}],"count":108525}
{"noDocExamples":[],"kind":"Lean.Parser.Term.arrow","examples":[{"type":"∀ {R : Type u_1} [inst : MulZeroClass R] {a : R} [inst_1 : Nontrivial R], IsRegular a → a ≠ 0","name":"IsRegular.ne_zero","isProp":true,"doc":"A regular element of a `Nontrivial` `MulZeroClass` is non-zero. ","depth":10},{"type":"∀ {m : ℕ}, 2 ≤ m → ∀ (n : ℕ), (Finset.sum (Finset.range n) fun k => m ^ k) = (m ^ n - 1) / (m - 1)","name":"Nat.geomSum_eq","isProp":true,"doc":"If all the elements of a finset of naturals are less than `n`, then the sum of their powers of\n`m ≥ 2` is less than `m ^ n`. ","depth":14},{"type":"AlgebraicGeometry.Scheme → AlgebraicGeometry.Scheme → Type u_1","name":"AlgebraicGeometry.Scheme.Hom","isProp":false,"doc":"A morphism between schemes is a morphism between the underlying locally ringed spaces. ","depth":2}],"count":99857}
{"noDocExamples":[],"kind":"Lean.Parser.Term.depArrow","examples":[{"type":"(X : Type u) → [inst : TopologicalSpace X] → Prop","name":"CompletelyRegularSpace","isProp":false,"doc":"A space is completely regular if points can be separated from closed sets via\ncontinuous functions to the unit interval. ","depth":3},{"type":"{α : Type u} → α → List α → Prop","name":"List.Mem","isProp":false,"doc":"`a ∈ l` is a predicate which asserts that `a` is in the list `l`.\nUnlike `elem`, this uses `=` instead of `==` and is suited for mathematical reasoning.\n* `a ∈ [x, y, z] ↔ a = x ∨ a = y ∨ a = z`\n","depth":4},{"type":"{α : Type u_1} → GeneralizedContinuedFraction α → Stream'.Seq (GeneralizedContinuedFraction.Pair α)","name":"GeneralizedContinuedFraction.s","isProp":false,"doc":"Sequence of partial numerator and denominator pairs. ","depth":4}],"count":45052}
{"noDocExamples":[],"kind":"Lean.Parser.Term.proj","examples":[{"type":"∀ {F : PFunctor.{u}} (self : PFunctor.MIntl F), PFunctor.Approx.AllAgree self.approx","name":"PFunctor.MIntl.consistent","isProp":true,"doc":"Each approximation agrees with the next ","depth":5},{"type":"∀ {V : Type u} {G : SimpleGraph V} (self : SimpleGraph.Partition G), ∀ s ∈ self.parts, IsAntichain G.Adj s","name":"SimpleGraph.Partition.independent","isProp":true,"doc":"`independent`: a proof that each element of `parts` doesn't have a pair of adjacent vertices.\n","depth":11},{"type":"∀ {b o : Ordinal.{u}} {x : Ordinal.{u} × Ordinal.{u}}, x ∈ Ordinal.CNF b o → 0 < x.2","name":"Ordinal.CNF_lt_snd","isProp":true,"doc":"Every coefficient in a Cantor normal form is positive. ","depth":11}],"count":36155}
{"noDocExamples":[],"kind":"coeNotation","examples":[{"type":"∀ {𝕜 : Type u_1} {E : Type u_2} {M : Type u_3} {H : Type u_4} [inst : NontriviallyNormedField 𝕜]\n  [inst_1 : NormedAddCommGroup E] [inst_2 : NormedSpace 𝕜 E] [inst_3 : TopologicalSpace H] [inst_4 : TopologicalSpace M]\n  (f : PartialHomeomorph M H) (I : ModelWithCorners 𝕜 E H) {t : Set M},\n  t ⊆ f.source → ↑(PartialEquiv.symm (PartialHomeomorph.extend f I)) ∘ ↑(PartialHomeomorph.extend f I) '' t = t","name":"PartialHomeomorph.extend_left_inv'","isProp":true,"doc":"Variant of `f.extend_left_inv I`, stated in terms of images. ","depth":32},{"type":"{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] →\n    [inst_1 : CategoryTheory.Limits.HasColimits C] → (X : AlgebraicGeometry.PresheafedSpace C) → ↑↑X → C","name":"AlgebraicGeometry.PresheafedSpace.stalk","isProp":false,"doc":"The stalk at `x` of a `PresheafedSpace`.\n","depth":9},{"type":"∀ {s : ℂ} {N : ℕ} (χ : DirichletCharacter ℂ N) (hs : 1 < s.re),\n  Filter.Tendsto (fun n => Finset.prod (Nat.primesBelow n) fun p => (1 - χ ↑p * ↑p ^ (-s))⁻¹) Filter.atTop\n    (nhds (∑' (n : ℕ), (dirichletSummandHom χ (_ : s ≠ 0)) n))","name":"dirichletLSeries_eulerProduct","isProp":true,"doc":"The Euler product for Dirichlet L-series, valid for `s.re > 1`. ","depth":26}],"count":30909}
{"noDocExamples":[],"kind":"Lean.Parser.Term.explicitUniv","examples":[{"type":"∀ {C : Type u_1} [inst : CategoryTheory.Category.{u_2, u_1} C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]\n  [inst_2 : CategoryTheory.Limits.HasFiniteProducts C] [inst_3 : CategoryTheory.Limits.HasKernels C]\n  [inst_4 : CategoryTheory.NormalMonoCategory C] {X Y : C} (f g : X ⟶ Y),\n  CategoryTheory.Limits.HasLimit (CategoryTheory.Limits.parallelPair f g)","name":"CategoryTheory.NormalMonoCategory.hasLimit_parallelPair","isProp":true,"doc":"The equalizer of `f` and `g` exists. ","depth":17},{"type":"∀ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] (J : CategoryTheory.GrothendieckTopology C),\n  (∀ (X : C), CategoryTheory.Presieve.IsSheaf J (CategoryTheory.yoneda.obj X)) → CategoryTheory.Sheaf.Subcanonical J","name":"CategoryTheory.Sheaf.Subcanonical.of_yoneda_isSheaf","isProp":true,"doc":"If every functor `yoneda.obj X` is a `J`-sheaf, then `J` is subcanonical. ","depth":17},{"type":"{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] →\n    [inst_1 : CategoryTheory.Limits.HasColimits C] → (X : AlgebraicGeometry.PresheafedSpace C) → ↑↑X → C","name":"AlgebraicGeometry.PresheafedSpace.stalk","isProp":false,"doc":"The stalk at `x` of a `PresheafedSpace`.\n","depth":9}],"count":30708}
{"noDocExamples":[],"kind":"Lean.Parser.Term.fun","examples":[{"type":"∀ (n : ℕ), RePred fun c => (Nat.Partrec.Code.eval c n).Dom","name":"ComputablePred.halting_problem_re","isProp":true,"doc":"The Halting problem is recursively enumerable ","depth":6},{"type":"∀ {μ : YoungDiagram},\n  YoungDiagram.ofRowLens (YoungDiagram.rowLens μ) (_ : List.Sorted (fun x x_1 => x ≥ x_1) (YoungDiagram.rowLens μ)) = μ","name":"YoungDiagram.ofRowLens_to_rowLens_eq_self","isProp":true,"doc":"The left_inv direction of the equivalence ","depth":6},{"type":"∀ {α : Type u_1}, (Sym2.map fun x => x) = id","name":"Sym2.map_id'","isProp":true,"doc":"Note: `Sym2.map_id` will not simplify `Sym2.map id z` due to `Sym2.map_congr`. ","depth":6}],"count":27129}
{"noDocExamples":[],"kind":"termℕ","examples":[{"type":"∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)], Fintype.card α = p → IsCyclic α","name":"isCyclic_of_prime_card","isProp":true,"doc":"A finite group of prime order is cyclic. ","depth":10},{"type":"∀ {m : ℕ}, 2 ≤ m → ∀ (n : ℕ), (Finset.sum (Finset.range n) fun k => m ^ k) = (m ^ n - 1) / (m - 1)","name":"Nat.geomSum_eq","isProp":true,"doc":"If all the elements of a finset of naturals are less than `n`, then the sum of their powers of\n`m ≥ 2` is less than `m ^ n`. ","depth":14},{"type":"{G : Type u_1} → [inst : AddGroup G] → AddSubgroup G → AddSubgroup G → ℕ","name":"AddSubgroup.relindex","isProp":false,"doc":"The relative index of a subgroup as a natural number,\nand returns 0 if the relative index is infinite.","depth":6}],"count":23623}
{"noDocExamples":[],"kind":"«term_≤_»","examples":[{"type":"∀ (L : List ℕ), List.headI L ≤ List.sum L","name":"List.headI_le_sum","isProp":true,"doc":"This relies on `default ℕ = 0`. ","depth":6},{"type":"∀ {p : ℕ} (n : ℕ), padicValNat p n ≤ Nat.log p n","name":"padicValNat_le_nat_log","isProp":true,"doc":"The p-adic valuation of `n` is less than or equal to its logarithm w.r.t `p`.","depth":6},{"type":"∀ {p : ℝ}, p ≤ 0 → ENNReal.ofReal p = 0","name":"ENNReal.ofReal_of_nonpos","isProp":true,"doc":"**Alias** of the reverse direction of `ENNReal.ofReal_eq_zero`.","depth":6}],"count":21386}
{"noDocExamples":[],"kind":"«term_↔_»","examples":[{"type":"∀ (p : True → Prop), (∀ (x : True), p x) ↔ p True.intro","name":"forall_true_left","isProp":true,"doc":"See `IsEmpty.forall_iff` for the `False` version. ","depth":5},{"type":"∀ {a b : Prop}, (a ↔ b) → b → a","name":"Iff.mpr","isProp":true,"doc":"Modus ponens for if and only if, reversed. If `a ↔ b` and `b`, then `a`. ","depth":5},{"type":"∀ {a : Prop}, ¬¬a ↔ a","name":"Classical.not_not","isProp":true,"doc":"The Double Negation Theorem: `¬¬P` is equivalent to `P`.\nThe left-to-right direction, double negation elimination (DNE),\nis classically true but not constructively. ","depth":5}],"count":19764}
{"noDocExamples":[],"kind":"«term_+_»","examples":[{"type":"∀ {a : ℕ}, Real.sqrt ↑a ≤ ↑(Nat.sqrt a) + 1","name":"Real.real_sqrt_le_nat_sqrt_succ","isProp":true,"doc":"The real square root is at most the natural square root plus one ","depth":8},{"type":"∀ (n : ℕ), List.length (List.Nat.antidiagonal n) = n + 1","name":"List.Nat.length_antidiagonal","isProp":true,"doc":"The length of the antidiagonal of `n` is `n + 1`. ","depth":8},{"type":"∀ (n : ℕ), Finset.card (Finset.antidiagonal n) = n + 1","name":"Finset.Nat.card_antidiagonal","isProp":true,"doc":"The cardinality of the antidiagonal of `n` is `n + 1`. ","depth":8}],"count":19615}
{"noDocExamples":[],"kind":"«term_*_»","examples":[{"type":"∀ (x : SetTheory.PGame), 0 * x ≈ 0","name":"SetTheory.PGame.zero_mul_equiv","isProp":true,"doc":"`0 * x` is equivalent to `0`. ","depth":9},{"type":"∀ {n : ℕ} [inst : NeZero n], Fintype.card (DihedralGroup n) = 2 * n","name":"DihedralGroup.card","isProp":true,"doc":"If `0 < n`, then `DihedralGroup n` has `2n` elements.\n","depth":9},{"type":"(fun τ => jacobiTheta τ - 1) =O[Filter.comap Complex.im Filter.atTop] fun τ => Real.exp (-Real.pi * τ.im)","name":"isBigO_at_im_infty_jacobiTheta_sub_one","isProp":true,"doc":"The norm of `jacobiTheta τ - 1` decays exponentially as `im τ → ∞`. ","depth":9}],"count":17249}
{"noDocExamples":[],"kind":"«term_⟶_»","examples":[{"type":"∀ {C : Type u_1} [inst : CategoryTheory.Category.{u_2, u_1} C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]\n  [inst_2 : CategoryTheory.Limits.HasFiniteProducts C] [inst_3 : CategoryTheory.Limits.HasKernels C]\n  [inst_4 : CategoryTheory.NormalMonoCategory C] {X Y : C} (f g : X ⟶ Y),\n  CategoryTheory.Limits.HasLimit (CategoryTheory.Limits.parallelPair f g)","name":"CategoryTheory.NormalMonoCategory.hasLimit_parallelPair","isProp":true,"doc":"The equalizer of `f` and `g` exists. ","depth":17},{"type":"{C : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} C] →\n    {X A : C} → (f : A ⟶ X) → [inst_1 : CategoryTheory.Mono f] → CategoryTheory.Subobject X","name":"CategoryTheory.Subobject.mk","isProp":false,"doc":"Convenience constructor for a subobject. ","depth":11},{"type":"{X Y Z : Type u} → (X ⟶ Z) → (Y ⟶ Z) → Type u","name":"CategoryTheory.Limits.Types.PullbackObj","isProp":false,"doc":"The usual explicit pullback in the category of types, as a subtype of the product.\nThe full `LimitCone` data is bundled as `pullbackLimitCone f g`.\n","depth":11}],"count":15781}
{"noDocExamples":[],"kind":"«term_∈_»","examples":[{"type":"∀ (A : Class), Class.iota A ∈ Class.univ","name":"Class.iota_ex","isProp":true,"doc":"Unlike the other set constructors, the `iota` definite descriptor\nis a set for any set input, but not constructively so, so there is no\nassociated `Class → Set` function. ","depth":6},{"type":"∀ {M : Type u_1} [inst : Monoid M] {x : M}, x ∈ powers x","name":"powers.self_mem","isProp":true,"doc":"An element of a monoid is in the set of that element's natural number powers. ","depth":8},{"type":"∀ {M : Type u_1} [inst : AddMonoid M] {x : M}, x ∈ multiples x","name":"multiples.self_mem","isProp":true,"doc":"An element of an `AddMonoid` is in the set of that element's natural number multiples.","depth":8}],"count":15141}
{"noDocExamples":[],"kind":"«term_<_»","examples":[{"type":"0 < 1","name":"Nat.one_pos","isProp":true,"doc":"**Alias** of `Nat.zero_lt_one`.","depth":5},{"type":"∀ (x : ℝ), 0 < Real.cosh x","name":"Real.cosh_pos","isProp":true,"doc":"`Real.cosh` is always positive ","depth":6},{"type":"∀ {n : ℕ} (self : Fin n), ↑self < n","name":"Fin.isLt","isProp":true,"doc":"If `i : Fin n`, then `i.2` is a proof that `i.1 < n`. ","depth":6}],"count":11431}
{"noDocExamples":[],"kind":"termℝ","examples":[{"type":"∀ {E : Type u_3} [inst : NormedAddCommGroup E] [inst_1 : CompleteSpace E] [inst_2 : NormedSpace ℝ E] {a b : ℝ}\n  {f f' : ℝ → ℝ} {g : ℝ → E},\n  ContinuousOn f (Set.uIcc a b) →\n    (∀ x ∈ Set.Ioo (min a b) (max a b), HasDerivWithinAt f (f' x) (Set.Ioi x) x) →\n      ContinuousOn f' (Set.uIcc a b) →\n        ContinuousOn g (f '' Set.uIcc a b) → ∫ (x : ℝ) in a..b, f' x • (g ∘ f) x = ∫ (u : ℝ) in f a..f b, g u","name":"intervalIntegral.integral_comp_smul_deriv''","isProp":true,"doc":"Change of variables for continuous integrands. If `f` is continuous on `[a, b]` and has\ncontinuous right-derivative `f'` in `(a, b)`, and `g` is continuous on `f '' [a, b]` then we can\nsubstitute `u = f x` to get `∫ x in a..b, f' x • (g ∘ f) x = ∫ u in f a..f b, g u`.\n","depth":35},{"type":"{G : Type u_1} → [inst : AddGroup G] → [inst : TopologicalSpace G] → Set G → Set (TopologicalSpace.Compacts G → ℝ)","name":"MeasureTheory.Measure.haar.addHaarProduct","isProp":false,"doc":"additive version of `MeasureTheory.Measure.haar.haarProduct`","depth":8},{"type":"∀ {α : Type u_1} [inst : Nonempty α] [inst : SemilatticeSup α] [inst_1 : NoMaxOrder α] {β : Type u_5}\n  [inst_2 : SeminormedAddCommGroup β] {f : α → β} {b : β},\n  Filter.Tendsto f Filter.atTop (nhds b) ↔ ∀ (ε : ℝ), 0 < ε → ∃ N, ∀ (n : α), N < n → ‖f n - b‖ < ε","name":"NormedAddCommGroup.tendsto_atTop'","isProp":true,"doc":"A variant of `NormedAddCommGroup.tendsto_atTop` that\nuses `∃ N, ∀ n > N, ...` rather than `∃ N, ∀ n ≥ N, ...`\n","depth":27}],"count":10257}
{"noDocExamples":[],"kind":"Lean.Parser.Term.prop","examples":[{"type":"∀ {α : Prop}, α","name":"lcProof","isProp":true,"doc":"Auxiliary unsafe constant used by the Compiler when erasing proofs from code.\n\nIt may look strange to have an axiom that says \"every proposition is true\",\nsince this is obviously unsound, but the `unsafe` marker ensures that the\nkernel will not let this through into regular proofs. The lower levels of the\ncode generator don't need proofs in terms, so this is used to stub the proofs\nout.\n","depth":1},{"type":"(X : Type u) → [inst : TopologicalSpace X] → Prop","name":"CompletelyRegularSpace","isProp":false,"doc":"A space is completely regular if points can be separated from closed sets via\ncontinuous functions to the unit interval. ","depth":3},{"type":"(𝕜 : Type u_1) →\n  {E : Type u_2} → [inst : OrderedSemiring 𝕜] → [inst : AddCommMonoid E] → [inst : SMul 𝕜 E] → Set E → Prop","name":"Convex","isProp":false,"doc":"Convexity of sets. ","depth":7}],"count":10062}
{"noDocExamples":[],"kind":"Std.Tactic.Coe.coeFunNotation","examples":[{"type":"∀ {α : Type u_1} (f : Poly α), IsPoly ⇑f","name":"Poly.isPoly","isProp":true,"doc":"The underlying function of a `Poly` is a polynomial ","depth":9},{"type":"∀ {α : Sort u} {β : Sort v}, Function.Injective fun e => ⇑e","name":"Equiv.coe_fn_injective","isProp":true,"doc":"The map `(r ≃ s) → (r → s)` is injective. ","depth":11},{"type":"∀ {α : Type u_1} [inst : Subsingleton α] (e : Equiv.Perm α), ⇑e = id","name":"Equiv.Perm.coe_subsingleton","isProp":true,"doc":"This cannot be a `simp` lemmas as it incorrectly matches against `e : α ≃ synonym α`, when\n`synonym α` is semireducible. This makes a mess of `Multiplicative.ofAdd` etc. ","depth":11}],"count":9937}
{"noDocExamples":[],"kind":"Lean.Parser.Term.hole","examples":[{"type":"∀ {μ : YoungDiagram},\n  YoungDiagram.ofRowLens (YoungDiagram.rowLens μ) (_ : List.Sorted (fun x x_1 => x ≥ x_1) (YoungDiagram.rowLens μ)) = μ","name":"YoungDiagram.ofRowLens_to_rowLens_eq_self","isProp":true,"doc":"The left_inv direction of the equivalence ","depth":6},{"type":"∀ {α : Sort u_1} {p : α → Prop} {q : (x : α) → p x → Prop},\n  (∀ (x : α) (h : p x), q x h) ↔ ∀ (x : { a // p a }), q ↑x (_ : p ↑x)","name":"Subtype.forall'","isProp":true,"doc":"An alternative version of `Subtype.forall`. This one is useful if Lean cannot figure out `q`\nwhen using `Subtype.forall` from right to left. ","depth":11},{"type":"∀ {α : Type u_1} {s : Set (Set α)} (hs : IsPiSystem s),\n  MeasurableSpace.generateFrom s =\n    MeasurableSpace.DynkinSystem.toMeasurableSpace (MeasurableSpace.DynkinSystem.generate s)\n      (_ :\n        ∀ (t₁ t₂ : Set α),\n          MeasurableSpace.DynkinSystem.Has (MeasurableSpace.DynkinSystem.generate s) t₁ →\n            MeasurableSpace.DynkinSystem.Has (MeasurableSpace.DynkinSystem.generate s) t₂ →\n              MeasurableSpace.DynkinSystem.Has (MeasurableSpace.DynkinSystem.generate s) (t₁ ∩ t₂))","name":"MeasurableSpace.DynkinSystem.generateFrom_eq","isProp":true,"doc":"**Dynkin's π-λ theorem**:\nGiven a collection of sets closed under binary intersections, then the Dynkin system it\ngenerates is equal to the σ-algebra it generates.\nThis result is known as the π-λ theorem.\nA collection of sets closed under binary intersection is called a π-system (often requiring\nadditionally that it is non-empty, but we drop this condition in the formalization).\n","depth":12}],"count":8555}
{"noDocExamples":[],"kind":"«term_≠_»","examples":[{"type":"∀ (self : ℚ), self.den ≠ 0","name":"Rat.den_nz","isProp":true,"doc":"The denominator is nonzero. ","depth":5},{"type":"∀ {a b : ℕ}, b < a → a ≠ b","name":"Nat.ne_of_lt'","isProp":true,"doc":"**Alias** of `Nat.ne_of_gt`.","depth":7},{"type":"∀ {M₀ : Type u_2} [inst : MonoidWithZero M₀] [inst_1 : Nontrivial M₀] (u : M₀ˣ), ↑u ≠ 0","name":"Units.ne_zero","isProp":true,"doc":"An element of the unit group of a nonzero monoid with zero represented as an element\nof the monoid is nonzero. ","depth":10}],"count":8300}
{"noDocExamples":[],"kind":"«term_•_»","examples":[{"type":"∀ {M : Type u} [inst : AddMonoid M] (a : M), 2 • a = a + a","name":"two_nsmul","isProp":true,"doc":"","depth":11},{"type":"∀ (n k : ℕ), Nat.factorization (n ^ k) = k • Nat.factorization n","name":"Nat.factorization_pow","isProp":true,"doc":"For any `p`, the power of `p` in `n^k` is `k` times the power in `n` ","depth":11},{"type":"∀ {G : Type u_1} [inst : AddMonoid G] {x : G}, (Function.Injective fun n => n • x) → ¬IsOfFinAddOrder x","name":"not_isOfFinAddOrder_of_injective_nsmul","isProp":true,"doc":"See also `injective_nsmul_iff_not_isOfFinAddOrder`.","depth":12}],"count":8191}
{"noDocExamples":[],"kind":"Lean.Parser.Term.typeAscription","examples":[{"type":"∀ {μ : YoungDiagram},\n  YoungDiagram.ofRowLens (YoungDiagram.rowLens μ) (_ : List.Sorted (fun x x_1 => x ≥ x_1) (YoungDiagram.rowLens μ)) = μ","name":"YoungDiagram.ofRowLens_to_rowLens_eq_self","isProp":true,"doc":"The left_inv direction of the equivalence ","depth":6},{"type":"∀ {α : Type u_1} (r : Setoid α), Setoid.mkClasses (Setoid.classes r) (_ : ∀ (a : α), ∃! b x, a ∈ b) = r","name":"Setoid.mkClasses_classes","isProp":true,"doc":"The equivalence relation made from the equivalence classes of an equivalence\nrelation r equals r. ","depth":8},{"type":"∀ {n m : ℕ} (h : Fin n = Fin m), cast h = Fin.cast (_ : n = m)","name":"Fin.cast_eq_cast'","isProp":true,"doc":"A reversed version of `Fin.cast_eq_cast` that is easier to rewrite with. ","depth":9}],"count":8063}
{"noDocExamples":[],"kind":"Lean.Parser.Term.structInst","examples":[{"type":"∀ {α : Sort u} (a : α), { down := a }.down = a","name":"PLift.down_up","isProp":true,"doc":"Bijection between `α` and `PLift α` ","depth":7},{"type":"∀ {α : Type u} (b : ULift.{v, u} α), { down := b.down } = b","name":"ULift.up_down","isProp":true,"doc":"Bijection between `α` and `ULift.{v} α` ","depth":7},{"type":"∀ {α : Sort u} (b : PLift α), { down := b.down } = b","name":"PLift.up_down","isProp":true,"doc":"Bijection between `α` and `PLift α` ","depth":7}],"count":7614}
{"noDocExamples":[],"kind":"Std.Tactic.Coe.coeSortNotation","examples":[{"type":"∀ {a : ℝ}, DiscreteTopology ↥(AddSubgroup.zmultiples a)","name":"Int.instDiscreteTopologySubtypeRealMemAddSubgroupInstAddGroupRealInstMembershipInstSetLikeAddSubgroupZmultiplesInstTopologicalSpaceSubtypeToTopologicalSpaceToUniformSpacePseudoMetricSpace","isProp":true,"doc":"This is a special case of `NormedSpace.discreteTopology_zmultiples`. It exists only to simplify\ndependencies. ","depth":13},{"type":"{S : Type u_5} →\n  [inst : Semiring S] →\n    {M : Type u_6} →\n      [inst_1 : AddCommMonoid M] →\n        [inst_2 : Module S M] → {m : Submodule S M} → {f : M →ₗ[S] M} → LinearMap.IsProj m f → M →ₗ[S] ↥m","name":"LinearMap.IsProj.codRestrict","isProp":false,"doc":"Restriction of the codomain of a projection of onto a subspace `p` to `p` instead of the whole\nspace.\n","depth":26},{"type":"{R : Type u_1} →\n  [inst : CommRing R] →\n    (S : Submonoid R) →\n      {M : Type u_2} →\n        {M'' : Type u_4} →\n          [inst_1 : AddCommMonoid M] →\n            [inst_2 : AddCommMonoid M''] →\n              [inst_3 : Module R M] →\n                [inst_4 : Module R M''] →\n                  (M →ₗ[R] M'') →\n                    (∀ (x : ↥S), IsUnit ((algebraMap R (Module.End R M'')) ↑x)) → LocalizedModule S M → M''","name":"LocalizedModule.lift'","isProp":false,"doc":"If `g` is a linear map `M → M''` such that all scalar multiplication by `s : S` is invertible, then\nthere is a linear map `LocalizedModule S M → M''`.\n","depth":33}],"count":6493}
{"noDocExamples":[],"kind":"«term_∧_»","examples":[{"type":"∀ {a b : Prop}, a ∧ b → a","name":"And.left","isProp":true,"doc":"Extract the left conjunct from a conjunction. `h : a ∧ b` then\n`h.left`, also notated as `h.1`, is a proof of `a`. ","depth":5},{"type":"∀ {a b : Prop}, a ∧ b → b","name":"And.right","isProp":true,"doc":"Extract the right conjunct from a conjunction. `h : a ∧ b` then\n`h.right`, also notated as `h.2`, is a proof of `b`. ","depth":5},{"type":"∀ {a b : Prop}, a → b → a ∧ b","name":"And.intro","isProp":true,"doc":"`And.intro : a → b → a ∧ b` is the constructor for the And operation. ","depth":6}],"count":6343}
{"noDocExamples":[],"kind":"Lean.Parser.Term.sort","examples":[{"type":"{α : Sort u} → {β : Sort v} → (α → β) → PLift α → PLift β","name":"PLift.map","isProp":false,"doc":"Functorial action. ","depth":5},{"type":"{ι : Sort u_1} → {α : ι → Sort u_2} → [inst : Unique ι] → α default → (i : ι) → α i","name":"uniqueElim","isProp":false,"doc":"Given one value over a unique, we get a dependent function. ","depth":8},{"type":"∀ {F : Sort u_1} {α : outParam (Sort u_2)} {β : outParam (α → Sort u_3)} [self : FunLike F α β],\n  Function.Injective FunLike.coe","name":"FunLike.coe_injective'","isProp":true,"doc":"The coercion to functions must be injective. ","depth":9}],"count":6275}
{"noDocExamples":[],"kind":"«term_-_»","examples":[{"type":"∀ (L : List ℕ), List.sum (List.tail L) = List.sum L - List.headI L","name":"List.tail_sum","isProp":true,"doc":"This relies on `default ℕ = 0`. ","depth":8},{"type":"(fun τ => jacobiTheta τ - 1) =O[Filter.comap Complex.im Filter.atTop] fun τ => Real.exp (-Real.pi * τ.im)","name":"isBigO_at_im_infty_jacobiTheta_sub_one","isProp":true,"doc":"The norm of `jacobiTheta τ - 1` decays exponentially as `im τ → ∞`. ","depth":9},{"type":"∀ {a : ENNReal}, a - ⊤ = 0","name":"ENNReal.sub_top","isProp":true,"doc":"This is a special case of `WithTop.sub_top` in the `ENNReal` namespace ","depth":9}],"count":6266}
{"noDocExamples":[],"kind":"«term_^_»","examples":[{"type":"∀ {q : ℕ+}, Fintype.card (LucasLehmer.X q) = ↑q ^ 2","name":"LucasLehmer.X.card_eq","isProp":true,"doc":"The cardinality of `X` is `q^2`. ","depth":8},{"type":"LinearRecurrence.IsSolution fibRec fun x => goldenConj ^ x","name":"geom_goldConj_isSol_fibRec","isProp":true,"doc":"The geometric sequence `fun n ↦ ψ^n` is a solution of `fibRec`. ","depth":8},{"type":"∀ (a : ℤ), ↑(Int.natAbs a) ≤ a ^ 2","name":"Int.natAbs_le_self_pow_two","isProp":true,"doc":"**Alias** of `Int.natAbs_le_self_sq`.","depth":8}],"count":5999}
{"noDocExamples":[],"kind":"Std.ExtendedBinder.«term∀__,_»","examples":[{"type":"∀ (S : Set ℝ), (∀ x ∈ S, x ≤ 0) → sSup S ≤ 0","name":"Real.sSup_nonpos","isProp":true,"doc":"As `0` is the default value for `Real.sSup` of the empty set, it suffices to show that `S` is\nbounded above by `0` to show that `sSup S ≤ 0`.\n","depth":9},{"type":"∀ (S : Set ℝ), (∀ x ∈ S, x ≤ 0) → sInf S ≤ 0","name":"Real.sInf_nonpos","isProp":true,"doc":"As `0` is the default value for `Real.sInf` of the empty set or sets which are not bounded below, it\nsuffices to show that `S` is bounded above by `0` to show that `sInf S ≤ 0`.\n","depth":9},{"type":"∀ {α : Type u_1} (M : Matroid α), ∀ X ⊆ M.E, Matroid.ExistsMaximalSubsetProperty M.Indep X","name":"Matroid.existsMaximalSubsetProperty_indep","isProp":true,"doc":"Matroids obey the maximality axiom ","depth":9}],"count":5718}
{"noDocExamples":[],"kind":"«term∃_,_»","examples":[{"type":"∀ {p : ℕ → Prop}, (∃ x, p x) → WellFounded (Nat.Upto.GT p)","name":"Nat.Upto.wf","isProp":true,"doc":"The \"greater than\" relation on `Upto p` is well founded if (and only if) there exists a value\nsatisfying `p`. ","depth":5},{"type":"∀ (p : True → Prop), (∃ (x : True), p x) ↔ p True.intro","name":"exists_true_left","isProp":true,"doc":"See `IsEmpty.exists_iff` for the `False` version. ","depth":6},{"type":"∀ (G : Type u_1) [inst : Monoid G], ¬Monoid.IsTorsion G ↔ ∃ g, ¬IsOfFinOrder g","name":"Monoid.not_isTorsion_iff","isProp":true,"doc":"A monoid is not a torsion monoid if it has an element of infinite order. ","depth":9}],"count":5673}
{"noDocExamples":[],"kind":"termℤ","examples":[{"type":"∀ {a b c : ℤ}, a % b = c → Int.natAbs (a - c) < Int.natAbs b → a = c","name":"Int.eq_of_mod_eq_of_natAbs_sub_lt_natAbs","isProp":true,"doc":"If two integers are congruent to a sufficiently large modulus,\nthey are equal. ","depth":14},{"type":"∀ {R : Type u_1} {ι : Type u_2} {A : Type u_3} {B : Type u_4} [inst : CommSemiring ι] [inst_1 : Module ι (Additive ℤˣ)]\n  [inst_2 : DecidableEq ι] [inst_3 : CommRing R] [inst_4 : Ring A] [inst_5 : Ring B] [inst_6 : Algebra R A]\n  [inst_7 : Algebra R B] (𝒜 : ι → Submodule R A) (ℬ : ι → Submodule R B) [inst_8 : GradedAlgebra 𝒜]\n  [inst_9 : GradedAlgebra ℬ] {j₁ : ι} (a₁ : A) (b₁ : ↥(ℬ j₁)) (a₂ : ↥(𝒜 0)) (b₂ : B),\n  a₁ ᵍ⊗ₜ[R] ↑b₁ * ↑a₂ ᵍ⊗ₜ[R] b₂ = (a₁ * ↑a₂) ᵍ⊗ₜ[R] (↑b₁ * b₂)","name":"GradedTensorProduct.tmul_coe_mul_zero_coe_tmul","isProp":true,"doc":"A special case for when `a₂` has grade 0. ","depth":44},{"type":"ℤ → ℤ","name":"Int.div2","isProp":false,"doc":"`div2 n = n/2`","depth":1}],"count":5211}
{"noDocExamples":[],"kind":"«term-_»","examples":[{"type":"goldenConj⁻¹ = -goldenRatio","name":"inv_goldConj","isProp":true,"doc":"The opposite of the golden ratio is the inverse of its conjugate. ","depth":5},{"type":"goldenRatio⁻¹ = -goldenConj","name":"inv_gold","isProp":true,"doc":"The inverse of the golden ratio is the opposite of its conjugate. ","depth":5},{"type":"∀ (n : ℕ), padicValRat 2 (harmonic n) = -↑(Nat.log 2 n)","name":"padicValRat_two_harmonic","isProp":true,"doc":"The 2-adic valuation of the n-th harmonic number is the negative of the logarithm\nof n. ","depth":9}],"count":5085}
{"noDocExamples":[],"kind":"«term_×_»","examples":[{"type":"∀ {b o : Ordinal.{u}} {x : Ordinal.{u} × Ordinal.{u}}, x ∈ Ordinal.CNF b o → 0 < x.2","name":"Ordinal.CNF_lt_snd","isProp":true,"doc":"Every coefficient in a Cantor normal form is positive. ","depth":11},{"type":"(C : Type u₁) →\n  [inst : CategoryTheory.Category.{v₁, u₁} C] →\n    (D : Type u₁) → [inst : CategoryTheory.Category.{v₁, u₁} D] → CategoryTheory.Category.{v₁, u₁} (C × D)","name":"CategoryTheory.uniformProd","isProp":false,"doc":"`Category.uniformProd C D` is an additional instance specialised so both factors have the same\nuniverse levels. This helps typeclass resolution.\n","depth":7},{"type":"∀ {α : Type u_1} {β : Type u_3} [inst : MeasurableSpace α] [inst_1 : MeasurableSpace β] {μ : MeasureTheory.Measure α}\n  [inst_2 : MeasureTheory.SFinite μ] {f : α × β → ENNReal}, Measurable f → Measurable fun y => ∫⁻ (x : α), f (x, y) ∂μ","name":"Measurable.lintegral_prod_left'","isProp":true,"doc":"The Lebesgue integral is measurable. This shows that the integrand of (the right-hand-side of)\nthe symmetric version of Tonelli's theorem is measurable. ","depth":17}],"count":4961}
{"noDocExamples":[],"kind":"«term_⊆_»","examples":[{"type":"∀ {x : ZFSet}, ZFSet.IsTransitive x → x ⊆ ZFSet.powerset x","name":"ZFSet.IsTransitive.subset_powerset","isProp":true,"doc":"**Alias** of the forward direction of `ZFSet.isTransitive_iff_subset_powerset`.","depth":6},{"type":"∀ {A : Class}, Class.powerset A ⊆ A → A = Class.univ","name":"Class.eq_univ_of_powerset_subset","isProp":true,"doc":"An induction principle for sets. If every subset of a class is a member, then the class is\nuniversal. ","depth":6},{"type":"∀ {x : ZFSet}, ZFSet.IsTransitive x → ⋃₀ x ⊆ x","name":"ZFSet.IsTransitive.sUnion_subset","isProp":true,"doc":"**Alias** of the forward direction of `ZFSet.isTransitive_iff_sUnion_subset`.","depth":6}],"count":4702}
{"noDocExamples":[],"kind":"«term⊤»","examples":[{"type":"∀ {α : Type u_1} [inst : Monoid α], Monoid.IsTorsionFree α → Monoid.minOrder α = ⊤","name":"Monoid.IsTorsionFree.minOrder","isProp":true,"doc":"**Alias** of the reverse direction of `Monoid.minOrder_eq_top`.","depth":7},{"type":"∀ {α : Type u_1} {G : SimpleGraph α}, SimpleGraph.IsAcyclic G → SimpleGraph.girth G = ⊤","name":"SimpleGraph.IsAcyclic.girth_eq_top","isProp":true,"doc":"**Alias** of the reverse direction of `SimpleGraph.girth_eq_top`.","depth":7},{"type":"∀ {α : Type u} [inst : Subsingleton α] (l : Filter α) [inst : Filter.NeBot l], l = ⊤","name":"Filter.eq_top_of_neBot","isProp":true,"doc":"There are only two filters on a `subsingleton`: `⊥` and `⊤`. If the type is empty, then they are\nequal. ","depth":8}],"count":4497}
{"noDocExamples":[],"kind":"«term_/_»","examples":[{"type":"riemannZeta 0 = -1 / 2","name":"riemannZeta_zero","isProp":true,"doc":"We have `ζ(0) = -1 / 2`. ","depth":8},{"type":"¬Summable fun n => 1 / ↑n","name":"Real.not_summable_one_div_nat_cast","isProp":true,"doc":"Harmonic series is not unconditionally summable. ","depth":9},{"type":"Real.sin (Real.pi / 3) = Real.sqrt 3 / 2","name":"Real.sin_pi_div_three","isProp":true,"doc":"The sine of `π / 3` is `√3 / 2`. ","depth":10}],"count":3866}
{"noDocExamples":[],"kind":"«term_⁻¹»","examples":[{"type":"goldenConj⁻¹ = -goldenRatio","name":"inv_goldConj","isProp":true,"doc":"The opposite of the golden ratio is the inverse of its conjugate. ","depth":5},{"type":"goldenRatio⁻¹ = -goldenConj","name":"inv_gold","isProp":true,"doc":"The inverse of the golden ratio is the opposite of its conjugate. ","depth":5},{"type":"∀ {p : ℕ}, 1 < p → padicNorm p ↑p = (↑p)⁻¹","name":"padicNorm.padicNorm_p","isProp":true,"doc":"The `p`-adic norm of `p` is `p⁻¹` if `p > 1`.\n\nSee also `padicNorm.padicNorm_p_of_prime` for a version assuming `p` is prime. ","depth":9}],"count":3271}
{"noDocExamples":[],"kind":"«term_∘_»","examples":[{"type":"Antitone (Stirling.stirlingSeq ∘ Nat.succ)","name":"Stirling.stirlingSeq'_antitone","isProp":true,"doc":"The sequence `stirlingSeq ∘ succ` is monotone decreasing ","depth":6},{"type":"Antitone (Real.log ∘ Stirling.stirlingSeq ∘ Nat.succ)","name":"Stirling.log_stirlingSeq'_antitone","isProp":true,"doc":"The sequence `log ∘ stirlingSeq ∘ succ` is monotone decreasing ","depth":7},{"type":"Cardinal.ord ∘ Cardinal.aleph' = Ordinal.enumOrd {b | Cardinal.ord (Ordinal.card b) = b}","name":"Cardinal.ord_aleph'_eq_enum_card","isProp":true,"doc":"`ord ∘ aleph'` enumerates the ordinals that are cardinals. ","depth":8}],"count":3034}
{"noDocExamples":[],"kind":"«term_→+*_»","examples":[{"type":"{R : Type u} → {S : Type v} → [inst : Semiring R] → [inst_1 : Semiring S] → (R →+* S) → Polynomial R → Polynomial S","name":"Polynomial.map","isProp":false,"doc":"`map f p` maps a polynomial `p` across a ring hom `f` ","depth":9},{"type":"{R : Type u_1} → {S : Type u_2} → [inst : Semiring R] → [inst_1 : Semiring S] → (R →+* S) → S → Polynomial R → S","name":"Polynomial.eval₂","isProp":false,"doc":"Evaluate a polynomial `p` given a ring hom `f` from the scalar ring\nto the target and a value `x` for the variable in the target ","depth":9},{"type":"{R : Type u₁} → {S : Type u₂} → [inst : Ring R] → [inst_1 : Ring S] → (R →+* S) → ModuleCat S → ModuleCat R","name":"ModuleCat.RestrictScalars.obj'","isProp":false,"doc":"Any `S`-module M is also an `R`-module via a ring homomorphism `f : R ⟶ S` by defining\n`r • m := f r • m` (`Module.compHom`). This is called restriction of scalars. ","depth":10}],"count":2899}
{"noDocExamples":[],"kind":"«term{_}»","examples":[{"type":"Multiset.Nat.antidiagonal 0 = {(0, 0)}","name":"Multiset.Nat.antidiagonal_zero","isProp":true,"doc":"The antidiagonal of `0` is the list `[(0, 0)]` ","depth":7},{"type":"Finset.antidiagonal 0 = {(0, 0)}","name":"Finset.Nat.antidiagonal_zero","isProp":true,"doc":"The antidiagonal of `0` is the list `[(0, 0)]` ","depth":7},{"type":"∀ {P : Type u_2} [inst : MetricSpace P] (p : P), EuclideanGeometry.Cospherical {p}","name":"EuclideanGeometry.cospherical_singleton","isProp":true,"doc":"A single point is cospherical. ","depth":8}],"count":2799}
{"noDocExamples":[],"kind":"«term¬_»","examples":[{"type":"¬Small.{u, max (u + 1) (v + 1)} Ordinal.{max u v}","name":"not_small_ordinal","isProp":true,"doc":"The type of ordinals in universe `u` is not `Small.{u}`. This is the type-theoretic analog of\nthe Burali-Forti paradox. ","depth":2},{"type":"¬Set.Countable Set.univ","name":"Cardinal.not_countable_real","isProp":true,"doc":"**Non-Denumerability of the Continuum**: The reals are not countable. ","depth":3},{"type":"∀ (p : Prop), p ∨ ¬p","name":"em","isProp":true,"doc":"**Alias** of `Classical.em`.\n\n---\n\nDiaconescu's theorem: excluded middle from choice, Function extensionality and propositional extensionality. ","depth":3}],"count":2789}
{"noDocExamples":[],"kind":"«term_ᵒᵖ»","examples":[{"type":"{C : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} C] →\n    {D : Type u₂} →\n      [inst_1 : CategoryTheory.Category.{v₂, u₂} D] →\n        {J : Type w} →\n          [inst_2 : CategoryTheory.Category.{w', w} J] →\n            (K : CategoryTheory.Functor J Cᵒᵖ) →\n              (F : CategoryTheory.Functor C D) →\n                [inst_3 : CategoryTheory.Limits.PreservesLimit K.leftOp F] →\n                  CategoryTheory.Limits.PreservesColimit K F.op","name":"CategoryTheory.Limits.preservesColimitOp","isProp":false,"doc":"If `F : C ⥤ D` preserves limits of `K.left_op : Jᵒᵖ ⥤ C`, then `F.op : Cᵒᵖ ⥤ Dᵒᵖ` preserves\ncolimits of `K : J ⥤ Cᵒᵖ`. ","depth":18},{"type":"∀ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] (P : CategoryTheory.Functor Cᵒᵖ (Type (max v u))) {X : C}\n  (S : CategoryTheory.Sieve X),\n  CategoryTheory.Presieve.IsSheafFor P S.arrows ↔\n    Nonempty\n      (CategoryTheory.Limits.IsLimit\n        (CategoryTheory.Limits.Fork.ofι (CategoryTheory.Equalizer.forkMap P S.arrows)\n          (_ :\n            CategoryTheory.CategoryStruct.comp (CategoryTheory.Equalizer.forkMap P S.arrows)\n                (CategoryTheory.Equalizer.Sieve.firstMap P S) =\n              CategoryTheory.CategoryStruct.comp (CategoryTheory.Equalizer.forkMap P S.arrows)\n                (CategoryTheory.Equalizer.Sieve.secondMap P S))))","name":"CategoryTheory.Equalizer.Sieve.equalizer_sheaf_condition","isProp":true,"doc":"`P` is a sheaf for `S`, iff the fork given by `w` is an equalizer. ","depth":20},{"type":"(S : CategoryTheory.Functor Type uᵒᵖ (Type u)) →\n  CategoryTheory.Presieve.IsSheaf CategoryTheory.typesGrothendieckTopology S →\n    (α : Type u) → (α → S.obj (Opposite.op PUnit.{u + 1})) → S.obj (Opposite.op α)","name":"CategoryTheory.typesGlue","isProp":false,"doc":"Given a sheaf `S` on the category of types, construct a map\n`(α → S(*)) → S(α)` that is inverse to `eval`. ","depth":14}],"count":2746}
{"noDocExamples":[],"kind":"CategoryTheory.«term_≅_»","examples":[{"type":"{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] →\n    {X Y : C} → CategoryTheory.Limits.IsZero X → CategoryTheory.Limits.IsInitial Y → (X ≅ Y)","name":"CategoryTheory.Limits.IsZero.isoIsInitial","isProp":false,"doc":"The (unique) isomorphism between any initial object and the zero object. ","depth":10},{"type":"{X Y : Stonean} → CoeSort.coe X ≃ₜ CoeSort.coe Y → (X ≅ Y)","name":"Stonean.isoOfHomeo","isProp":false,"doc":"Construct an isomorphism from a homeomorphism. ","depth":11},{"type":"(C : Type u) →\n  (A : Type u_1) →\n    [inst : CategoryTheory.Category.{v, u} C] →\n      [inst_1 : AddMonoid A] →\n        [inst_2 : CategoryTheory.HasShift C A] → CategoryTheory.shiftFunctor C 0 ≅ CategoryTheory.Functor.id C","name":"CategoryTheory.shiftFunctorZero","isProp":false,"doc":"Shifting by zero is the identity functor. ","depth":13}],"count":2731}
{"noDocExamples":[],"kind":"Lean.Parser.Term.tuple","examples":[{"type":"Multiset.Nat.antidiagonal 0 = {(0, 0)}","name":"Multiset.Nat.antidiagonal_zero","isProp":true,"doc":"The antidiagonal of `0` is the list `[(0, 0)]` ","depth":7},{"type":"Finset.antidiagonal 0 = {(0, 0)}","name":"Finset.Nat.antidiagonal_zero","isProp":true,"doc":"The antidiagonal of `0` is the list `[(0, 0)]` ","depth":7},{"type":"List.Nat.antidiagonal 0 = [(0, 0)]","name":"List.Nat.antidiagonal_zero","isProp":true,"doc":"The antidiagonal of `0` is the list `[(0, 0)]` ","depth":8}],"count":2693}
{"noDocExamples":[],"kind":"«term‖_‖»","examples":[{"type":"∀ {α : Type u_5} [self : NontriviallyNormedField α], ∃ x, 1 < ‖x‖","name":"NontriviallyNormedField.non_trivial","isProp":true,"doc":"The norm attains a value exceeding 1. ","depth":10},{"type":"∀ {α : Type u_5} [inst : Norm α] [inst_1 : One α] [self : NormOneClass α], ‖1‖ = 1","name":"NormOneClass.norm_one","isProp":true,"doc":"The norm of the multiplicative identity is 1. ","depth":10},{"type":"∀ (V : Type u_1) [inst : SeminormedAddCommGroup V], ‖NormedAddGroupHom.id V‖ ≤ 1","name":"NormedAddGroupHom.norm_id_le","isProp":true,"doc":"The norm of the identity is at most `1`. It is in fact `1`, except when the norm of every\nelement vanishes, where it is `0`. (Since we are working with seminorms this can happen even if the\nspace is non-trivial.) It means that one can not do better than an inequality in general. ","depth":11}],"count":2616}
{"noDocExamples":[],"kind":"«term_≃_»","examples":[{"type":"List Unit ≃ ℕ","name":"Equiv.listUnitEquiv","isProp":false,"doc":"The type lists on unit is canonically equivalent to the natural numbers. ","depth":3},{"type":"Bool ≃ PUnit.{u + 1} ⊕ PUnit.{v + 1}","name":"Equiv.boolEquivPUnitSumPUnit","isProp":false,"doc":"`Bool` is equivalent the sum of two `PUnit`s. ","depth":3},{"type":"{α : Type u_1} → α ≃ Specialization α","name":"Specialization.toEquiv","isProp":false,"doc":"`toEquiv` is the \"identity\" function to the `Specialization` of a type. ","depth":3}],"count":2594}
{"noDocExamples":[],"kind":"«term⊥»","examples":[{"type":"∀ {α : Type u} {f : Filter α} [self : Filter.NeBot f], f ≠ ⊥","name":"Filter.NeBot.ne'","isProp":true,"doc":"The filter is nontrivial: `f ≠ ⊥` or equivalently, `∅ ∉ f`. ","depth":8},{"type":"∀ {α : Type u_1} [t : TopologicalSpace α] [self : DiscreteTopology α], t = ⊥","name":"DiscreteTopology.eq_bot","isProp":true,"doc":"The `TopologicalSpace` structure on a type with discrete topology is equal to `⊥`. ","depth":8},{"type":"∀ {α : Type u_1}, ⊥ = 0","name":"Multiset.bot_eq_zero","isProp":true,"doc":"This is a `rfl` and `simp` version of `bot_eq_zero`. ","depth":10}],"count":2508}
{"noDocExamples":[],"kind":"Set.term_''_","examples":[{"type":"∀ {α : Type u_1} (s : Set α), (fun x => x) '' s = s","name":"Set.image_id'","isProp":true,"doc":"A variant of `image_id` ","depth":8},{"type":"∀ {α : Type u_1} {s : Set α} {f : α → α}, Set.EqOn f id s → f '' s = s","name":"Set.EqOn.image_eq_self","isProp":true,"doc":"Variant of `EqOn.image_eq`, for one function being the identity. ","depth":10},{"type":"∀ {α : Type u_1} {β : Type u_2} {s : Set α}, Set.Subsingleton s → ∀ (f : α → β), Set.Subsingleton (f '' s)","name":"Set.Subsingleton.image","isProp":true,"doc":"The image of a subsingleton is a subsingleton. ","depth":10}],"count":2298}
{"noDocExamples":[],"kind":"«term_⊓_»","examples":[{"type":"∀ (m n : ℕ+), PNat.factorMultiset (PNat.gcd m n) = PNat.factorMultiset m ⊓ PNat.factorMultiset n","name":"PNat.factorMultiset_gcd","isProp":true,"doc":"The gcd and lcm operations on positive integers correspond\nto the inf and sup operations on multisets. ","depth":9},{"type":"∀ {α : Type u_1} {m0 : MeasurableSpace α} {μ : MeasureTheory.Measure α} {f : Filter α},\n  MeasureTheory.Measure.FiniteAtFilter μ (f ⊓ MeasureTheory.Measure.ae μ) → MeasureTheory.Measure.FiniteAtFilter μ f","name":"MeasureTheory.Measure.FiniteAtFilter.of_inf_ae","isProp":true,"doc":"**Alias** of the forward direction of `MeasureTheory.Measure.FiniteAtFilter.inf_ae_iff`.","depth":11},{"type":"∀ {α : Type u} [self : SemilatticeInf α] (a b : α), a ⊓ b ≤ b","name":"SemilatticeInf.inf_le_right","isProp":true,"doc":"The infimum is a lower bound on the second argument ","depth":11}],"count":2194}
{"noDocExamples":[],"kind":"«term_⊔_»","examples":[{"type":"∀ {L : Type u_1} [inst : TopologicalSpace L] [inst_1 : Sup L] [self : ContinuousSup L], Continuous fun p => p.1 ⊔ p.2","name":"ContinuousSup.continuous_sup","isProp":true,"doc":"The supremum is continuous ","depth":11},{"type":"∀ {α : Type u} [self : SemilatticeSup α] (a b : α), a ≤ a ⊔ b","name":"SemilatticeSup.le_sup_left","isProp":true,"doc":"The supremum is an upper bound on the first argument ","depth":11},{"type":"∀ {α : Type u} [self : SemilatticeSup α] (a b : α), b ≤ a ⊔ b","name":"SemilatticeSup.le_sup_right","isProp":true,"doc":"The supremum is an upper bound on the second argument ","depth":11}],"count":2122}
{"noDocExamples":[],"kind":"«term_∨_»","examples":[{"type":"UnivLE.{u, v} ∨ UnivLE.{v, u}","name":"univLE_total","isProp":true,"doc":"Together with transitivity, this shows UnivLE \"IsTotalPreorder\". ","depth":2},{"type":"∀ (p : Prop), p ∨ ¬p","name":"em","isProp":true,"doc":"**Alias** of `Classical.em`.\n\n---\n\nDiaconescu's theorem: excluded middle from choice, Function extensionality and propositional extensionality. ","depth":3},{"type":"∀ (p : Prop), p ∨ ¬p","name":"Classical.em","isProp":true,"doc":"Diaconescu's theorem: excluded middle from choice, Function extensionality and propositional extensionality. ","depth":3}],"count":2085}
{"noDocExamples":[],"kind":"«term_→ₗ[_]_»","examples":[{"type":"{R : Type u} → [inst : Semiring R] → ℕ → R →ₗ[R] Polynomial R","name":"Polynomial.monomial","isProp":false,"doc":"`monomial s a` is the monomial `a * X^s` ","depth":14},{"type":"∀ {R : Type u} [inst : Semiring R] [self : StrongRankCondition R] {n m : ℕ} (f : (Fin n → R) →ₗ[R] Fin m → R),\n  Function.Injective ⇑f → n ≤ m","name":"StrongRankCondition.le_of_fin_injective","isProp":true,"doc":"Any injective linear map from `Rⁿ` to `Rᵐ` guarantees `n ≤ m`. ","depth":24},{"type":"{S : Type u_5} →\n  [inst : Semiring S] →\n    {M : Type u_6} →\n      [inst_1 : AddCommMonoid M] →\n        [inst_2 : Module S M] → {m : Submodule S M} → {f : M →ₗ[S] M} → LinearMap.IsProj m f → M →ₗ[S] ↥m","name":"LinearMap.IsProj.codRestrict","isProp":false,"doc":"Restriction of the codomain of a projection of onto a subspace `p` to `p` instead of the whole\nspace.\n","depth":26}],"count":2072}
{"noDocExamples":[],"kind":"Set.«term{_|_}»","examples":[{"type":"Set.Infinite {p | Nat.Prime p}","name":"Nat.infinite_setOf_prime","isProp":true,"doc":"A version of `Nat.exists_infinite_primes` using the `Set.Infinite` predicate. ","depth":4},{"type":"Dense {x | Liouville x}","name":"dense_liouville","isProp":true,"doc":"The set of Liouville numbers in dense. ","depth":5},{"type":"¬BddAbove {p | Nat.Prime p}","name":"Nat.not_bddAbove_setOf_prime","isProp":true,"doc":"A version of `Nat.exists_infinite_primes` using the `BddAbove` predicate. ","depth":6}],"count":2032}
{"noDocExamples":[],"kind":"Set.«term_⁻¹'_»","examples":[{"type":"∀ {s : Set ℂ}, Set.Countable s → Set.Countable (Complex.exp ⁻¹' s)","name":"Set.Countable.preimage_cexp","isProp":true,"doc":"**Alias** of the reverse direction of `Complex.countable_preimage_exp`.","depth":7},{"type":"∀ {M : Type u_1} [inst : AddMonoid M] {N : Type u_3} [inst_1 : AddMonoid N] {f : M → N},\n  IsAddMonoidHom f → ∀ {s : Set N}, IsAddSubmonoid s → IsAddSubmonoid (f ⁻¹' s)","name":"IsAddSubmonoid.preimage","isProp":true,"doc":"The preimage of an `AddSubmonoid` under an `AddMonoid` hom is\nan `AddSubmonoid` of the domain.","depth":13},{"type":"∀ {α : Type u} [inst : TopologicalSpace α] (U : Set α),\n  ConnectedComponents.mk ⁻¹' (ConnectedComponents.mk '' U) = ⋃ x ∈ U, connectedComponent x","name":"connectedComponents_preimage_image","isProp":true,"doc":"The preimage of the image of a set under the quotient map to `connectedComponents α`\nis the union of the connected components of the elements in it. ","depth":13}],"count":2001}
{"noDocExamples":[],"kind":"«term_∩_»","examples":[{"type":"∀ {α : Type u} [inst : Preorder α] {s t : Set α}, BddBelow s → BddBelow (s ∩ t)","name":"BddBelow.inter_of_left","isProp":true,"doc":"If `s` is bounded, then so is `s ∩ t` ","depth":11},{"type":"∀ {α : Type u} [inst : Preorder α] {s t : Set α}, BddAbove t → BddAbove (s ∩ t)","name":"BddAbove.inter_of_right","isProp":true,"doc":"If `t` is bounded, then so is `s ∩ t` ","depth":11},{"type":"∀ {α : Type u} [inst : Preorder α] {s t : Set α}, BddAbove s → BddAbove (s ∩ t)","name":"BddAbove.inter_of_left","isProp":true,"doc":"If `s` is bounded, then so is `s ∩ t` ","depth":11}],"count":1984}
{"noDocExamples":[],"kind":"termℂ","examples":[{"type":"∀ {s : ℂ} {N : ℕ} (χ : DirichletCharacter ℂ N) (hs : 1 < s.re),\n  Filter.Tendsto (fun n => Finset.prod (Nat.primesBelow n) fun p => (1 - χ ↑p * ↑p ^ (-s))⁻¹) Filter.atTop\n    (nhds (∑' (n : ℕ), (dirichletSummandHom χ (_ : s ≠ 0)) n))","name":"dirichletLSeries_eulerProduct","isProp":true,"doc":"The Euler product for Dirichlet L-series, valid for `s.re > 1`. ","depth":26},{"type":"∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {a b C : ℝ} {f : ℂ → E} {z : ℂ},\n  DiffContOnCl ℂ f (Complex.re ⁻¹' Set.Ioo a b) →\n    (∃ c < Real.pi / (b - a),\n        ∃ B,\n          f =O[Filter.comap (abs ∘ Complex.im) Filter.atTop ⊓ Filter.principal (Complex.re ⁻¹' Set.Ioo a b)] fun z =>\n            Real.exp (B * Real.exp (c * |z.im|))) →\n      (∀ (z : ℂ), z.re = a → ‖f z‖ ≤ C) → (∀ (z : ℂ), z.re = b → ‖f z‖ ≤ C) → a ≤ z.re → z.re ≤ b → ‖f z‖ ≤ C","name":"PhragmenLindelof.vertical_strip","isProp":true,"doc":"**Phragmen-Lindelöf principle** in a strip `U = {z : ℂ | a < re z < b}`.\nLet `f : ℂ → E` be a function such that\n\n* `f` is differentiable on `U` and is continuous on its closure;\n* `‖f z‖` is bounded from above by `A * exp(B * exp(c * |im z|))` on `U` for some `c < π / (b - a)`;\n* `‖f z‖` is bounded from above by a constant `C` on the boundary of `U`.\n\nThen `‖f z‖` is bounded by the same constant on the closed strip\n`{z : ℂ | a ≤ re z ≤ b}`. Moreover, it suffices to verify the second assumption\nonly for sufficiently large values of `|im z|`.\n","depth":28},{"type":"∀ {E : Type u_1} {V : Type u_2} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {f : V → E}\n  [inst_2 : NormedAddCommGroup V] [inst_3 : MeasurableSpace V] [inst_4 : BorelSpace V] [inst_5 : InnerProductSpace ℝ V]\n  [inst_6 : FiniteDimensional ℝ V],\n  Continuous f →\n    HasCompactSupport f →\n      Filter.Tendsto (fun w => ∫ (v : V), ↑(Real.fourierChar (Multiplicative.ofAdd (-inner v w))) • f v)\n        (Filter.cocompact V) (nhds 0)","name":"tendsto_integral_exp_inner_smul_cocompact_of_continuous_compact_support","isProp":true,"doc":"Riemann-Lebesgue Lemma for continuous and compactly-supported functions: the integral\n`∫ v, exp (-2 * π * ⟪w, v⟫ * I) • f v` tends to 0 wrt `cocompact V`. Note that this is primarily\nof interest as a preparatory step for the more general result\n`tendsto_integral_exp_inner_smul_cocompact` in which `f` can be arbitrary. ","depth":47}],"count":1922}
{"noDocExamples":[],"kind":"Std.ExtendedBinder.«term∃__,_»","examples":[{"type":"∀ (R : Type u_1) [inst : CommRing R] [inst_1 : CharZero R], IsEmpty (Algebra ℚ R) ↔ ∃ p > 0, MixedCharZero R p","name":"isEmpty_algebraRat_iff_mixedCharZero","isProp":true,"doc":"A ring of characteristic zero is not a `ℚ`-algebra iff it has mixed characteristic for some `p`.\n","depth":12},{"type":"∀ {α : Type u_3} [self : Denumerable α] (n : ℕ), ∃ a ∈ Encodable.decode n, Encodable.encode a = n","name":"Denumerable.decode_inv","isProp":true,"doc":"`decode` and `encode` are inverses. ","depth":12},{"type":"∀ {P : Type u_2} [inst : Preorder P] (self : Order.Cofinal P) (x : P), ∃ y ∈ self.carrier, x ≤ y","name":"Order.Cofinal.mem_gt","isProp":true,"doc":"The `Cofinal` contains arbitrarily large elements. ","depth":13}],"count":1889}
{"noDocExamples":[],"kind":"«term{_:_//_}»","examples":[{"type":"∀ {α : Sort u_1}, IsEmpty { _a // False }","name":"Subtype.isEmpty_false","isProp":true,"doc":"subtypes by false are false. ","depth":4},{"type":"{K : Type u_1} →\n  [inst : Field K] →\n    [inst_1 : NumberField K] →\n      ({ w // NumberField.InfinitePlace.IsReal w } → ℝ) × ({ w // NumberField.InfinitePlace.IsComplex w } → ℂ) → ℝ","name":"NumberField.mixedEmbedding.convexBodySumFun","isProp":false,"doc":"The function that sends `x : ({w // IsReal w} → ℝ) × ({w // IsComplex w} → ℂ)` to\n`∑ w, ‖x.1 w‖ + 2 * ∑ w, ‖x.2 w‖`. It defines a norm and it used to define `convexBodySum`. ","depth":12},{"type":"{α : Type u_1} → (l : List α) → List.Nodup l → (∀ (x : α), x ∈ l) → { f // Function.Bijective f }","name":"List.Nodup.getBijectionOfForallMemList","isProp":false,"doc":"If `l` lists all the elements of `α` without duplicates, then `List.get` defines\na bijection `Fin l.length → α`.  See `List.Nodup.getEquivOfForallMemList`\nfor a version giving an equivalence when there is decidable equality. ","depth":12}],"count":1759}
{"noDocExamples":[],"kind":"«term∅»","examples":[{"type":"∀ {X : Type u_1} [inst : TopologicalSpace X], IsSigmaCompact ∅","name":"isSigmaCompact_empty","isProp":true,"doc":"The empty set is σ-compact. ","depth":6},{"type":"∀ {X : Type u_4} [inst : TopologicalSpace X], IsMeagre ∅","name":"meagre_empty","isProp":true,"doc":"The empty set is meagre. ","depth":6},{"type":"∀ {α : Type u_7} (self : MeasurableSpace α), MeasurableSpace.MeasurableSet' self ∅","name":"MeasurableSpace.measurableSet_empty","isProp":true,"doc":"The empty set is a measurable set. Use `MeasurableSet.empty` instead. ","depth":6}],"count":1527}
{"noDocExamples":[],"kind":"«term_∣_»","examples":[{"type":"Function.Injective fun x x_1 => x ∣ x_1","name":"Nat.dvd_left_injective","isProp":true,"doc":"`dvd` is injective in the left argument ","depth":7},{"type":"∀ {m n : ℕ}, Odd n → m ∣ n → m ≠ 2","name":"Odd.ne_two_of_dvd_nat","isProp":true,"doc":"`2` is not a factor of an odd natural number. ","depth":8},{"type":"∀ {a b : ℕ}, a ∣ b → b < a → b = 0","name":"Nat.eq_zero_of_dvd_of_lt","isProp":true,"doc":"If a small natural number is divisible by a larger natural number,\nthe small number is zero. ","depth":8}],"count":1526}
{"noDocExamples":[],"kind":"«term_→*_»","examples":[{"type":"{ι : Type u_1} → {η : Type v} → (R : Type w) → (ι → η) → [inst : MulOneClass R] → (ι → R) →* η → R","name":"Function.ExtendByOne.hom","isProp":false,"doc":"`Function.extend s f 1` as a bundled hom. ","depth":10},{"type":"{α : Type u_8} → [inst : DivisionCommMonoid α] → α × α →* α","name":"divMonoidHom","isProp":false,"doc":"Division as a monoid homomorphism. ","depth":11},{"type":"(G : Type u_1) → [inst : Group G] → [inst_1 : Subgroup.FiniteIndex (Subgroup.center G)] → G →* ↥(Subgroup.center G)","name":"MonoidHom.transferCenterPow","isProp":false,"doc":"The transfer homomorphism `G →* center G`. ","depth":16}],"count":1514}
{"noDocExamples":[],"kind":"«term_∪_»","examples":[{"type":"∀ {α : Type u_1} (s : Set α) (a : α), 𝒫 insert a s = 𝒫 s ∪ insert a '' 𝒫 s","name":"Set.powerset_insert","isProp":true,"doc":"The powerset of `{a} ∪ s` is `𝒫 s` together with `{a} ∪ t` for each `t ∈ 𝒫 s`. ","depth":11},{"type":"∀ {α : Type u} (S T : Set α), Cardinal.mk ↑(S ∪ T) ≤ Cardinal.mk ↑S + Cardinal.mk ↑T","name":"Cardinal.mk_union_le","isProp":true,"doc":"The cardinality of a union is at most the sum of the cardinalities\nof the two sets. ","depth":12},{"type":"∀ {α : Type u_1} {A B : Set (Finset α)} {r : ℕ}, Set.Sized r A ∧ Set.Sized r B → Set.Sized r (A ∪ B)","name":"Set.sized.union","isProp":true,"doc":"**Alias** of the reverse direction of `Set.sized_union`.","depth":12}],"count":1415}
{"noDocExamples":[],"kind":"«term_→+_»","examples":[{"type":"∀ {α : Type u_1} {β : Type u_2} [inst : AddGroup α] [inst_1 : SubtractionMonoid β] (f : α →+ β) (g h : α),\n  f (g - h) = f g - f h","name":"AddMonoidHom.map_sub","isProp":true,"doc":"Additive group homomorphisms preserve subtraction.","depth":26},{"type":"∀ {ι : Type u} {β : ι → Type v} [dec : DecidableEq ι] [inst : (i : ι) → AddZeroClass (β i)] {γ : Type w}\n  [inst_1 : AddZeroClass γ] ⦃f g : (Π₀ (i : ι), β i) →+ γ⦄,\n  (∀ (i : ι) (y : β i), f (DFinsupp.single i y) = g (DFinsupp.single i y)) → f = g","name":"DFinsupp.addHom_ext","isProp":true,"doc":"If two additive homomorphisms from `Π₀ i, β i` are equal on each `single a b`, then\nthey are equal. ","depth":34},{"type":"{α : Type u_8} → [inst : SubtractionCommMonoid α] → α × α →+ α","name":"subAddMonoidHom","isProp":false,"doc":"Subtraction as an additive monoid homomorphism.","depth":11}],"count":1375}
{"noDocExamples":[],"kind":"«term_→₀_»","examples":[{"type":"∀ {α : Type u_1} {M : Type u_8} {N : Type u_10} [inst : AddZeroClass M] [inst_1 : CommMonoid N] {f g : α →₀ M}\n  {h : α → M → N},\n  (∀ (a : α), h a 0 = 1) →\n    (∀ (a : α) (b₁ b₂ : M), h a (b₁ + b₂) = h a b₁ * h a b₂) →\n      Finsupp.prod (f + g) h = Finsupp.prod f h * Finsupp.prod g h","name":"Finsupp.prod_add_index'","isProp":true,"doc":"Taking the product under `h` is an additive-to-multiplicative homomorphism of finsupps,\nif `h` is an additive-to-multiplicative homomorphism.\nThis is a more specialized version of `Finsupp.prod_add_index` with simpler hypotheses. ","depth":23},{"type":"ℕ → ℕ →₀ ℕ","name":"Nat.factorization","isProp":false,"doc":"`n.factorization` is the finitely supported function `ℕ →₀ ℕ`\nmapping each prime factor of `n` to its multiplicity in `n`. ","depth":4},{"type":"{ι : Type u_1} → {η : ι → Type u_4} → {N : Type u_5} → [inst : Zero N] → ((i : ι) × η i →₀ N) ≃ Π₀ (i : ι), η i →₀ N","name":"sigmaFinsuppEquivDFinsupp","isProp":false,"doc":"`Finsupp.split` is an equivalence between `(Σ i, η i) →₀ N` and `Π₀ i, (η i →₀ N)`. ","depth":12}],"count":1292}
{"noDocExamples":[],"kind":"«term_∉_»","examples":[{"type":"Class.univ ∉ Class.univ","name":"Class.univ_not_mem_univ","isProp":true,"doc":"**There is no universal set.**\nThis is stated as `univ ∉ univ`, meaning that `univ` (the class of all sets) is proper (does not\nbelong to the class of all sets). ","depth":6},{"type":"∀ {α : Type u_1} {r : Setoid α}, ∅ ∉ Setoid.classes r","name":"Setoid.empty_not_mem_classes","isProp":true,"doc":"The empty set is not an equivalence class. ","depth":9},{"type":"∀ {A : Set ℕ} [inst : DecidablePred fun x => x ∈ A], 1 ∉ A → schnirelmannDensity A = 0","name":"schnirelmannDensity_eq_zero_of_one_not_mem","isProp":true,"doc":"The Schnirelmann density of a set not containing `1` is `0`. ","depth":9}],"count":1196}
{"noDocExamples":[],"kind":"«term_→L[_]_»","examples":[{"type":"∀ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] {f : E → ℝ} {a : E} {f' : E →L[ℝ] ℝ},\n  IsLocalMin f a → HasFDerivAt f f' a → f' = 0","name":"IsLocalMin.hasFDerivAt_eq_zero","isProp":true,"doc":"**Fermat's Theorem**: the derivative of a function at a local minimum equals zero. ","depth":25},{"type":"∀ {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] {F : Type u_3} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F] {f : E → F}\n  {f' : E →L[𝕜] F} {x : E} {s : Set E}, nhdsWithin x (s \\ {x}) = ⊥ → HasFDerivWithinAt f f' s x","name":"HasFDerivWithinAt.of_nhdsWithin_eq_bot","isProp":true,"doc":"If `x` is isolated in `s`, then `f` has any derivative at `x` within `s`,\nas this statement is empty. ","depth":27},{"type":"∀ {ι : Type u} {E : Type v} {F : Type w} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E]\n  [inst_2 : NormedAddCommGroup F] [inst_3 : NormedSpace ℝ F] {I J : BoxIntegral.Box ι} [inst_4 : Fintype ι]\n  {l : BoxIntegral.IntegrationParams} {f : (ι → ℝ) → E} {vol : BoxIntegral.BoxAdditiveMap ι (E →L[ℝ] F) ⊤}\n  [inst_5 : CompleteSpace F], BoxIntegral.Integrable I l f vol → J ≤ I → BoxIntegral.Integrable J l f vol","name":"BoxIntegral.Integrable.to_subbox","isProp":true,"doc":"If `f` is integrable on a box `I`, then it is integrable on any subbox of `I`. ","depth":29}],"count":1150}
{"noDocExamples":[],"kind":"Set.«term⋃_,_»","examples":[{"type":"∀ {α : Type u_7} (self : MeasurableSpace α) (f : ℕ → Set α),\n  (∀ (i : ℕ), MeasurableSpace.MeasurableSet' self (f i)) → MeasurableSpace.MeasurableSet' self (⋃ i, f i)","name":"MeasurableSpace.measurableSet_iUnion","isProp":true,"doc":"The union of a sequence of measurable sets is a measurable set. Use a more general\n`MeasurableSet.iUnion` instead. ","depth":8},{"type":"∀ {X : Type u_4} [inst : TopologicalSpace X] {s : ℕ → Set X}, (∀ (n : ℕ), IsMeagre (s n)) → IsMeagre (⋃ n, s n)","name":"meagre_iUnion","isProp":true,"doc":"A countable union of meagre sets is meagre. ","depth":8},{"type":"∀ {X : Type u_4} [inst : TopologicalSpace X] (self : CompactExhaustion X),\n  ⋃ n, CompactExhaustion.toFun self n = Set.univ","name":"CompactExhaustion.iUnion_eq'","isProp":true,"doc":"The union of all sets in a compact exhaustion equals the entire space. ","depth":11}],"count":1143}
{"noDocExamples":[],"kind":"«term_ᶜ»","examples":[{"type":"∀ {α : Type u_1} [inst : Preorder α] {s : Set α}, DirSupClosed sᶜ → DirSupInacc s","name":"DirSupClosed.of_compl","isProp":true,"doc":"**Alias** of the forward direction of `dirSupClosed_compl`.","depth":10},{"type":"∀ {α : Type u_2} [inst : Bornology α] {s : Set α}, Bornology.IsBounded sᶜ → Bornology.IsCobounded s","name":"Bornology.IsBounded.of_compl","isProp":true,"doc":"**Alias** of the forward direction of `Bornology.isBounded_compl_iff`.","depth":10},{"type":"∀ {α : Type u} [inst : Infinite α] {s : Set α}, Set.Finite s → sᶜ ∈ Filter.hyperfilter α","name":"Set.Finite.compl_mem_hyperfilter","isProp":true,"doc":"**Alias** of `Filter.compl_mem_hyperfilter_of_finite`.","depth":11}],"count":1138}
{"noDocExamples":[],"kind":"«term[_]»","examples":[{"type":"∀ {α : Type u_1}, List.Sublist [] []","name":"List.Sublist.slnil","isProp":true,"doc":"the base case: `[]` is a sublist of `[]` ","depth":4},{"type":"∀ {α : Type u_1}, List.Perm [] []","name":"List.Perm.nil","isProp":true,"doc":"`[] ~ []` ","depth":4},{"type":"∀ {α : Type u_1} {R : α → α → Prop}, List.Pairwise R []","name":"List.Pairwise.nil","isProp":true,"doc":"All elements of the empty list are vacuously pairwise related. ","depth":5}],"count":1132}
{"noDocExamples":[],"kind":"«term_ᵐᵒᵖ»","examples":[{"type":"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : Group α] [inst_2 : TopologicalGroup α], TopologicalGroup αᵐᵒᵖ","name":"instTopologicalGroupMulOppositeInstTopologicalSpaceMulOppositeGroup","isProp":true,"doc":"If multiplication is continuous in `α`, then it also is in `αᵐᵒᵖ`. ","depth":8},{"type":"∀ (R : Type u_2) [inst : MonoidWithZero R], nonZeroSMulDivisors Rᵐᵒᵖ R = Submonoid.op (nonZeroDivisors R)","name":"nonZeroSMulDivisors_mulOpposite_eq_op_nonZeroDivisors","isProp":true,"doc":"The non-zero `•`-divisors with `•` as right multiplication correspond with the non-zero\ndivisors. Note that the `MulOpposite` is needed because we defined `nonZeroDivisors` with\nmultiplication on the right. ","depth":10},{"type":"{G : Type v} → [inst : Group G] → [inst_1 : PseudoEMetricSpace G] → [inst : IsometricSMul Gᵐᵒᵖ G] → G → G ≃ᵢ G","name":"IsometryEquiv.mulRight","isProp":false,"doc":"Multiplication `y ↦ y * x` as an `IsometryEquiv`. ","depth":11}],"count":1100}
{"noDocExamples":[],"kind":"«termC(_,_)»","examples":[{"type":"{ι : Type u_4} →\n  {X : ι → Type u_2} →\n    {Y : ι → Type u_3} →\n      [inst : (i : ι) → TopologicalSpace (X i)] →\n        [inst_1 : (i : ι) → TopologicalSpace (Y i)] →\n          {f₀ f₁ : (i : ι) → C(X i, Y i)} →\n            ((i : ι) → ContinuousMap.Homotopy (f₀ i) (f₁ i)) →\n              ContinuousMap.Homotopy (ContinuousMap.piMap f₀) (ContinuousMap.piMap f₁)","name":"ContinuousMap.Homotopy.piMap","isProp":false,"doc":"Given a family of homotopies `F i` between `f₀ i : C(X i, Y i)` and `f₁ i : C(X i, Y i)`,\nreturns a homotopy between `ContinuousMap.piMap f₀` and `ContinuousMap.piMap f₁`. ","depth":17},{"type":"(R : Type u_2) →\n  [inst : CommSemiring R] →\n    (A : Type u_3) →\n      [inst_1 : TopologicalSpace A] →\n        [inst_2 : Semiring A] →\n          [inst_3 : Algebra R A] →\n            [inst_4 : TopologicalSemiring A] →\n              {α : Type u_5} →\n                {β : Type u_6} →\n                  [inst_5 : TopologicalSpace α] → [inst_6 : TopologicalSpace β] → C(α, β) → C(β, A) →ₐ[R] C(α, A)","name":"ContinuousMap.compRightAlgHom","isProp":false,"doc":"Precomposition of functions into a normed ring by a continuous map is an algebra homomorphism.\n","depth":23},{"type":"∀ {X : Type u_1} {Y : Type u_2} {Z : Type u_3} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y]\n  [inst_2 : TopologicalSpace Z] {f : C(X, Y)} (hf : QuotientMap ⇑f) (g : C(X, Z)) (h : Function.FactorsThrough ⇑g ⇑f),\n  ContinuousMap.comp (QuotientMap.lift hf g h) f = g","name":"QuotientMap.lift_comp","isProp":true,"doc":"The obvious triangle induced by `QuotientMap.lift` commutes:\n```\n     g\n  X --→ Z\n  |   ↗\nf |  / hf.lift g h\n  v /\n  Y\n```\n","depth":24}],"count":1088}
{"noDocExamples":[],"kind":"termIfThenElse","examples":[{"type":"∀ {P : Prop} {α : Sort u_1} {a b : α} [inst : Decidable P], (if x : P then a else b) = if P then a else b","name":"dite_eq_ite","isProp":true,"doc":"A `dite` whose results do not actually depend on the condition may be reduced to an `ite`. ","depth":12},{"type":"∀ {α : Sort u_1} (P : Prop) {x : Decidable P} (x_1 y : α), (if ¬P then x_1 else y) = if P then y else x_1","name":"ite_not","isProp":true,"doc":"Negation of the condition `P : Prop` in a `ite` is the same as swapping the branches. ","depth":12},{"type":"∀ {α : Sort u} {f : α → α},\n  Function.Involutive f → ∀ (P : Prop) [inst : Decidable P] (x : α), f (if P then x else f x) = if ¬P then x else f x","name":"Function.Involutive.ite_not","isProp":true,"doc":"Involuting an `ite` of an involuted value `x : α` negates the `Prop` condition in the `ite`. ","depth":14}],"count":1056}
{"noDocExamples":[],"kind":"«term_ˣ»","examples":[{"type":"∀ {M₀ : Type u_2} [inst : MonoidWithZero M₀] [inst_1 : Nontrivial M₀] (u : M₀ˣ), ↑u ≠ 0","name":"Units.ne_zero","isProp":true,"doc":"An element of the unit group of a nonzero monoid with zero represented as an element\nof the monoid is nonzero. ","depth":10},{"type":"∀ {R : Type u_1} {ι : Type u_2} {A : Type u_3} {B : Type u_4} [inst : CommSemiring ι] [inst_1 : Module ι (Additive ℤˣ)]\n  [inst_2 : DecidableEq ι] [inst_3 : CommRing R] [inst_4 : Ring A] [inst_5 : Ring B] [inst_6 : Algebra R A]\n  [inst_7 : Algebra R B] (𝒜 : ι → Submodule R A) (ℬ : ι → Submodule R B) [inst_8 : GradedAlgebra 𝒜]\n  [inst_9 : GradedAlgebra ℬ] {j₁ : ι} (a₁ : A) (b₁ : ↥(ℬ j₁)) (a₂ : ↥(𝒜 0)) (b₂ : B),\n  a₁ ᵍ⊗ₜ[R] ↑b₁ * ↑a₂ ᵍ⊗ₜ[R] b₂ = (a₁ * ↑a₂) ᵍ⊗ₜ[R] (↑b₁ * b₂)","name":"GradedTensorProduct.tmul_coe_mul_zero_coe_tmul","isProp":true,"doc":"A special case for when `a₂` has grade 0. ","depth":44},{"type":"{R : Type u_1} → [inst : NormedRing R] → [inst_1 : CompleteSpace R] → (x : Rˣ) → (t : R) → ‖t‖ < ‖↑x⁻¹‖⁻¹ → Rˣ","name":"Units.add","isProp":false,"doc":"In a complete normed ring, a perturbation of a unit `x` by an element `t` of distance less than\n`‖x⁻¹‖⁻¹` from `x` is a unit.  Here we construct its `Units` structure. ","depth":19}],"count":1026}
{"noDocExamples":[],"kind":"«term_+ᵥ_»","examples":[{"type":"∀ {M : Type u_1} (c : M) (X : Type u_2) [inst : VAdd M X] [inst_1 : TopologicalSpace X] [h : ProperConstVAdd M X],\n  IsProperMap fun x => c +ᵥ x","name":"isProperMap_vadd","isProp":true,"doc":"`(c +ᵥ ·)` is a proper map.","depth":14},{"type":"∀ {M : Type u_1} {X : Type u_2} [inst : VAdd M X] [inst_1 : TopologicalSpace M] [inst_2 : TopologicalSpace X]\n  [self : ContinuousVAdd M X], Continuous fun p => p.1 +ᵥ p.2","name":"ContinuousVAdd.continuous_vadd","isProp":true,"doc":"The additive action `(+ᵥ)` is continuous. ","depth":14},{"type":"∀ {M : Type u_1} {X : Type u_2} [inst : VAdd M X] [inst_1 : TopologicalSpace X] [self : ProperConstVAdd M X] (c : M),\n  IsProperMap fun x => c +ᵥ x","name":"ProperConstVAdd.isProperMap_vadd","isProp":true,"doc":"`(c +ᵥ ·)` is a proper map. ","depth":14}],"count":1010}
{"noDocExamples":[],"kind":"«term_ᵒᵈ»","examples":[{"type":"{α : Type u_1} → [inst : Preorder α] → [inst_1 : LocallyFiniteOrder α] → LocallyFiniteOrder αᵒᵈ","name":"OrderDual.locallyFiniteOrder","isProp":false,"doc":"Note we define `Icc (toDual a) (toDual b)` as `Icc α _ _ b a` (which has type `Finset α` not\n`Finset αᵒᵈ`!) instead of `(Icc b a).map toDual.toEmbedding` as this means the\nfollowing is defeq:\n```\nlemma this : (Icc (toDual (toDual a)) (toDual (toDual b)) : _) = (Icc a b : _) := rfl\n```\n","depth":6},{"type":"∀ {α : Type u_2} [inst : SemilatticeInf α] {a : αᵒᵈ}, SupIrred a → InfIrred (OrderDual.ofDual a)","name":"SupIrred.ofDual","isProp":true,"doc":"**Alias** of the reverse direction of `infIrred_ofDual`.","depth":14},{"type":"{α : Type u_2} → {β : Type u_3} → [inst : Preorder α] → [inst_1 : Preorder β] → α ↪o β → αᵒᵈ ↪o βᵒᵈ","name":"OrderEmbedding.dual","isProp":false,"doc":"An order embedding is also an order embedding between dual orders. ","depth":10}],"count":976}
{"noDocExamples":[],"kind":"«term_\\_»","examples":[{"type":"∀ (N : ℕ), (Nat.smoothNumbers N)ᶜ \\ {0} ⊆ {n | N ≤ n}","name":"Nat.smoothNumbers_compl","isProp":true,"doc":"The non-zero non-`N`-smooth numbers are `≥ N`. ","depth":10},{"type":"∀ {A : Set ℕ} [inst : DecidablePred fun x => x ∈ A] [inst_1 : DecidablePred fun x => x ∈ A \\ {0}],\n  schnirelmannDensity (A \\ {0}) = schnirelmannDensity A","name":"schnirelmannDensity_diff_singleton_zero","isProp":true,"doc":"The Schnirelmann density is unaffected by removing `0`. ","depth":12},{"type":"∀ {X : Type u} [inst : TopologicalSpace X] {s t : Set X}, IsCompact s → IsOpen t → IsCompact (s \\ t)","name":"IsCompact.diff","isProp":true,"doc":"The set difference of a compact set and an open set is a compact set. ","depth":12}],"count":971}
{"noDocExamples":[],"kind":"«term_⧸_»","examples":[{"type":"∀ {R : Type u_1} [inst : CommRing R] [inst_1 : Fact (∀ (I : Ideal R), I ≠ ⊤ → CharZero (R ⧸ I))] (n : ℕ+), ↑↑n = ↑↑n","name":"EqualCharZero.pnatCast_eq_natCast","isProp":true,"doc":"Internal: Not intended to be used outside this local construction. ","depth":18},{"type":"∀ {G : Type u_1} [inst : Group G] [inst_1 : MeasurableSpace G] [inst_2 : TopologicalSpace G]\n  [inst_3 : TopologicalGroup G] [inst_4 : BorelSpace G] {Γ : Subgroup G} [inst_5 : MeasurableSpace (G ⧸ Γ)]\n  [inst_6 : BorelSpace (G ⧸ Γ)], MeasurableSMul G (G ⧸ Γ)","name":"QuotientGroup.measurableSMul","isProp":true,"doc":"Measurability of the action of the topological group `G` on the left-coset space `G/Γ`. ","depth":20},{"type":"{α : Type u_1} →\n  [inst : Group α] →\n    {s t : Subgroup α} → (H : Subgroup α) → s ≤ t → ↥H ⧸ Subgroup.subgroupOf s H → ↥H ⧸ Subgroup.subgroupOf t H","name":"Subgroup.quotientSubgroupOfMapOfLE","isProp":false,"doc":"If `s ≤ t`, then there is a map `H ⧸ s.subgroupOf H → H ⧸ t.subgroupOf H`. ","depth":22}],"count":967}
{"noDocExamples":[],"kind":"«term_::_»","examples":[{"type":"∀ {α : Type u} {a : α} (as : List α), List.Mem a (a :: as)","name":"List.Mem.head","isProp":true,"doc":"The head of a list is a member: `a ∈ a :: as`. ","depth":7},{"type":"∀ {α : Type u} [inst : LT α] (b : α) (bs : List α), List.lt [] (b :: bs)","name":"List.lt.nil","isProp":true,"doc":"`[]` is the smallest element in the order. ","depth":8},{"type":"∀ {α : Type u_1} {l₁ l₂ : List α} (a : α), List.Sublist l₁ l₂ → List.Sublist l₁ (a :: l₂)","name":"List.Sublist.cons","isProp":true,"doc":"If `l₁` is a subsequence of `l₂`, then it is also a subsequence of `a :: l₂`. ","depth":9}],"count":932}
{"noDocExamples":[],"kind":"«term⨆_,_»","examples":[{"type":"∀ {ι : Sort u_1} {f : ι → ℝ}, (∀ (i : ι), 0 ≤ f i) → 0 ≤ ⨆ i, f i","name":"Real.iSup_nonneg","isProp":true,"doc":"As `0` is the default value for `Real.sSup` of the empty set or sets which are not bounded above, it\nsuffices to show that `f i` is nonnegative to show that `0 ≤ ⨆ i, f i`.\n","depth":9},{"type":"∀ {α : Type u_1} [inst : UniformSpace α] [inst_1 : CompactSpace α], uniformity α = ⨆ x, nhds (x, x)","name":"compactSpace_uniformity","isProp":true,"doc":"On a compact uniform space, the topology determines the uniform structure, entourages are\nexactly the neighborhoods of the diagonal. ","depth":13},{"type":"∀ {α : Type ua} [inst : UniformSpace α], ⨆ x, nhds (x, x) ≤ uniformity α","name":"iSup_nhds_le_uniformity","isProp":true,"doc":"Entourages are neighborhoods of the diagonal. ","depth":13}],"count":917}
{"noDocExamples":[],"kind":"«term⨅_,_»","examples":[{"type":"∀ {ι : Sort u_1}, ⨅ i, 0 = 0","name":"Nat.iInf_const_zero","isProp":true,"doc":"This combines `Nat.iInf_of_empty` with `ciInf_const`. ","depth":8},{"type":"∀ {α : Type u_1} {γ : Type u_3} {ι : Type u_4} {u : ι → UniformSpace γ},\n  UniformFun.uniformSpace α γ = ⨅ i, UniformFun.uniformSpace α γ","name":"UniformFun.iInf_eq","isProp":true,"doc":"If `u` is a family of uniform structures on `γ`, then\n`𝒰(α, γ, (⨅ i, u i)) = ⨅ i, 𝒰(α, γ, u i)`. ","depth":12},{"type":"∀ {α : Type u_1} {γ : Type u_3} {ι : Type u_4} {𝔖 : Set (Set α)} {u : ι → UniformSpace γ},\n  UniformOnFun.uniformSpace α γ 𝔖 = ⨅ i, UniformOnFun.uniformSpace α γ 𝔖","name":"UniformOnFun.iInf_eq","isProp":true,"doc":"If `u` is a family of uniform structures on `γ`, then\n`𝒱(α, γ, 𝔖, (⨅ i, u i)) = ⨅ i, 𝒱(α, γ, 𝔖, u i)`. ","depth":14}],"count":900}
{"noDocExamples":[],"kind":"«term_⊕_»","examples":[{"type":"Bool ≃ PUnit.{u + 1} ⊕ PUnit.{v + 1}","name":"Equiv.boolEquivPUnitSumPUnit","isProp":false,"doc":"`Bool` is equivalent the sum of two `PUnit`s. ","depth":3},{"type":"WType.Natα ≃ PUnit.{u + 1} ⊕ PUnit.{u_1 + 1}","name":"WType.NatαEquivPUnitSumPUnit","isProp":false,"doc":"`WType.Natα` is equivalent to `PUnit ⊕ PUnit`.\nThis is useful when considering the associated polynomial endofunctor.\n","depth":3},{"type":"{α : Type u_1} → {β : Type u_2} → α ⊕ β → Option β","name":"Sum.getRight?","isProp":false,"doc":"Check if a sum is `inr` and if so, retrieve its contents. ","depth":5}],"count":895}
{"noDocExamples":[],"kind":"«term_→ₐ[_]_»","examples":[{"type":"(R : Type u_2) →\n  [inst : CommSemiring R] →\n    (A : Type u_3) →\n      [inst_1 : TopologicalSpace A] →\n        [inst_2 : Semiring A] →\n          [inst_3 : Algebra R A] →\n            [inst_4 : TopologicalSemiring A] →\n              {α : Type u_5} →\n                {β : Type u_6} →\n                  [inst_5 : TopologicalSpace α] → [inst_6 : TopologicalSpace β] → C(α, β) → C(β, A) →ₐ[R] C(α, A)","name":"ContinuousMap.compRightAlgHom","isProp":false,"doc":"Precomposition of functions into a normed ring by a continuous map is an algebra homomorphism.\n","depth":23},{"type":"{R : Type u1} →\n  [inst : CommRing R] →\n    {M : Type u2} →\n      [inst_1 : AddCommGroup M] →\n        [inst_2 : Module R M] →\n          [inst_3 : Module Rᵐᵒᵖ M] → [inst_4 : IsCentralScalar R M] → ExteriorAlgebra R M →ₐ[R] TrivSqZeroExt R M","name":"ExteriorAlgebra.toTrivSqZeroExt","isProp":false,"doc":"The canonical map from `ExteriorAlgebra R M` into `TrivSqZeroExt R M` that sends\n`ExteriorAlgebra.ι` to `TrivSqZeroExt.inr`. ","depth":27},{"type":"∀ {R : Type uR} {S : Type uS} {A : Type uA} {B : Type uB} {C : Type uC} [inst : CommSemiring R] [inst_1 : Semiring A]\n  [inst_2 : Algebra R A] [inst_3 : Semiring B] [inst_4 : Algebra R B] [inst_5 : Semiring C] [inst_6 : Algebra R C]\n  [inst_7 : CommSemiring S] [inst_8 : Algebra S A] [inst_9 : Algebra R S] [inst_10 : Algebra S C]\n  [inst_11 : IsScalarTower R S A] [inst_12 : IsScalarTower R S C] ⦃f g : TensorProduct R A B →ₐ[S] C⦄,\n  AlgHom.comp f Algebra.TensorProduct.includeLeft = AlgHom.comp g Algebra.TensorProduct.includeLeft →\n    AlgHom.comp (AlgHom.restrictScalars R f) Algebra.TensorProduct.includeRight =\n        AlgHom.comp (AlgHom.restrictScalars R g) Algebra.TensorProduct.includeRight →\n      f = g","name":"Algebra.TensorProduct.ext","isProp":true,"doc":"A version of `TensorProduct.ext` for `AlgHom`.\n\nUsing this as the `@[ext]` lemma instead of `Algebra.TensorProduct.ext'` allows `ext` to apply\nlemmas specific to `A →ₐ[S] _` and `B →ₐ[R] _`; notably this allows recursion into nested tensor\nproducts of algebras.\n\nSee note [partially-applied ext lemmas]. ","depth":48}],"count":895}
{"noDocExamples":[],"kind":"Rat.termℚ","examples":[{"type":"{α : Type u_1} → [inst : AddCommMonoid α] → [inst_1 : Module ℚ α] → Module NNRat α","name":"NNRat.instModuleNNRatToSemiringToDivisionSemiringToSemifieldToLinearOrderedSemifieldInstNNRatCanonicallyLinearOrderedSemifield","isProp":false,"doc":"A `Module` over `ℚ` restricts to a `Module` over `ℚ≥0`. ","depth":10},{"type":"∀ {p : ℕ+} {K : Type u} [inst : Field K] [inst_1 : CharZero K] {ζ : K} [hp : Fact (Nat.Prime ↑p)]\n  [h : IsCyclotomicExtension {p} ℚ K] (hζ : IsPrimitiveRoot ζ ↑p), Prime (IsPrimitiveRoot.toInteger hζ - 1)","name":"IsPrimitiveRoot.zeta_sub_one_prime'","isProp":true,"doc":"`ζ - 1` is prime if `ζ` is a primitive `p`-th root of unity. ","depth":30},{"type":"↥(NumberField.ringOfIntegers ℚ) ≃+* ℤ","name":"Rat.ringOfIntegersEquiv","isProp":false,"doc":"The ring of integers of `ℚ` as a number field is just `ℤ`. ","depth":24}],"count":883}
{"noDocExamples":[],"kind":"Filter.«term_=ᶠ[_]_»","examples":[{"type":"∀ {α : Type u_1} {m : MeasurableSpace α} {μ : MeasureTheory.Measure α} {f g : MeasureTheory.SimpleFunc α ENNReal},\n  ↑f =ᶠ[MeasureTheory.Measure.ae μ] ↑g → MeasureTheory.SimpleFunc.lintegral f μ = MeasureTheory.SimpleFunc.lintegral g μ","name":"MeasureTheory.SimpleFunc.lintegral_congr","isProp":true,"doc":"If two simple functions are equal a.e., then their `lintegral`s are equal. ","depth":12},{"type":"∀ {α : Type u_1} {β : Type u_2} {l : Filter α} {f g : α → β}, f =ᶠ[l] g → ↑f = ↑g","name":"Filter.EventuallyEq.germ_eq","isProp":true,"doc":"**Alias** of the reverse direction of `Filter.Germ.coe_eq`.","depth":12},{"type":"∀ {α : Type u} {β : Type v} {m₁ m₂ : α → β} {f : Filter α}, m₁ =ᶠ[f] m₂ → Filter.map m₁ f = Filter.map m₂ f","name":"Filter.map_congr","isProp":true,"doc":"If functions `m₁` and `m₂` are eventually equal at a filter `f`, then\nthey map this filter to the same filter. ","depth":12}],"count":882}
{"noDocExamples":[],"kind":"«term_×ˢ_»","examples":[{"type":"∀ {α : Type u_1} {f : Filter α} {p : α × α → Prop}, (∀ᶠ (i : α × α) in f ×ˢ f, p i) → ∀ᶠ (i : α) in f, p (i, i)","name":"Filter.Eventually.diag_of_prod","isProp":true,"doc":"A fact that is eventually true about all pairs `l ×ˢ l` is eventually true about\nall diagonal pairs `(i, i)` ","depth":12},{"type":"∀ {α : Type u_1} {Ixx : α → α → Set α} {l₁ : Filter α} {l₂ : outParam (Filter α)}\n  [self : Filter.TendstoIxxClass Ixx l₁ l₂], Filter.Tendsto (fun p => Ixx p.1 p.2) (l₁ ×ˢ l₁) (Filter.smallSets l₂)","name":"Filter.TendstoIxxClass.tendsto_Ixx","isProp":true,"doc":"`Function.uncurry Ixx` tends to `l₂.smallSets` along `l₁ ×ˢ l₁`. In other words, for any\n`s ∈ l₂` there exists `t ∈ l₁` such that `Ixx x y ⊆ s` whenever `x ∈ t` and `y ∈ t`.\n\nUse lemmas like `Filter.Tendsto.Icc` instead. ","depth":14},{"type":"∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] {s : Set α} {t : Set β},\n  IsOpen (s ×ˢ t) ↔ IsOpen s ∧ IsOpen t ∨ s = ∅ ∨ t = ∅","name":"isOpen_prod_iff'","isProp":true,"doc":"A product set is open in a product space if and only if each factor is open, or one of them is\nempty ","depth":16}],"count":865}
{"noDocExamples":[],"kind":"Filter.«term∀ᶠ_In_,_»","examples":[{"type":"∀ᶠ (x : ℝ) in residual ℝ, Liouville x","name":"eventually_residual_liouville","isProp":true,"doc":"The set of Liouville numbers is a residual set. ","depth":5},{"type":"∀ {α : Type u} {f : Ultrafilter α} {p : α → Prop}, (∃ᶠ (x : α) in ↑f, p x) → ∀ᶠ (x : α) in ↑f, p x","name":"Filter.Frequently.eventually","isProp":true,"doc":"**Alias** of the forward direction of `Ultrafilter.frequently_iff_eventually`.","depth":8},{"type":"∀ {α : Type u} [inst : TopologicalSpace α] {p : α → Prop} {a : α}, (∀ᶠ (y : α) in nhds a, p y) → p a","name":"Filter.Eventually.self_of_nhds","isProp":true,"doc":"If a predicate is true in a neighborhood of `a`, then it is true for `a`. ","depth":9}],"count":788}
{"noDocExamples":[],"kind":"«termℕ∞»","examples":[{"type":"∀ {𝕜 : Type u} [inst : NontriviallyNormedField 𝕜] {E : Type uE} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] {F : Type uF} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F] {f : E → F}\n  {n : ℕ∞}, ContDiff 𝕜 n f ↔ HasFTaylorSeriesUpTo n f (ftaylorSeries 𝕜 f)","name":"contDiff_iff_ftaylorSeries","isProp":true,"doc":"When a function is `C^n` in a set `s` of unique differentiability, it admits\n`ftaylorSeriesWithin 𝕜 f s` as a Taylor series up to order `n` in `s`. ","depth":22},{"type":"ℕ∞ →*₀ ℕ","name":"ENat.toNat","isProp":false,"doc":"Conversion of `ℕ∞` to `ℕ` sending `∞` to `0`. ","depth":8},{"type":"∀ {𝕂 : Type u_1} [inst : IsROrC 𝕂] {E' : Type u_2} [inst_1 : NormedAddCommGroup E'] [inst_2 : NormedSpace 𝕂 E']\n  {F' : Type u_3} [inst_3 : NormedAddCommGroup F'] [inst_4 : NormedSpace 𝕂 F'] {f : E' → F'} {n : ℕ∞},\n  HasCompactSupport f → ContDiff 𝕂 n f → 1 ≤ n → ∃ C, LipschitzWith C f","name":"ContDiff.lipschitzWith_of_hasCompactSupport","isProp":true,"doc":"A `C^1` function with compact support is Lipschitz. ","depth":24}],"count":765}
{"noDocExamples":[],"kind":"«term|___|»","examples":[{"type":"∀ (c : ℂ) (R : ℝ), Set.range (circleMap c R) = Metric.sphere c |R|","name":"range_circleMap","isProp":true,"doc":"The range of `circleMap c R` is the circle with center `c` and radius `|R|`. ","depth":11},{"type":"∀ (x : ℝ), 0 < x → x ≤ 1 → |Real.log x * x| < 1","name":"Real.abs_log_mul_self_lt","isProp":true,"doc":"Bound for `|log x * x|` in the interval `(0, 1]`. ","depth":12},{"type":"∀ {α : Type u_1} {l : Filter α} {f : α → ℝ},\n  ((fun x => Real.exp (f x)) =Θ[l] fun x => 1) ↔ Filter.IsBoundedUnder (fun x x_1 => x ≤ x_1) l fun x => |f x|","name":"Real.isTheta_exp_comp_one","isProp":true,"doc":"`Real.exp (f x)` is bounded away from zero and infinity along a filter `l` if and only if\n`|f x|` is bounded from above along this filter. ","depth":13}],"count":711}
{"noDocExamples":[],"kind":"«term_×__1»","examples":[{"type":"{ι : Type u_1} → {η : ι → Type u_4} → {N : Type u_5} → [inst : Zero N] → ((i : ι) × η i →₀ N) ≃ Π₀ (i : ι), η i →₀ N","name":"sigmaFinsuppEquivDFinsupp","isProp":false,"doc":"`Finsupp.split` is an equivalence between `(Σ i, η i) →₀ N` and `Π₀ i, (η i →₀ N)`. ","depth":12},{"type":"{J : Type v} →\n  [inst : CategoryTheory.SmallCategory J] →\n    (F : CategoryTheory.Functor J TypeMax) → (j : J) × F.obj j → (j : J) × F.obj j → Prop","name":"CategoryTheory.Limits.Types.FilteredColimit.Rel","isProp":false,"doc":"An alternative relation on `Σ j, F.obj j`,\nwhich generates the same equivalence relation as we use to define the colimit in `Type` above,\nbut that is more convenient when working with filtered colimits.\n\nElements in `F.obj j` and `F.obj j'` are equivalent if there is some `k : J` to the right\nwhere their images are equal.\n","depth":15},{"type":"{α : Type u_1} →\n  {β : Type u_2} →\n    (f : α → β) →\n      {p : α → Prop} → {q : β → Prop} → (∀ (x : α), p x ↔ q (f x)) → (y : Subtype q) × { x // f x = ↑y } ≃ Subtype p","name":"Equiv.sigmaSubtypeFiberEquivSubtype","isProp":false,"doc":"If for each `x` we have `p x ↔ q (f x)`, then `Σ y : {y // q y}, f ⁻¹' {y}` is equivalent\nto `{x // p x}`. ","depth":16}],"count":709}
{"noDocExamples":[],"kind":"«termℕ+»","examples":[{"type":"∀ {R : Type u_1} [inst : CommRing R] [inst_1 : Fact (∀ (I : Ideal R), I ≠ ⊤ → CharZero (R ⧸ I))] (n : ℕ+), ↑↑n = ↑↑n","name":"EqualCharZero.pnatCast_eq_natCast","isProp":true,"doc":"Internal: Not intended to be used outside this local construction. ","depth":18},{"type":"∀ {p : ℕ+} {K : Type u} [inst : Field K] [inst_1 : CharZero K] {ζ : K} [hp : Fact (Nat.Prime ↑p)]\n  [h : IsCyclotomicExtension {p} ℚ K] (hζ : IsPrimitiveRoot ζ ↑p), Prime (IsPrimitiveRoot.toInteger hζ - 1)","name":"IsPrimitiveRoot.zeta_sub_one_prime'","isProp":true,"doc":"`ζ - 1` is prime if `ζ` is a primitive `p`-th root of unity. ","depth":30},{"type":"ℕ+ → ℕ+ → ℕ+","name":"PNat.gcdA'","isProp":false,"doc":"Final value of `a / d` ","depth":2}],"count":627}
{"noDocExamples":[],"kind":"«term_≃ₗ[_]_»","examples":[{"type":"Nonempty (ℂ ≃ₗ[ℚ] ℝ)","name":"Complex.nonempty_linearEquiv_real","isProp":true,"doc":"`ℂ` and `ℝ` are isomorphic as vector spaces over `ℚ`, or equivalently,\nas additive groups. ","depth":15},{"type":"{R : Type u_3} → [inst : CommRing R] → (c₁ c₂ : R) → QuaternionAlgebra R c₁ c₂ ≃ₗ[R] Fin 4 → R","name":"QuaternionAlgebra.linearEquivTuple","isProp":false,"doc":"`QuaternionAlgebra.equivTuple` as a linear equivalence. ","depth":19},{"type":"{R : Type u_1} → [inst : CommRing R] → PolynomialModule R R ≃ₗ[Polynomial R] Polynomial R","name":"PolynomialModule.equivPolynomialSelf","isProp":false,"doc":"`PolynomialModule R R` is isomorphic to `R[X]` as an `R[X]` module. ","depth":20}],"count":606}
{"noDocExamples":[],"kind":"«term_++_»","examples":[{"type":"∀ {a b : ℕ}, Nat.Coprime a b → List.Perm (Nat.factors (a * b)) (Nat.factors a ++ Nat.factors b)","name":"Nat.perm_factors_mul_of_coprime","isProp":true,"doc":"For coprime `a` and `b`, the prime factors of `a * b` are the union of those of `a` and `b` ","depth":12},{"type":"∀ {a b : ℕ}, a ≠ 0 → b ≠ 0 → List.Perm (Nat.factors (a * b)) (Nat.factors a ++ Nat.factors b)","name":"Nat.perm_factors_mul","isProp":true,"doc":"For positive `a` and `b`, the prime factors of `a * b` are the union of those of `a` and `b` ","depth":13},{"type":"∀ {α : Type u_1} {n : ℕ} {l₁ l₂ : List α}, List.drop n (l₁ ++ l₂) = List.drop n l₁ ++ List.drop (n - List.length l₁) l₂","name":"List.drop_append_eq_append_drop","isProp":true,"doc":"Dropping the elements up to `n` in `l₁ ++ l₂` is the same as dropping the elements up to `n`\nin `l₁`, dropping the elements up to `n - l₁.length` in `l₂`, and appending them. ","depth":14}],"count":594}
{"noDocExamples":[],"kind":"«term_≃o_»","examples":[{"type":"EReal ≃o ERealᵒᵈ","name":"EReal.negOrderIso","isProp":false,"doc":"Negation as an order reversing isomorphism on `EReal`. ","depth":5},{"type":"{α : Type u_1} → [inst : Preorder α] → Topology.WithLowerSet α ≃o α","name":"Topology.WithLowerSet.ofLowerSetOrderIso","isProp":false,"doc":"`ofLowerSet` as an `OrderIso` ","depth":7},{"type":"(α : Type u_1) → Setoid α ≃o { C // Setoid.IsPartition C }","name":"Setoid.Partition.orderIso","isProp":false,"doc":"The order-preserving bijection between equivalence relations on a type `α`, and\npartitions of `α` into subsets. ","depth":8}],"count":569}
{"noDocExamples":[],"kind":"Set.«term⋂_,_»","examples":[{"type":"∀ {ι : Type u} {f : ι → Ordinal.{max u v} → Ordinal.{max u v}},\n  (∀ (i : ι), Ordinal.IsNormal (f i)) → Ordinal.derivFamily f = Ordinal.enumOrd (⋂ i, Function.fixedPoints (f i))","name":"Ordinal.derivFamily_eq_enumOrd","isProp":true,"doc":"For a family of normal functions, `Ordinal.derivFamily` enumerates the common fixed points. ","depth":9},{"type":"∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : BaireSpace α] {f : ℕ → Set α},\n  (∀ (n : ℕ), IsOpen (f n)) → (∀ (n : ℕ), Dense (f n)) → Dense (⋂ n, f n)","name":"dense_iInter_of_isOpen_nat","isProp":true,"doc":"Definition of a Baire space. ","depth":10},{"type":"∀ {X : Type u_1} {ι : Type u_3} [inst : TopologicalSpace X] [inst_1 : Encodable ι] {s : ι → Set X},\n  (∀ (i : ι), IsGδ (s i)) → IsGδ (⋂ i, s i)","name":"isGδ_iInter","isProp":true,"doc":"The intersection of an encodable family of Gδ sets is a Gδ set. ","depth":10}],"count":561}
{"noDocExamples":[],"kind":"«term_ᵃᵒᵖ»","examples":[{"type":"∀ {M : Type u_1} {X : Type u_2} [inst : TopologicalSpace M] [inst_1 : TopologicalSpace X] [inst_2 : VAdd M X]\n  [inst_3 : ContinuousVAdd M X] [inst_4 : VAdd Mᵃᵒᵖ X] [inst_5 : IsCentralVAdd M X], ContinuousVAdd Mᵃᵒᵖ X","name":"ContinuousVAdd.op","isProp":true,"doc":"If an additive action is central, then its right action is continuous when its left\naction is.","depth":14},{"type":"{α : Type u_1} → αᵃᵒᵖ → α","name":"AddOpposite.unop","isProp":false,"doc":"The element of `α` represented by `x : αᵃᵒᵖ`.","depth":3},{"type":"{M : Type u_1} → [inst : AddZeroClass M] → AddSubmonoid M ≃ AddSubmonoid Mᵃᵒᵖ","name":"AddSubmonoid.opEquiv","isProp":false,"doc":"A additive submonoid `H` of `G` determines an additive submonoid\n`H.op` of the opposite group `Gᵐᵒᵖ`.","depth":6}],"count":554}
{"noDocExamples":[],"kind":"«termΠ₀_,_»","examples":[{"type":"∀ {ι : Type u} {β : ι → Type v} [dec : DecidableEq ι] [inst : (i : ι) → AddZeroClass (β i)] {γ : Type w}\n  [inst_1 : AddZeroClass γ] ⦃f g : (Π₀ (i : ι), β i) →+ γ⦄,\n  (∀ (i : ι) (y : β i), f (DFinsupp.single i y) = g (DFinsupp.single i y)) → f = g","name":"DFinsupp.addHom_ext","isProp":true,"doc":"If two additive homomorphisms from `Π₀ i, β i` are equal on each `single a b`, then\nthey are equal. ","depth":34},{"type":"{ι : Type u} → {β : ι → Type v} → [inst : (i : ι) → Zero (β i)] → CoeFun (Π₀ (i : ι), β i) fun x => (i : ι) → β i","name":"DFinsupp.instCoeFunDFinsuppForAll","isProp":false,"doc":"Helper instance for when there are too many metavariables to apply `FunLike.coeFunForall`\ndirectly. ","depth":9},{"type":"∀ {ι : Type u_1} {π : ι → Type u_2} [inst : ∀ (i : ι), Infinite (π i)] [inst : (i : ι) → Zero (π i)]\n  [inst_1 : Nonempty ι], Infinite (Π₀ (i : ι), π i)","name":"DFinsupp.infinite_of_right","isProp":true,"doc":"See `DFinsupp.infinite_of_exists_right` for the case that only one `π ι` is infinite. ","depth":10}],"count":544}
{"noDocExamples":[],"kind":"CategoryTheory.«term_≌_»","examples":[{"type":"AlgebraicGeometry.AffineScheme ≌ CommRingCatᵒᵖ","name":"AlgebraicGeometry.AffineScheme.equivCommRingCat","isProp":false,"doc":"The category of affine schemes is equivalent to the category of commutative rings. ","depth":4},{"type":"{C : Type u₁} →\n  {D : Type u₂} →\n    [inst : CategoryTheory.Category.{v₁, u₁} C] →\n      [inst_1 : CategoryTheory.Category.{v₂, u₂} D] → (C ≌ D) → CategoryTheory.Functor D C","name":"CategoryTheory.Equivalence.inverse","isProp":false,"doc":"A functor in the other direction ","depth":9},{"type":"{C : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} C] →\n    [inst_1 : CategoryTheory.MonoidalCategory C] →\n      {D : Type u₂} → [inst_2 : CategoryTheory.Category.{v₂, u₂} D] → (C ≌ D) → CategoryTheory.MonoidalCategory D","name":"CategoryTheory.Monoidal.transport","isProp":false,"doc":"Transport a monoidal structure along an equivalence of (plain) categories.\n","depth":10}],"count":541}
{"noDocExamples":[],"kind":"«term∑'_,_»","examples":[{"type":"∀ {α : Type u_1} {f : α → ENNReal}, ∑' (i : α), f i ≠ ⊤ → Set.Countable (Function.support f)","name":"Summable.countable_support_ennreal","isProp":true,"doc":"Finitely summable non-negative functions have countable support ","depth":14},{"type":"∀ (f : ℕ → NNReal), Filter.Tendsto (fun i => ∑' (k : ℕ), f (k + i)) Filter.atTop (nhds 0)","name":"NNReal.tendsto_sum_nat_add","isProp":true,"doc":"For `f : ℕ → ℝ≥0`, then `∑' k, f (k + i)` tends to zero. This does not require a summability\nassumption on `f`, as otherwise all sums are zero. ","depth":14},{"type":"∀ {ι : Type u_1} {E : Type u_3} [inst : SeminormedAddCommGroup E] {f : ι → E},\n  (Summable fun i => ‖f i‖) → ‖∑' (i : ι), f i‖ ≤ ∑' (i : ι), ‖f i‖","name":"norm_tsum_le_tsum_norm","isProp":true,"doc":"If `∑' i, ‖f i‖` is summable, then `‖∑' i, f i‖ ≤ (∑' i, ‖f i‖)`. Note that we do not assume\nthat `∑' i, f i` is summable, and it might not be the case if `α` is not a complete space. ","depth":15}],"count":525}
{"noDocExamples":[],"kind":"«term_≃*_»","examples":[{"type":"{M : Type u_6} →\n  {N : Type u_7} → [inst : Mul M] → [inst_1 : Mul N] → (f : M ≃ N) → (∀ (x y : M), f (x * y) = f x * f y) → M ≃* N","name":"MulEquiv.mk'","isProp":false,"doc":"Makes a multiplicative isomorphism from a bijection which preserves multiplication. ","depth":19},{"type":"∀ {M : Type u_6} {N : Type u_7} [inst : Mul M] [inst_1 : Mul N] {f g : M ≃* N}, (∀ (x : M), f x = g x) → f = g","name":"MulEquiv.ext","isProp":true,"doc":"Two multiplicative isomorphisms agree if they are defined by the\nsame underlying function. ","depth":25},{"type":"{M : Type u_12} → {N : Type u_13} → [inst : Mul M] → [inst_1 : Mul N] → M ≃* N → M →ₙ* N","name":"MulEquiv.toMulHom","isProp":false,"doc":"The `MulHom` underlying a `MulEquiv`. ","depth":9}],"count":522}
{"noDocExamples":[],"kind":"«term_≃ₐ[_]_»","examples":[{"type":"{K : Type u_1} → [inst : IsROrC K] → K ≃ₐ[ℝ] K","name":"IsROrC.conjAe","isProp":false,"doc":"Conjugate as an `ℝ`-algebra equivalence ","depth":13},{"type":"{R : Type u_3} → [inst : CommRing R] → Quaternion R ≃ₐ[R] (Quaternion R)ᵐᵒᵖ","name":"Quaternion.starAe","isProp":false,"doc":"Quaternion conjugate as an `AlgEquiv` to the opposite ring. ","depth":15},{"type":"∀ {R : Type w₁} {A : Type w₂} {B : Type w₃} [inst : CommRing R] [inst_1 : CommRing A] [inst_2 : Algebra R A]\n  [inst_3 : CommRing B] [inst_4 : Algebra R B],\n  Algebra.FinitePresentation R A → (A ≃ₐ[R] B) → Algebra.FinitePresentation R B","name":"Algebra.FinitePresentation.equiv","isProp":true,"doc":"If `e : A ≃ₐ[R] B` and `A` is finitely presented, then so is `B`. ","depth":18}],"count":522}
{"noDocExamples":[],"kind":"«term‖_‖₊»","examples":[{"type":"∀ {E : Type u_6} [inst : SeminormedAddGroup E] (a b : E), nndist a b = ‖a - b‖₊","name":"nndist_eq_nnnorm","isProp":true,"doc":"**Alias** of `nndist_eq_nnnorm_sub`.","depth":14},{"type":"∀ {E : Type u_6} [inst : SeminormedAddGroup E] (a b : E), ‖b‖₊ ≤ ‖a‖₊ + ‖a - b‖₊","name":"nnnorm_le_insert","isProp":true,"doc":"**Alias** of `nnnorm_le_nnnorm_add_nnnorm_sub`.","depth":15},{"type":"∀ {ι : Type u_1} {E : Type u_3} [inst : SeminormedAddCommGroup E] {f : ι → E},\n  (Summable fun i => ‖f i‖₊) → ‖∑' (i : ι), f i‖₊ ≤ ∑' (i : ι), ‖f i‖₊","name":"nnnorm_tsum_le","isProp":true,"doc":"If `∑' i, ‖f i‖₊` is summable, then `‖∑' i, f i‖₊ ≤ ∑' i, ‖f i‖₊`. Note that\nwe do not assume that `∑' i, f i` is summable, and it might not be the case if `α` is not a complete\nspace. ","depth":15}],"count":513}
{"noDocExamples":[],"kind":"«term_%_»","examples":[{"type":"∀ {n a : ℕ}, Even n → Even a → Even (n % a)","name":"Even.mod_even","isProp":true,"doc":"If `n` is even and `a` is even, then `n % a` is even. ","depth":11},{"type":"∀ {n a : ℕ}, Odd n → Even a → Odd (n % a)","name":"Odd.mod_even","isProp":true,"doc":"If `n` is odd and `a` is even, then `n % a` is odd. ","depth":11},{"type":"∀ {n : ℕ}, n % 4 = 1 → (-1) ^ (n / 2) = 1","name":"ZMod.neg_one_pow_div_two_of_one_mod_four","isProp":true,"doc":"If `n % 4 = 1`, then `(-1)^(n/2) = 1`. ","depth":11}],"count":506}
{"noDocExamples":[],"kind":"MeasureTheory.«term∀ᵐ_∂_,_»","examples":[{"type":"∀ {α : Type u_2} {m0 : MeasurableSpace α} {μ : MeasureTheory.Measure α} {s t : α → Prop},\n  s =ᶠ[MeasureTheory.Measure.ae μ] t →\n    ∀ {p : α → Prop},\n      (∀ᵐ (x : α) ∂MeasureTheory.Measure.restrict μ s, p x) → ∀ᵐ (x : α) ∂MeasureTheory.Measure.restrict μ t, p x","name":"MeasureTheory.ae_restrict_of_ae_eq_of_ae_restrict","isProp":true,"doc":"If two measurable sets are ae_eq then any proposition that is almost everywhere true on one\nis almost everywhere true on the other ","depth":14},{"type":"∀ {α : Type u_2} {m0 : MeasurableSpace α} {μ : MeasureTheory.Measure α} {s t : α → Prop},\n  s =ᶠ[MeasureTheory.Measure.ae μ] t →\n    ∀ {p : α → Prop},\n      (∀ᵐ (x : α) ∂MeasureTheory.Measure.restrict μ s, p x) ↔ ∀ᵐ (x : α) ∂MeasureTheory.Measure.restrict μ t, p x","name":"MeasureTheory.ae_restrict_congr_set","isProp":true,"doc":"If two measurable sets are ae_eq then any proposition that is almost everywhere true on one\nis almost everywhere true on the other ","depth":15},{"type":"∀ {α : Type u_1} {m0 : MeasurableSpace α} {μ : MeasureTheory.Measure α} {f : α → ENNReal},\n  AEMeasurable f →\n    (∀ᵐ (x : α) ∂μ, f x ≠ 0) →\n      (∀ᵐ (x : α) ∂μ, f x ≠ ⊤) → MeasureTheory.Measure.AbsolutelyContinuous μ (MeasureTheory.Measure.withDensity μ f)","name":"MeasureTheory.withDensity_absolutelyContinuous'","isProp":true,"doc":"If `f` is almost everywhere positive and finite, then `μ ≪ μ.withDensity f`. See also\n`withDensity_absolutelyContinuous` for the reverse direction, which always holds. ","depth":16}],"count":487}
{"noDocExamples":[],"kind":"«term_≃+_»","examples":[{"type":"{α : Type u_2} → {β : Type u_3} → FreeAbelianGroup α ≃+ FreeAbelianGroup β → α ≃ β","name":"FreeAbelianGroup.Equiv.ofFreeAbelianGroupEquiv","isProp":false,"doc":"Isomorphic free abelian groups (as additive groups) have equivalent bases. ","depth":11},{"type":"{F : Type u_1} →\n  {α : Type u_2} →\n    {β : Type u_3} → [inst : Add α] → [inst_1 : Add β] → [inst_2 : AddEquivClass F α β] → CoeTC F (α ≃+ β)","name":"instCoeTCAddEquiv","isProp":false,"doc":"Any type satisfying `AddEquivClass` can be cast into `AddEquiv` via\n`AddEquivClass.toAddEquiv`. ","depth":11},{"type":"{G : Type u_1} →\n  {H : Type u_2} → [inst : MulOneClass G] → [inst_1 : AddZeroClass H] → Additive G ≃+ H ≃ (G ≃* Multiplicative H)","name":"AddEquiv.toMultiplicative'","isProp":false,"doc":"Reinterpret `Additive G ≃+ H` as `G ≃* Multiplicative H`. ","depth":11}],"count":477}
{"noDocExamples":[],"kind":"«term_≃+*_»","examples":[{"type":"{R : Type u_4} →\n  {S : Type u_5} → [inst : Mul R] → [inst_1 : Mul S] → [inst_2 : Add R] → [inst_3 : Add S] → R ≃+* S → S ≃+* R","name":"RingEquiv.symm","isProp":false,"doc":"The inverse of a ring isomorphism is a ring isomorphism. ","depth":13},{"type":"{X Y : Type u_1} →\n  [inst : CommSemiring X] → [inst_1 : CommSemiring Y] → X ≃+* Y → (CommSemiRingCat.of X ≅ CommSemiRingCat.of Y)","name":"RingEquiv.toCommSemiRingCatIso","isProp":false,"doc":"Ring equivalence are isomorphisms in category of commutative semirings\n","depth":14},{"type":"{R : Type u_2} →\n  [inst : Semiring R] → {σ : Type u_3} → [inst_1 : Fintype σ] → HahnSeries (σ →₀ ℕ) R ≃+* MvPowerSeries σ R","name":"HahnSeries.toMvPowerSeries","isProp":false,"doc":"The ring `HahnSeries (σ →₀ ℕ) R` is isomorphic to `MvPowerSeries σ R` for a `Fintype` `σ`.\nWe take the index set of the hahn series to be `Finsupp` rather than `pi`,\neven though we assume `Fintype σ` as this is more natural for alignment with `MvPowerSeries`.\nAfter importing `Algebra.Order.Pi` the ring `HahnSeries (σ → ℕ) R` could be constructed instead.\n ","depth":17}],"count":457}
{"noDocExamples":[],"kind":"«term_≈_»","examples":[{"type":"∀ (G : SetTheory.PGame) [inst : SetTheory.PGame.Impartial G], G ≈ SetTheory.PGame.nim (SetTheory.PGame.grundyValue G)","name":"SetTheory.PGame.equiv_nim_grundyValue","isProp":true,"doc":"The Sprague-Grundy theorem which states that every impartial game is equivalent to a game of\nnim, namely the game of nim corresponding to the games Grundy value ","depth":7},{"type":"∀ {x y : SetTheory.PGame}, SetTheory.PGame.Relabelling x y → x ≈ y","name":"SetTheory.PGame.Relabelling.equiv","isProp":true,"doc":"A relabelling lets us prove equivalence of games. ","depth":8},{"type":"∀ (x : SetTheory.PGame), 0 * x ≈ 0","name":"SetTheory.PGame.zero_mul_equiv","isProp":true,"doc":"`0 * x` is equivalent to `0`. ","depth":9}],"count":454}
{"noDocExamples":[],"kind":"CategoryTheory.«term_⊣_»","examples":[{"type":"CategoryTheory.Cat.free ⊣ CategoryTheory.Quiv.forget","name":"CategoryTheory.Quiv.adj","isProp":false,"doc":"The adjunction between forming the free category on a quiver, and forgetting a category to a quiver.\n","depth":6},{"type":"CompHaus.toProfinite ⊣ profiniteToCompHaus","name":"Profinite.toProfiniteAdjToCompHaus","isProp":false,"doc":"The adjunction between CompHaus.to_Profinite and Profinite.to_CompHaus ","depth":6},{"type":"{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] →\n    (T : CategoryTheory.Monad C) →\n      CategoryTheory.Kleisli.Adjunction.toKleisli T ⊣ CategoryTheory.Kleisli.Adjunction.fromKleisli T","name":"CategoryTheory.Kleisli.Adjunction.adj","isProp":false,"doc":"The Kleisli adjunction which gives rise to the monad `(T, η_ T, μ_ T)`.\ncf Lemma 5.2.11 of [Riehl][riehl2017]. ","depth":10}],"count":447}
{"noDocExamples":[],"kind":"«term_^[_]»","examples":[{"type":"∀ {α : Type u} {f : α → α} {x : α}, Function.IsFixedPt f x → ∀ (n : ℕ), Function.IsFixedPt f^[n] x","name":"Function.IsFixedPt.iterate","isProp":true,"doc":"If `x` is a fixed point of `f`, then it is a fixed point of `f^[n]`. ","depth":10},{"type":"∀ {α : Type u_1} (f : α → α) (x : α),\n  Function.periodicOrbit f x = Cycle.map (fun n => f^[n] x) ↑(List.range (Function.minimalPeriod f x))","name":"Function.periodicOrbit_eq_cycle_map","isProp":true,"doc":"The definition of a periodic orbit, in terms of `Cycle.map`. ","depth":11},{"type":"∀ {α : Type u_2} [inst : MeasurableSpace α] {f : α → α} {μ : MeasureTheory.Measure α},\n  MeasureTheory.Conservative f μ → ∀ (n : ℕ), MeasureTheory.Conservative f^[n] μ","name":"MeasureTheory.Conservative.iterate","isProp":true,"doc":"Iteration of a conservative system is a conservative system. ","depth":11}],"count":422}
{"noDocExamples":[],"kind":"«term_≃ₜ_»","examples":[{"type":"{M : Type u_1} → [inst : TopologicalSpace M] → M ≃ₜ Mᵐᵒᵖ","name":"MulOpposite.opHomeomorph","isProp":false,"doc":"`MulOpposite.op` as a homeomorphism. ","depth":6},{"type":"{X : Type u} → [inst : TopologicalSpace X] → ULift.{v, u} X ≃ₜ X","name":"Homeomorph.ulift","isProp":false,"doc":"`ULift X` is homeomorphic to `X`. ","depth":7},{"type":"{X Y : Stonean} → CoeSort.coe X ≃ₜ CoeSort.coe Y → (X ≅ Y)","name":"Stonean.isoOfHomeo","isProp":false,"doc":"Construct an isomorphism from a homeomorphism. ","depth":11}],"count":418}
{"noDocExamples":[],"kind":"MeasureTheory.«term∫⁻_,_∂_»","examples":[{"type":"∀ {α : Type u_1} {m : MeasurableSpace α} {μ : MeasureTheory.Measure α} {f : α → ℝ},\n  MeasureTheory.Integrable f →\n    ∫ (a : α), f a ∂μ =\n      ENNReal.toReal (∫⁻ (a : α), ENNReal.ofReal (f a) ∂μ) - ENNReal.toReal (∫⁻ (a : α), ENNReal.ofReal (-f a) ∂μ)","name":"MeasureTheory.integral_eq_lintegral_pos_part_sub_lintegral_neg_part","isProp":true,"doc":"The Bochner integral of a real-valued function `f : α → ℝ` is the difference between the\nintegral of the positive part of `f` and the integral of the negative part of `f`.  ","depth":14},{"type":"∀ {α : Type u_1} {β : Type u_3} [inst : MeasurableSpace α] [inst_1 : MeasurableSpace β] {μ : MeasureTheory.Measure α}\n  [inst_2 : MeasureTheory.SFinite μ] {f : α → β → ENNReal},\n  Measurable (Function.uncurry f) → Measurable fun y => ∫⁻ (x : α), f x y ∂μ","name":"Measurable.lintegral_prod_left","isProp":true,"doc":"The Lebesgue integral is measurable. This shows that the integrand of (the right-hand-side of)\nthe symmetric version of Tonelli's theorem is measurable.\nThis version has the argument `f` in curried form. ","depth":15},{"type":"∀ {α : Type u_1} {β : Type u_3} [inst : MeasurableSpace α] [inst_1 : MeasurableSpace β] {ν : MeasureTheory.Measure β}\n  [inst_2 : MeasureTheory.SFinite ν] {f : α → β → ENNReal},\n  Measurable (Function.uncurry f) → Measurable fun x => ∫⁻ (y : β), f x y ∂ν","name":"Measurable.lintegral_prod_right","isProp":true,"doc":"The Lebesgue integral is measurable. This shows that the integrand of (the right-hand-side of)\nTonelli's theorem is measurable.\nThis version has the argument `f` in curried form. ","depth":15}],"count":404}
{"noDocExamples":[],"kind":"MeasureTheory.«term∫_,_∂_»","examples":[{"type":"∀ {α : Type u_1} {m : MeasurableSpace α} {μ : MeasureTheory.Measure α} {f : α → ℝ},\n  MeasureTheory.Integrable f →\n    ∫ (a : α), f a ∂μ =\n      ENNReal.toReal (∫⁻ (a : α), ENNReal.ofReal (f a) ∂μ) - ENNReal.toReal (∫⁻ (a : α), ENNReal.ofReal (-f a) ∂μ)","name":"MeasureTheory.integral_eq_lintegral_pos_part_sub_lintegral_neg_part","isProp":true,"doc":"The Bochner integral of a real-valued function `f : α → ℝ` is the difference between the\nintegral of the positive part of `f` and the integral of the negative part of `f`.  ","depth":14},{"type":"∀ {α : Type u_1} {m0 : MeasurableSpace α} {μ : MeasureTheory.Measure α} {f : α → ℝ}\n  [inst : MeasureTheory.IsProbabilityMeasure μ], MeasureTheory.Integrable f → ∃ x, f x ≤ ∫ (a : α), f a ∂μ","name":"MeasureTheory.exists_le_integral","isProp":true,"doc":"**First moment method**. The minimum of an integrable function is smaller than its integral. ","depth":16},{"type":"∀ {α : Type u_1} {m0 : MeasurableSpace α} {μ : MeasureTheory.Measure α} {f : α → ℝ}\n  [inst : MeasureTheory.IsProbabilityMeasure μ], MeasureTheory.Integrable f → ∃ x, ∫ (a : α), f a ∂μ ≤ f x","name":"MeasureTheory.exists_integral_le","isProp":true,"doc":"**First moment method**. The maximum of an integrable function is greater than its integral. ","depth":17}],"count":398}
{"noDocExamples":[],"kind":"«term_→ₛₗ[_]_»","examples":[{"type":"{R : Type u_1} →\n  {M : Type u_5} →\n    {M₁ : Type u_6} →\n      [inst : CommSemiring R] →\n        [inst_1 : AddCommMonoid M] →\n          [inst_2 : Module R M] →\n            [inst_3 : AddCommMonoid M₁] →\n              [inst_4 : Module R M₁] →\n                {I : R →+* R} → (M →ₗ[R] M →ₛₗ[I] R) → (M₁ →ₗ[R] M₁ →ₛₗ[I] R) → (M →ₗ[R] M₁) → (M₁ →ₗ[R] M) → Prop","name":"LinearMap.IsAdjointPair","isProp":false,"doc":"Given a pair of modules equipped with bilinear forms, this is the condition for a pair of\nmaps between them to be mutually adjoint. ","depth":27},{"type":"{R : Type u_1} →\n  {R₂ : Type u_2} →\n    {E : Type u_5} →\n      {E₂ : Type u_6} →\n        [inst : Semiring R] →\n          [inst_1 : Semiring R₂] →\n            {σ₁₂ : R →+* R₂} →\n              [inst_2 : SeminormedAddCommGroup E] →\n                [inst_3 : SeminormedAddCommGroup E₂] →\n                  [inst_4 : Module R E] → [inst_5 : Module R₂ E₂] → (f : E →ₛₗ[σ₁₂] E₂) → Isometry ⇑f → E →ₛₗᵢ[σ₁₂] E₂","name":"LinearMap.toLinearIsometry","isProp":false,"doc":"Construct a `LinearIsometry` from a `LinearMap` satisfying `Isometry`. ","depth":30},{"type":"∀ {K : Type u_1} {V : Type u_2} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {L : Type u_3}\n  {W : Type u_4} [inst_3 : DivisionRing L] [inst_4 : AddCommGroup W] [inst_5 : Module L W] {σ : K →+* L} {τ : L →+* K}\n  [inst_6 : RingHomInvPair σ τ] (f : V →ₛₗ[σ] W) (hf : Function.Injective ⇑f),\n  Function.Injective (Projectivization.map f hf)","name":"Projectivization.map_injective","isProp":true,"doc":"Mapping with respect to a semilinear map over an isomorphism of fields yields\nan injective map on projective spaces. ","depth":33}],"count":391}
{"noDocExamples":[],"kind":"«term_→o_»","examples":[{"type":"{α : Type u_2} → [inst : Preorder α] → α →o α","name":"OrderHom.id","isProp":false,"doc":"The identity function as bundled monotone function. ","depth":6},{"type":"{α : Type u_2} → {β : Type u_3} → [inst : Preorder α] → [inst_1 : Preorder β] → (α →o β) → α → β","name":"OrderHom.Simps.coe","isProp":false,"doc":"See Note [custom simps projection]. We give this manually so that we use `toFun` as the\nprojection directly instead. ","depth":9},{"type":"{α : Type u_2} → {β : Type u_3} → [inst : Preorder α] → [inst_1 : Preorder β] → (α →o β) ≃ (αᵒᵈ →o βᵒᵈ)","name":"OrderHom.dual","isProp":false,"doc":"Reinterpret a bundled monotone function as a monotone function between dual orders. ","depth":10}],"count":386}
{"noDocExamples":[],"kind":"Function.«term_↪_»","examples":[{"type":"∀ {ι : Type u} (β : ι → Type v) [I : Nonempty ι], ∃ i, Nonempty ((j : ι) → β i ↪ β j)","name":"Function.Embedding.min_injective","isProp":true,"doc":"The cardinals are well-ordered. We express it here by the fact that in any set of cardinals\nthere is an element that injects into the others.\nSee `Cardinal.conditionallyCompleteLinearOrderBot` for (one of) the lattice instances. ","depth":10},{"type":"(α : Sort u_1) → α ↪ α","name":"Function.Embedding.refl","isProp":false,"doc":"The identity map as a `Function.Embedding`. ","depth":3},{"type":"{α : Sort u} → {β : Sort v} → α ≃ β → α ↪ β","name":"Equiv.toEmbedding","isProp":false,"doc":"Convert an `α ≃ β` to `α ↪ β`.\n\nThis is also available as a coercion `Equiv.coeEmbedding`.\nThe explicit `Equiv.toEmbedding` version is preferred though, since the coercion can have issues\ninferring the type of the resulting embedding. For example:\n\n```lean\n-- Works:\nexample (s : Finset (Fin 3)) (f : Equiv.Perm (Fin 3)) : s.map f.toEmbedding = s.map f := by simp\n-- Error, `f` has type `Fin 3 ≃ Fin 3` but is expected to have type `Fin 3 ↪ ?m_1 : Type ?`\nexample (s : Finset (Fin 3)) (f : Equiv.Perm (Fin 3)) : s.map f = s.map f.toEmbedding := by simp\n```\n","depth":5}],"count":386}
{"noDocExamples":[],"kind":"«term⁅_,_⁆»","examples":[{"type":"∀ {L : Type v} [self : LieRing L] (x : L), ⁅x, x⁆ = 0","name":"LieRing.lie_self","isProp":true,"doc":"A Lie ring bracket vanishes on the diagonal in L × L. ","depth":12},{"type":"∀ {L : Type v} [self : LieRing L] (x y z : L), ⁅x, ⁅y, z⁆⁆ = ⁅⁅x, y⁆, z⁆ + ⁅y, ⁅x, z⁆⁆","name":"LieRing.leibniz_lie","isProp":true,"doc":"A Lie ring bracket satisfies a Leibniz / Jacobi identity. ","depth":17},{"type":"∀ {η : Type u_4} [inst : Finite η] {Gs : η → Type u_5} [inst : (i : η) → Group (Gs i)]\n  (H K : (i : η) → Subgroup (Gs i)),\n  ⁅Subgroup.pi Set.univ H, Subgroup.pi Set.univ K⁆ = Subgroup.pi Set.univ fun i => ⁅H i, K i⁆","name":"Subgroup.commutator_pi_pi_of_finite","isProp":true,"doc":"The commutator of a finite direct product is contained in the direct product of the commutators.\n","depth":18}],"count":378}
{"noDocExamples":[],"kind":"Quotient.«term⟦_⟧»","examples":[{"type":"∀ {α : Sort u} {s : Setoid α} {motive : Quotient s → Prop}, (∀ (a : α), motive ⟦a⟧) → ∀ (q : Quotient s), motive q","name":"Quotient.ind","isProp":true,"doc":"The analogue of `Quot.ind`: every element of `Quotient s` is of the form `Quotient.mk s a`. ","depth":9},{"type":"∀ {α : Sort u} {s : Setoid α} {a b : α}, a ≈ b → ⟦a⟧ = ⟦b⟧","name":"Quotient.sound","isProp":true,"doc":"The analogue of `Quot.sound`: If `a` and `b` are related by the equivalence relation,\nthen they have equal equivalence classes.\n","depth":10},{"type":"∀ {α : Sort u} {s : Setoid α} {motive : Quotient s → Prop} (q : Quotient s), (∀ (a : α), motive ⟦a⟧) → motive q","name":"Quotient.inductionOn","isProp":true,"doc":"The analogue of `Quot.inductionOn`: every element of `Quotient s` is of the form `Quotient.mk s a`. ","depth":10}],"count":373}
{"noDocExamples":[],"kind":"«term_-ᵥ_»","examples":[{"type":"∀ {G : Type u_1} [inst : AddGroup G] (g1 g2 : G), g1 -ᵥ g2 = g1 - g2","name":"vsub_eq_sub","isProp":true,"doc":"Simplify subtraction for a torsor for an `AddGroup G` over\nitself. ","depth":13},{"type":"∀ {G : Type u_1} {P : Type u_2} [inst : AddGroup G] [T : AddTorsor G P] (p : P), Function.Injective fun x => p -ᵥ x","name":"vsub_right_injective","isProp":true,"doc":"Subtracting a point from the point `p` is an injective\nfunction. ","depth":14},{"type":"∀ {G : Type u_1} {P : Type u_2} [inst : AddGroup G] [T : AddTorsor G P] (p : P), p -ᵥ p = 0","name":"vsub_self","isProp":true,"doc":"Subtracting a point from itself produces 0. ","depth":14}],"count":366}
{"noDocExamples":[],"kind":"LinearMap.compNotation","examples":[{"type":"∀ {R : Type u} [inst : Semiring R] {P : Type v} [inst_1 : AddCommMonoid P] [inst_2 : Module R P],\n  (∀ (f : (P →₀ R) →ₗ[R] P), Function.Surjective ⇑f → ∃ h, f ∘ₗ h = LinearMap.id) → Module.Projective R P","name":"Module.Projective.of_lifting_property''","isProp":true,"doc":"A module which satisfies the universal property is projective: If all surjections of\n`R`-modules `(P →₀ R) →ₗ[R] P` have `R`-linear left inverse maps, then `P` is\nprojective. ","depth":33},{"type":"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V] {f g : V →ₗ[K] V}, f ∘ₗ g = LinearMap.id ↔ g ∘ₗ f = LinearMap.id","name":"LinearMap.comp_eq_id_comm","isProp":true,"doc":"In a finite-dimensional space, linear maps are inverse to each other on one side if and only if\nthey are inverse to each other on the other side. ","depth":33},{"type":"∀ {R : Type u} {A : Type v} [inst : CommSemiring R] [inst_1 : AddCommMonoid A] [inst_2 : Module R A]\n  [self : Coalgebra R A], LinearMap.rTensor A Coalgebra.counit ∘ₗ Coalgebra.comul = (TensorProduct.mk R R A) 1","name":"Coalgebra.rTensor_counit_comp_comul","isProp":true,"doc":"The counit satisfies the left counitality law ","depth":34}],"count":338}
{"noDocExamples":[],"kind":"Lean.Parser.Term.match","examples":[{"type":"∀ {α : Type u_2} [inst : Preorder α] {a : Thunk α} {ε : Type u_1} [self : Estimator a ε] (e : ε),\n  match EstimatorData.improve a e with\n  | none => EstimatorData.bound a e = Thunk.get a\n  | some e' => EstimatorData.bound a e < EstimatorData.bound a e'","name":"Estimator.improve_spec","isProp":true,"doc":"Calling `improve` either gives a strictly better bound,\nor a proof that the current bound is exact. ","depth":18},{"type":"∀ {α β δ : Type} [inst : CanonicallyLinearOrderedAddCommMonoid δ] {C : Levenshtein.Cost α β δ} {xs : List α}\n  {ys : List β} (self : LevenshteinEstimator' C xs ys),\n  self.bound =\n    match self.pre_rev, (_ : List.reverse self.pre_rev ++ self.suff = ys) with\n    | [], split => ((↑self.distances)[0], List.length ys)\n    | x, split => (List.minimum_of_length_pos (_ : 0 < List.length ↑self.distances), List.length self.suff)","name":"LevenshteinEstimator'.bound_eq","isProp":true,"doc":"Predicate describing the current bound. ","depth":27},{"type":"{C : Type u_1} →\n  [inst : CategoryTheory.Category.{u_2, u_1} C] →\n    {B X : C} →\n      (f : X ⟶ B) →\n        [inst_1 : CategoryTheory.EffectiveEpi f] →\n          CategoryTheory.EffectiveEpiFamilyStruct (fun x => X) fun x =>\n            match x with\n            | PUnit.unit => f","name":"CategoryTheory.effectiveEpiFamilyStructSingletonOfEffectiveEpi","isProp":false,"doc":"An `EffectiveEpiFamily` consisting of a single `EffectiveEpi`\n","depth":18}],"count":308}
{"noDocExamples":[],"kind":"«term_→ₙ*_»","examples":[{"type":"{α : Type u} → [inst : Mul α] → α →ₙ* WithOne α","name":"WithOne.coeMulHom","isProp":false,"doc":"`WithOne.coe` as a bundled morphism ","depth":6},{"type":"{M : Type u_3} → {N : Type u_4} → [inst : Mul M] → [inst_1 : CommSemigroup N] → Mul (M →ₙ* N)","name":"MulHom.instMulMulHomToMulToCommMagma","isProp":false,"doc":"Given two mul morphisms `f`, `g` to a commutative semigroup, `f * g` is the mul morphism\nsending `x` to `f x * g x`. ","depth":9},{"type":"{M : Type u_12} → {N : Type u_13} → [inst : Mul M] → [inst_1 : Mul N] → M ≃* N → M →ₙ* N","name":"MulEquiv.toMulHom","isProp":false,"doc":"The `MulHom` underlying a `MulEquiv`. ","depth":9}],"count":279}
{"noDocExamples":[],"kind":"Asymptotics.«term_=O[_]_»","examples":[{"type":"(fun τ => jacobiTheta τ - 1) =O[Filter.comap Complex.im Filter.atTop] fun τ => Real.exp (-Real.pi * τ.im)","name":"isBigO_at_im_infty_jacobiTheta_sub_one","isProp":true,"doc":"The norm of `jacobiTheta τ - 1` decays exponentially as `im τ → ∞`. ","depth":9},{"type":"zetaKernel₁ =O[Filter.atTop] fun t => Real.exp (-Real.pi * t)","name":"isBigO_atTop_zetaKernel₁","isProp":true,"doc":"Bound for `zetaKernel₁` for large `t`. ","depth":9},{"type":"zetaKernel₂ =O[Filter.atTop] fun t => Real.exp (-Real.pi * t)","name":"isBigO_atTop_zetaKernel₂","isProp":true,"doc":"Bound for `zetaKernel₂` for large `t`. ","depth":9}],"count":278}
{"noDocExamples":[],"kind":"termDepIfThenElse","examples":[{"type":"∀ {P : Prop} {α : Sort u_1} {a b : α} [inst : Decidable P], (if x : P then a else b) = if P then a else b","name":"dite_eq_ite","isProp":true,"doc":"A `dite` whose results do not actually depend on the condition may be reduced to an `ite`. ","depth":12},{"type":"∀ {α : Sort u_1} {β : Sort u_2} (f : α → β) (P : Prop) [inst : Decidable P] (x : P → α) (y : ¬P → α),\n  f (dite P x y) = if h : P then f (x h) else f (y h)","name":"apply_dite","isProp":true,"doc":"A function applied to a `dite` is a `dite` of that function applied to each of the branches. ","depth":15},{"type":"∀ {α : Sort u_2} {σ : α → Sort u_1} (P : Prop) [inst : Decidable P] (f : P → (a : α) → σ a) (g : ¬P → (a : α) → σ a)\n  (a : α), dite P f g a = if h : P then f h a else g h a","name":"dite_apply","isProp":true,"doc":"A 'dite' producing a `Pi` type `Π a, σ a`, applied to a value `a : α` is a `dite` that applies\neither branch to `a`. ","depth":17}],"count":275}
{"noDocExamples":[],"kind":"Finsupp.fun₀","examples":[{"type":"∀ {p : ℕ}, Nat.Prime p → Nat.factorization p = fun₀ | p => 1","name":"Nat.Prime.factorization","isProp":true,"doc":"The only prime factor of prime `p` is `p` itself, with multiplicity `1` ","depth":8},{"type":"∀ {p k : ℕ}, Nat.Prime p → Nat.factorization (p ^ k) = fun₀ | p => k","name":"Nat.Prime.factorization_pow","isProp":true,"doc":"For prime `p` the only prime factor of `p^k` is `p` with multiplicity `k` ","depth":12},{"type":"∀ {n p k : ℕ}, n ≠ 0 → (Nat.factorization n = fun₀ | p => k) → n = p ^ k","name":"Nat.eq_pow_of_factorization_eq_single","isProp":true,"doc":"If the factorization of `n` contains just one number `p` then `n` is a power of `p` ","depth":12}],"count":264}
{"noDocExamples":[],"kind":"Asymptotics.«term_=o[_]_»","examples":[{"type":"∀ (s : ℝ), (fun x => x ^ s) =o[Filter.atTop] Real.exp","name":"isLittleO_rpow_exp_atTop","isProp":true,"doc":"`x ^ s = o(exp x)` as `x → ∞` for any real `s`. ","depth":10},{"type":"∀ {R : Type u_4} [inst : NormedRing R] {r : ℝ}, 1 < r → Nat.cast =o[Filter.atTop] fun n => r ^ n","name":"isLittleO_coe_const_pow_of_one_lt","isProp":true,"doc":"For a real `r > 1` we have `n = o(r ^ n)` as `n → ∞`. ","depth":12},{"type":"∀ (k : ℕ) {b : ℝ}, 0 < b → (fun x => x ^ k) =o[Filter.atTop] fun x => Real.exp (b * x)","name":"isLittleO_pow_exp_pos_mul_atTop","isProp":true,"doc":"`x ^ k = o(exp(b * x))` as `x → ∞` for any natural `k` and positive `b`. ","depth":12}],"count":247}
{"noDocExamples":[],"kind":"TensorProduct.«term_⊗ₜ[_]_»","examples":[{"type":"∀ (R : Type u) (S : Type v) [inst : CommRing R] [inst_1 : CommRing S] [inst_2 : Algebra R S],\n  Submodule.span S (Set.range fun s => 1 ⊗ₜ[R] s - s ⊗ₜ[R] 1) =\n    Submodule.restrictScalars S (KaehlerDifferential.ideal R S)","name":"KaehlerDifferential.submodule_span_range_eq_ideal","isProp":true,"doc":"The kernel of `S ⊗[R] S →ₐ[R] S` is generated by `1 ⊗ s - s ⊗ 1` as a `S`-module. ","depth":27},{"type":"∀ (R : Type u_1) [inst : CommSemiring R] (M : Type u_4) (N : Type u_5) [inst_1 : AddCommMonoid M]\n  [inst_2 : AddCommMonoid N] [inst_3 : Module R M] [inst_4 : Module R N],\n  Submodule.span R {t | ∃ m n, m ⊗ₜ[R] n = t} = ⊤","name":"TensorProduct.span_tmul_eq_top","isProp":true,"doc":"The simple (aka pure) elements span the tensor product. ","depth":29},{"type":"∀ {R : Type u_1} [inst : CommSemiring R] {R' : Type u_2} [inst_1 : Monoid R'] {M : Type u_4} {N : Type u_5}\n  [inst_2 : AddCommMonoid M] [inst_3 : AddCommMonoid N] [inst_4 : Module R M] [inst_5 : Module R N]\n  [inst_6 : DistribMulAction R' M] [inst_7 : DistribMulAction R' N] [inst_8 : TensorProduct.CompatibleSMul R R' M N]\n  (r : R') (m : M) (n : N), (r • m) ⊗ₜ[R] n = m ⊗ₜ[R] (r • n)","name":"TensorProduct.smul_tmul","isProp":true,"doc":"`smul` can be moved from one side of the product to the other .","depth":31}],"count":239}
{"noDocExamples":[],"kind":"Function.term_On_","examples":[{"type":"∀ {α : Type u_1} {ι : Type u_4} {f : ι → α}, Function.Injective f → Pairwise ((fun x x_1 => x ≠ x_1) on f)","name":"Function.Injective.pairwise_ne","isProp":true,"doc":"**Alias** of the forward direction of `Function.injective_iff_pairwise_ne`.","depth":12},{"type":"∀ {α : Type u_2} (self : MeasurableSpace.DynkinSystem α) {f : ℕ → Set α},\n  Pairwise (Disjoint on f) →\n    (∀ (i : ℕ), MeasurableSpace.DynkinSystem.Has self (f i)) → MeasurableSpace.DynkinSystem.Has self (⋃ i, f i)","name":"MeasurableSpace.DynkinSystem.has_iUnion_nat","isProp":true,"doc":"A Dynkin system is closed under countable union of pairwise disjoint sets. Use a more general\n`MeasurableSpace.DynkinSystem.has_iUnion` instead.","depth":15},{"type":"∀ {α : Type u} {β : Type v} {f : β → Set α},\n  Pairwise (Disjoint on f) →\n    ∀ {s : Set α}, (∀ (t : β), f t ⊆ s) → Set.Countable s → Set.Countable {t | Set.Nonempty (f t)}","name":"Set.countable_setOf_nonempty_of_disjoint","isProp":true,"doc":"If a family of disjoint sets is included in a countable set, then only countably many of\nthem are nonempty. ","depth":15}],"count":238}
{"noDocExamples":[],"kind":"MeasureTheory.«term∫_In_,_∂_»","examples":[{"type":"∀ {α : Type u_1} {m0 : MeasurableSpace α} {μ : MeasureTheory.Measure α} {f : α → ℝ},\n  MeasureTheory.StronglyMeasurable f →\n    MeasureTheory.Integrable f →\n      (∀ (s : Set α), MeasurableSet s → ↑↑μ s < ⊤ → 0 ≤ ∫ (x : α) in s, f x ∂μ) → 0 ≤ᶠ[MeasureTheory.Measure.ae μ] f","name":"MeasureTheory.ae_nonneg_of_forall_set_integral_nonneg_of_stronglyMeasurable","isProp":true,"doc":"Don't use this lemma. Use `ae_nonneg_of_forall_set_integral_nonneg`. ","depth":20},{"type":"∀ {α : Type u_1} {E : Type u_3} [inst : MeasurableSpace α] [inst_1 : NormedAddCommGroup E] {f : α → E} {s : Set α}\n  {μ : MeasureTheory.Measure α} [inst_2 : NormedSpace ℝ E],\n  f =ᶠ[MeasureTheory.Measure.ae (MeasureTheory.Measure.restrict μ sᶜ)] 0 → ∫ (ω : α) in s, f ω ∂μ = ∫ (ω : α), f ω ∂μ","name":"MeasureTheory.set_integral_eq_integral_of_ae_restrict_eq_zero","isProp":true,"doc":"If a function equals zero almost everywhere w.r.t. restriction of the measure to `sᶜ`, then its\nintegral on `s` coincides with its integral on the whole space. ","depth":21},{"type":"∀ {α : Type u_1} {E : Type u_3} [inst : MeasurableSpace α] [inst_1 : NormedAddCommGroup E] {f : α → E} {s : Set α}\n  {μ : MeasureTheory.Measure α} [inst_2 : NormedSpace ℝ E],\n  (∀ x ∉ s, f x = 0) → ∫ (x : α) in s, f x ∂μ = ∫ (x : α), f x ∂μ","name":"MeasureTheory.set_integral_eq_integral_of_forall_compl_eq_zero","isProp":true,"doc":"If a function vanishes on `sᶜ`, then its integral on `s` coincides with its integral on the\nwhole space. ","depth":21}],"count":235}
{"noDocExamples":[],"kind":"«term_<$>_»","examples":[{"type":"∀ (P : PFunctor.{u}) {α β : Type v} (f : α → β) (x : ↑P α), f <$> x = PFunctor.map P f x","name":"PFunctor.map_eq_map","isProp":true,"doc":"We prefer `PFunctor.map` to `Functor.map` because it is universe-polymorphic. ","depth":14},{"type":"∀ {α β γ : Type u} (f : α → β → γ) (a : Option α) (b : Option β), Option.map₂ f a b = Seq.seq (f <$> a) fun x => b","name":"Option.map₂_def","isProp":true,"doc":"`Option.map₂` in terms of monadic operations. Note that this can't be taken as the definition\nbecause of the lack of universe polymorphism. ","depth":15},{"type":"∀ {α β γ : Type u} (f : α → β → γ) (s : Set α) (t : Set β), Set.image2 f s t = Seq.seq (f <$> s) fun x => t","name":"Set.image2_def","isProp":true,"doc":"`Set.image2` in terms of monadic operations. Note that this can't be taken as the definition\nbecause of the lack of universe polymorphism. ","depth":15}],"count":232}
{"noDocExamples":[],"kind":"«term_≥_»","examples":[{"type":"∀ {μ : YoungDiagram},\n  YoungDiagram.ofRowLens (YoungDiagram.rowLens μ) (_ : List.Sorted (fun x x_1 => x ≥ x_1) (YoungDiagram.rowLens μ)) = μ","name":"YoungDiagram.ofRowLens_to_rowLens_eq_self","isProp":true,"doc":"The left_inv direction of the equivalence ","depth":6},{"type":"∀ {w : List ℕ} {hw : List.Sorted (fun x x_1 => x ≥ x_1) w} (i : Fin (List.length w)),\n  YoungDiagram.rowLen (YoungDiagram.ofRowLens w hw) ↑i = List.get w i","name":"YoungDiagram.rowLen_ofRowLens","isProp":true,"doc":"The length of the `i`th row in `ofRowLens w hw` is the `i`th entry of `w` ","depth":10},{"type":"∀ {w : List ℕ} {hw : List.Sorted (fun x x_1 => x ≥ x_1) w},\n  (∀ x ∈ w, 0 < x) → YoungDiagram.rowLens (YoungDiagram.ofRowLens w hw) = w","name":"YoungDiagram.rowLens_ofRowLens_eq_self","isProp":true,"doc":"The right_inv direction of the equivalence ","depth":10}],"count":230}
{"noDocExamples":[],"kind":"«term_→ᵃ[_]_»","examples":[{"type":"∀ {k : Type u_1} {V1 : Type u_2} {P1 : Type u_3} {V2 : Type u_4} {P2 : Type u_5} [inst : Ring k]\n  [inst_1 : AddCommGroup V1] [inst_2 : Module k V1] [inst_3 : AddTorsor V1 P1] [inst_4 : AddCommGroup V2]\n  [inst_5 : Module k V2] [inst_6 : AddTorsor V2 P2] {f g : P1 →ᵃ[k] P2}, (∀ (p : P1), f p = g p) → f = g","name":"AffineMap.ext","isProp":true,"doc":"Two affine maps are equal if they coerce to the same function. ","depth":36},{"type":"∀ {𝕜 : Type u_1} {V : Type u_2} {V₂ : Type u_4} {P : Type u_8} {P₂ : Type u_9} [inst : NormedField 𝕜]\n  [inst_1 : SeminormedAddCommGroup V] [inst_2 : SeminormedAddCommGroup V₂] [inst_3 : NormedSpace 𝕜 V]\n  [inst_4 : NormedSpace 𝕜 V₂] [inst_5 : PseudoMetricSpace P] [inst_6 : PseudoMetricSpace P₂]\n  [inst_7 : NormedAddTorsor V P] [inst_8 : NormedAddTorsor V₂ P₂] {f : P →ᵃ[𝕜] P₂}, IsOpenMap ⇑f.linear ↔ IsOpenMap ⇑f","name":"AffineMap.isOpenMap_linear_iff","isProp":true,"doc":"If `f` is an affine map, then its linear part is an open map iff `f` is an open map. ","depth":37},{"type":"{k : Type u_1} →\n  {V₁ : Type u_2} →\n    {V₂ : Type u_3} →\n      [inst : Ring k] →\n        [inst_1 : AddCommGroup V₁] →\n          [inst_2 : Module k V₁] → [inst_3 : AddCommGroup V₂] → [inst_4 : Module k V₂] → (V₁ →ₗ[k] V₂) → V₁ →ᵃ[k] V₂","name":"LinearMap.toAffineMap","isProp":false,"doc":"Reinterpret a linear map as an affine map. ","depth":21}],"count":219}
{"noDocExamples":[],"kind":"«term_[Λ^_]→ₗ[_]_»","examples":[{"type":"{R : Type u_1} →\n  {M : Type u_2} →\n    {N : Type u_3} →\n      {ι : Type u_4} →\n        [inst : Semiring R] →\n          [inst_1 : AddCommMonoid M] →\n            [inst_2 : Module R M] →\n              [inst_3 : TopologicalSpace M] →\n                [inst_4 : AddCommMonoid N] →\n                  [inst_5 : Module R N] → [inst_6 : TopologicalSpace N] → M[Λ^ι]→L[R]N → M [Λ^ι]→ₗ[R] N","name":"ContinuousAlternatingMap.toAlternatingMap","isProp":false,"doc":"Projection to `AlternatingMap`s. ","depth":23},{"type":"{R : Type u_1} →\n  [inst : Semiring R] →\n    {M : Type u_2} →\n      [inst_1 : AddCommMonoid M] →\n        [inst_2 : Module R M] →\n          {N : Type u_3} →\n            [inst_3 : AddCommMonoid N] →\n              [inst_4 : Module R N] →\n                {ι : Type u_7} →\n                  {S : Type u_10} →\n                    [inst_5 : Semiring S] →\n                      [inst_6 : Module S N] → [inst_7 : SMulCommClass R S N] → Module S (M [Λ^ι]→ₗ[R] N)","name":"AlternatingMap.module","isProp":false,"doc":"The space of multilinear maps over an algebra over `R` is a module over `R`, for the pointwise\naddition and scalar multiplication. ","depth":25},{"type":"∀ {R : Type u_1} [inst : Semiring R] {M : Type u_2} [inst_1 : AddCommMonoid M] [inst_2 : Module R M] {N : Type u_3}\n  [inst_3 : AddCommMonoid N] [inst_4 : Module R N] {ι : Type u_7} {M₂ : Type u_10} [inst_5 : AddCommMonoid M₂]\n  [inst_6 : Module R M₂] (f : M [Λ^ι]→ₗ[R] N) (g : M₂ ≃ₗ[R] M), AlternatingMap.compLinearMap f ↑g = 0 ↔ f = 0","name":"AlternatingMap.compLinearEquiv_eq_zero_iff","isProp":true,"doc":"Composing an alternating map with the same linear equiv on each argument gives the zero map\nif and only if the alternating map is the zero map. ","depth":34}],"count":218}
{"noDocExamples":[],"kind":"«term_→._»","examples":[{"type":"{α : Type u_1} → {β : Type u_2} → (α →. β) → Set β → Set α","name":"PFun.preimage","isProp":false,"doc":"Preimage of a set under a partial function. ","depth":5},{"type":"{α : Type u_1} → {β : Type u_2} → (α →. β ⊕ α) → α →. β","name":"PFun.fix","isProp":false,"doc":"First return map. Transforms a partial function `f : α →. β ⊕ α` into the partial function\n`α →. β` which sends `a : α` to the first value in `β` it hits by iterating `f`, if such a value\nexists. By abusing notation to illustrate, either `f a` is in the `β` part of `β ⊕ α` (in which\ncase `f.fix a` returns `f a`), or it is undefined (in which case `f.fix a` is undefined as well), or\nit is in the `α` part of `β ⊕ α` (in which case we repeat the procedure, so `f.fix a` will return\n`f.fix (f a)`). ","depth":6},{"type":"{α : Type u_1} → {β : Type u_2} → [inst : TopologicalSpace α] → [inst : TopologicalSpace β] → (α →. β) → Prop","name":"PContinuous","isProp":false,"doc":"Continuity of a partial function ","depth":7}],"count":209}
{"noDocExamples":[],"kind":"«term∫_In_.._,_»","examples":[{"type":"∀ (n : ℕ), ∫ (x : ℝ) in 0 ..Real.pi / 2, Real.cos x ^ n = 1 / 2 * ∫ (x : ℝ) in 0 ..Real.pi, Real.sin x ^ n","name":"EulerSine.integral_cos_pow_eq","isProp":true,"doc":"Relate the integral `cos x ^ n` over `[0, π/2]` to the integral of `sin x ^ n` over `[0, π]`,\nwhich is studied in `Data.Real.Pi.Wallis` and other places. ","depth":14},{"type":"∀ {a b : ℝ}, ∫ (x : ℝ) in a..b, Real.sin x * Real.cos x = (Real.cos a ^ 2 - Real.cos b ^ 2) / 2","name":"integral_sin_mul_cos₂","isProp":true,"doc":"The integral of `sin x * cos x`, given in terms of cos².\nSee `integral_sin_mul_cos₁` above for the integral given in terms of sin². ","depth":15},{"type":"∀ {a b : ℝ}, ∫ (x : ℝ) in a..b, Real.sin x * Real.cos x = (Real.sin b ^ 2 - Real.sin a ^ 2) / 2","name":"integral_sin_mul_cos₁","isProp":true,"doc":"The integral of `sin x * cos x`, given in terms of sin².\nSee `integral_sin_mul_cos₂` below for the integral given in terms of cos². ","depth":15}],"count":207}
{"noDocExamples":[],"kind":"Filter.«term_≤ᶠ[_]_»","examples":[{"type":"∀ {α : Type u_2} {_m0 : MeasurableSpace α} ⦃s s' : Set α⦄ ⦃μ ν : MeasureTheory.Measure α⦄,\n  s ≤ᶠ[MeasureTheory.Measure.ae μ] s' → μ ≤ ν → MeasureTheory.Measure.restrict μ s ≤ MeasureTheory.Measure.restrict ν s'","name":"MeasureTheory.Measure.restrict_mono'","isProp":true,"doc":"Restriction of a measure to a subset is monotone both in set and in measure. ","depth":16},{"type":"∀ {α : Type u_1} {m : MeasurableSpace α} {μ : MeasureTheory.Measure α} {f : MeasureTheory.SimpleFunc α ℝ},\n  MeasureTheory.Integrable ↑f →\n    0 ≤ᶠ[MeasureTheory.Measure.ae μ] ↑f →\n      MeasureTheory.SimpleFunc.integral μ f = ENNReal.toReal (∫⁻ (a : α), ENNReal.ofReal (↑f a) ∂μ)","name":"MeasureTheory.SimpleFunc.integral_eq_lintegral","isProp":true,"doc":"`SimpleFunc.bintegral` and `SimpleFunc.integral` agree when the integrand has type\n`α →ₛ ℝ≥0∞`. But since `ℝ≥0∞` is not a `NormedSpace`, we need some form of coercion. ","depth":16},{"type":"∀ {α : Type u_1} [inst : MeasurableSpace α] {μ : MeasureTheory.Measure α} {s t : Set α},\n  s ≤ᶠ[MeasureTheory.Measure.ae μ] t → ↑↑μ s ≤ ↑↑μ t","name":"MeasureTheory.measure_mono_ae","isProp":true,"doc":"If `s ⊆ t` modulo a set of measure `0`, then `μ s ≤ μ t`. ","depth":16}],"count":205}
{"noDocExamples":[],"kind":"«term_→ₗ.[_]_»","examples":[{"type":"{𝕜 : Type u_1} →\n  {E : Type u_2} →\n    {F : Type u_3} →\n      [inst : IsROrC 𝕜] →\n        [inst_1 : NormedAddCommGroup E] →\n          [inst_2 : InnerProductSpace 𝕜 E] →\n            [inst_3 : NormedAddCommGroup F] → [inst_4 : InnerProductSpace 𝕜 F] → (E →ₗ.[𝕜] F) → (F →ₗ.[𝕜] E) → Prop","name":"LinearPMap.IsFormalAdjoint","isProp":false,"doc":"An operator `T` is a formal adjoint of `S` if for all `x` in the domain of `T` and `y` in the\ndomain of `S`, we have that `⟪T x, y⟫ = ⟪x, S y⟫`. ","depth":23},{"type":"∀ {R : Type u_1} [inst : Ring R] {E : Type u_2} [inst_1 : AddCommGroup E] [inst_2 : Module R E] {F : Type u_3}\n  [inst_3 : AddCommGroup F] [inst_4 : Module R F] (f : E →ₗ.[R] F),\n  LinearPMap.graph (-f) = Submodule.map (LinearMap.prodMap LinearMap.id (-LinearMap.id)) (LinearPMap.graph f)","name":"LinearPMap.neg_graph","isProp":true,"doc":"The graph of `-f` as a pushforward. ","depth":28},{"type":"∀ {R : Type u_1} [inst : Ring R] {E : Type u_2} [inst_1 : AddCommGroup E] [inst_2 : Module R E] {F : Type u_3}\n  [inst_3 : AddCommGroup F] [inst_4 : Module R F] (f : E →ₗ.[R] F) (x : ↥f.domain), (↑x, ↑f x) ∈ LinearPMap.graph f","name":"LinearPMap.mem_graph","isProp":true,"doc":"The tuple `(x, f x)` is contained in the graph of `f`. ","depth":28}],"count":194}
{"noDocExamples":[],"kind":"«term_⊂_»","examples":[{"type":"∀ {α : Type u} {s : Set α}, Set.Nonempty s → ∅ ⊂ s","name":"Set.Nonempty.empty_ssubset","isProp":true,"doc":"**Alias** of the reverse direction of `Set.empty_ssubset`.","depth":8},{"type":"∀ {α : Type u_1} {s : Finset α}, Finset.Nonempty s → ∅ ⊂ s","name":"Finset.Nonempty.empty_ssubset","isProp":true,"doc":"**Alias** of the reverse direction of `Finset.empty_ssubset`.","depth":8},{"type":"∀ {α : Type u} [inst : HasSSubset α] [inst_1 : IsIrrefl α fun x x_1 => x ⊂ x_1] {a b : α}, a ⊂ b → a ≠ b","name":"HasSSubset.SSubset.ne","isProp":true,"doc":"**Alias** of `ne_of_ssubset`.","depth":10}],"count":193}
{"noDocExamples":[],"kind":"MeasureTheory.«term_→ₘ[_]_»","examples":[{"type":"{α : Type u_1} → [inst : MeasurableSpace α] → {μ : MeasureTheory.Measure α} → (α →ₘ[μ] ENNReal) → ENNReal","name":"MeasureTheory.AEEqFun.lintegral","isProp":false,"doc":"For `f : α → ℝ≥0∞`, define `∫ [f]` to be `∫ f` ","depth":9},{"type":"{α : Type u_1} →\n  {β : Type u_2} →\n    [inst : MeasurableSpace α] → {μ : MeasureTheory.Measure α} → [inst_1 : TopologicalSpace β] → (α →ₘ[μ] β) → α → β","name":"MeasureTheory.AEEqFun.cast","isProp":false,"doc":"Coercion from a space of equivalence classes of almost everywhere strongly measurable\nfunctions to functions. ","depth":11},{"type":"(α : Type u_1) →\n  {β : Type u_2} →\n    [inst : MeasurableSpace α] → {μ : MeasureTheory.Measure α} → [inst_1 : TopologicalSpace β] → β → α →ₘ[μ] β","name":"MeasureTheory.AEEqFun.const","isProp":false,"doc":"The equivalence class of a constant function: `[fun _ : α => b]`, based on the equivalence\nrelation of being almost everywhere equal ","depth":11}],"count":193}
{"noDocExamples":[],"kind":"«term⅟_»","examples":[{"type":"∀ {α : Type u} [inst : Mul α] [inst_1 : One α] {a : α} [self : Invertible a], ⅟a * a = 1","name":"Invertible.invOf_mul_self","isProp":true,"doc":"`invOf a` is a left inverse of `a` ","depth":14},{"type":"∀ {α : Type u} [inst : Monoid α] (a b : α) [inst_1 : Invertible a] [inst_2 : Invertible b], a = b → ⅟a = ⅟b","name":"Invertible.congr","isProp":true,"doc":"If `a` is invertible and `a = b`, then `⅟a = ⅟b`. ","depth":16},{"type":"∀ {k : Type u} [inst : Field k] {G : GroupCat} [inst_1 : IsAlgClosed k] [inst_2 : Fintype ↑G]\n  [inst_3 : Invertible ↑(Fintype.card ↑G)] (V W : FdRep k ↑G) [inst_4 : CategoryTheory.Simple V]\n  [inst_5 : CategoryTheory.Simple W],\n  (⅟↑(Fintype.card ↑G) • Finset.sum Finset.univ fun g => FdRep.character V g * FdRep.character W g⁻¹) =\n    if Nonempty (V ≅ W) then 1 else 0","name":"FdRep.char_orthonormal","isProp":true,"doc":"Orthogonality of characters for irreducible representations of finite group over an\nalgebraically closed field whose characteristic doesn't divide the order of the group. ","depth":26}],"count":189}
{"noDocExamples":[],"kind":"«term_→ₗ⁅_⁆_»","examples":[{"type":"(R : Type u) →\n  (ι : Type v) →\n    [inst : CommRing R] →\n      (L : ι → Type w) →\n        [inst_1 : (i : ι) → LieRing (L i)] →\n          [inst_2 : (i : ι) → LieAlgebra R (L i)] →\n            [inst_3 : DecidableEq ι] → (j : ι) → L j →ₗ⁅R⁆ DirectSum ι fun i => L i","name":"DirectSum.lieAlgebraOf","isProp":false,"doc":"The inclusion of each component into the direct sum as morphism of Lie algebras. ","depth":22},{"type":"{R : Type u_1} →\n  {L : Type u_2} →\n    {L' : Type u_3} →\n      [inst : CommRing R] →\n        [inst_1 : LieRing L] →\n          [inst_2 : LieAlgebra R L] →\n            [inst_3 : LieRing L'] →\n              [inst_4 : LieAlgebra R L'] → (f : L →ₗ⁅R⁆ L') → (L ⧸ LieHom.ker f) ≃ₗ⁅R⁆ ↥(LieHom.range f)","name":"LieHom.quotKerEquivRange","isProp":false,"doc":"The first isomorphism theorem for morphisms of Lie algebras. ","depth":28},{"type":"∀ {R : Type u_1} {L : Type u_2} {L' : Type u_3} [inst : CommRing R] [inst_1 : LieRing L] [inst_2 : LieAlgebra R L]\n  [inst_3 : LieRing L'] [inst_4 : LieAlgebra R L'] (self : L →ₗ⁅R⁆ L') {x y : L},\n  AddHom.toFun self.toAddHom ⁅x, y⁆ = ⁅AddHom.toFun self.toAddHom x, AddHom.toFun self.toAddHom y⁆","name":"LieHom.map_lie'","isProp":true,"doc":"A morphism of Lie algebras is compatible with brackets. ","depth":29}],"count":188}
{"noDocExamples":[],"kind":"Matrix.vecNotation","examples":[{"type":"∀ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {p₁ p₂ p₃ : P}, AffineIndependent k ![p₁, p₂, p₃] ↔ ¬Collinear k {p₁, p₂, p₃}","name":"affineIndependent_iff_not_collinear_set","isProp":true,"doc":"Three points are affinely independent if and only if they are not collinear. ","depth":21},{"type":"∀ {K : Type u_2} {V : Type u_3} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  (u v : Projectivization K V), Projectivization.Dependent ![u, v] ↔ u = v","name":"Projectivization.dependent_pair_iff_eq","isProp":true,"doc":"Two points in a projective space are dependent if and only if they are equal. ","depth":22},{"type":"∀ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] [inst_2 : MetricSpace P]\n  [inst_3 : NormedAddTorsor V P] {p₁ p₂ p₃ : P},\n  EuclideanGeometry.Cospherical {p₁, p₂, p₃} → p₁ ≠ p₂ → p₁ ≠ p₃ → p₂ ≠ p₃ → AffineIndependent ℝ ![p₁, p₂, p₃]","name":"EuclideanGeometry.Cospherical.affineIndependent_of_ne","isProp":true,"doc":"The three points of a cospherical set are affinely independent. ","depth":23}],"count":187}
{"noDocExamples":[],"kind":"«term_>_»","examples":[{"type":"∀ (b o : Ordinal.{u_1}), List.Sorted (fun x x_1 => x > x_1) (List.map Prod.fst (Ordinal.CNF b o))","name":"Ordinal.CNF_sorted","isProp":true,"doc":"The exponents of the Cantor normal form are decreasing. ","depth":12},{"type":"∀ {α : Type u} [inst : LT α] [inst_1 : WellFoundedGT α] (a : α), Acc (fun x x_1 => x > x_1) a","name":"WellFoundedGT.apply","isProp":true,"doc":"All values are accessible under the well-founded `>`. ","depth":12},{"type":"∀ {n : ℕ}, n > 0 → ∀ {i j : ℕ}, i ≤ j → n ^ i ≤ n ^ j","name":"Nat.pow_le_pow_right","isProp":true,"doc":"**Alias** of `Nat.pow_le_pow_of_le_right`.","depth":13}],"count":187}
{"noDocExamples":[],"kind":"Lean.Parser.Term.let","examples":[{"type":"Lean.Expr →\n  Lean.MetaM\n    ((u : Lean.Level) ×\n      (α :\n        let u := u;\n        Q(Type u)) ×\n        Q(«$α»))","name":"Qq.inferTypeQ'","isProp":false,"doc":"Variant of `inferTypeQ` that yields a type in `Type u` rather than `Sort u`.\nThrows an error if the type is a `Prop` or if it's otherwise not possible to represent\nthe universe as `Type u` (for example due to universe level metavariables). ","depth":10},{"type":"{u : Lean.Level} →\n  ℕ →\n    {α :\n        let u := u;\n        Q(Type u)} →\n      Q(Semiring «$α») → Q(«$α») → Q(«$α»)","name":"Linarith.mulExpr'","isProp":false,"doc":"A typesafe version of `mulExpr`. ","depth":11},{"type":"{α : Type u} →\n  {β : Type v} →\n    (R : Type u_1) →\n      [inst : Semiring R] →\n        (e : α ≃ β) →\n          [inst_1 : AddCommMonoid β] →\n            let addCommMonoid := Equiv.addCommMonoid e;\n            [inst_2 : Module R β] → Module R α","name":"Equiv.module","isProp":false,"doc":"Transfer `Module` across an `Equiv` ","depth":12}],"count":184}
{"noDocExamples":[],"kind":"«term_⋖_»","examples":[{"type":"∀ {a b : ℕ}, a ⋖ b → ↑a ⋖ ↑b","name":"Covby.cast_int","isProp":true,"doc":"**Alias** of the reverse direction of `Nat.cast_int_covby_iff`.","depth":8},{"type":"∀ {n : ℕ} {a b : Fin n}, a ⋖ b → ↑a ⋖ ↑b","name":"Covby.coe_fin","isProp":true,"doc":"**Alias** of the reverse direction of `Fin.coe_covby_iff`.","depth":9},{"type":"∀ {α : Type u_1} [inst : LT α] {a b : α} [inst_1 : DenselyOrdered α], ¬a ⋖ b","name":"not_covby","isProp":true,"doc":"In a dense order, nothing covers anything. ","depth":10}],"count":181}
{"noDocExamples":[],"kind":"«term∃!_,_»","examples":[{"type":"∀ {α : Type u_1} (r : Setoid α), Setoid.mkClasses (Setoid.classes r) (_ : ∀ (a : α), ∃! b x, a ∈ b) = r","name":"Setoid.mkClasses_classes","isProp":true,"doc":"The equivalence relation made from the equivalence classes of an equivalence\nrelation r equals r. ","depth":8},{"type":"∀ {α : Sort u_1} {β : Sort u_2} {f : α → β}, Function.Bijective f → ∀ (b : β), ∃! a, f a = b","name":"Function.Bijective.existsUnique","isProp":true,"doc":"Shorthand for using projection notation with `Function.bijective_iff_existsUnique`. ","depth":10},{"type":"∀ {α : Sort u_1} {r : α → α → Prop},\n  Symmetric r → ((∀ (a : α), ∃! b, r a b) ↔ ∃ f, Function.Involutive f ∧ ∀ {a b : α}, r a b ↔ f a = b)","name":"Symmetric.forall_existsUnique_iff","isProp":true,"doc":"A symmetric relation `r : α → α → Prop` is \"function-like\"\n(for each `a` there exists a unique `b` such that `r a b`)\nif and only if it is `(f · = ·)` for some involutive function `f`. ","depth":13}],"count":181}
{"noDocExamples":[],"kind":"Set.«term⋃₀_»","examples":[{"type":"∀ {α : Type u} [t : TopologicalSpace α] {s : Set (Set α)}, TopologicalSpace.IsTopologicalBasis s → ⋃₀ s = Set.univ","name":"TopologicalSpace.IsTopologicalBasis.sUnion_eq","isProp":true,"doc":"The sets from `s` cover the whole space. ","depth":8},{"type":"∀ {α : Type u_1} {S T : Set (Set α)}, S ⊆ T → ⋃₀ S ⊆ ⋃₀ T","name":"Set.sUnion_mono","isProp":true,"doc":"**Alias** of `Set.sUnion_subset_sUnion`.","depth":10},{"type":"∀ {α : Type u_1} {S : Set (Set α)}, S ⊆ {∅, Set.univ} → ⋃₀ S ∈ {∅, Set.univ}","name":"Set.sUnion_mem_empty_univ","isProp":true,"doc":"If all sets in a collection are either `∅` or `Set.univ`, then so is their union. ","depth":10}],"count":171}
{"noDocExamples":[],"kind":"«termℤ√_»","examples":[{"type":"∀ {d : ℤ} {a : ℤ√d}, Zsqrtd.norm a = 1 ↔ a ∈ unitary (ℤ√d)","name":"Zsqrtd.norm_eq_one_iff_mem_unitary","isProp":true,"doc":"An element of `ℤ√d` has norm equal to `1` if and only if it is contained in the submonoid\nof unitary elements. ","depth":13},{"type":"{d : ℤ} → ℤ√d","name":"Zsqrtd.sqrtd","isProp":false,"doc":"The representative of `√d` in the ring ","depth":2},{"type":"{d : ℤ} → Zero (ℤ√d)","name":"Zsqrtd.instZeroZsqrtd","isProp":false,"doc":"The zero of the ring ","depth":3}],"count":162}
{"noDocExamples":[{"type":"∀ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] {X Y : C} (α : X ≅ Y), α ≪≫ CategoryTheory.Iso.refl Y = α","name":"CategoryTheory.Iso.trans_refl","isProp":true,"depth":14}],"kind":"CategoryTheory.Iso.«term_≪≫_»","examples":[{"type":"∀ {B : Type u} [inst : CategoryTheory.Bicategory B] {a b : B} (self : CategoryTheory.Bicategory.Equivalence a b),\n  CategoryTheory.Bicategory.leftZigzagIso self.unit self.counit =\n    CategoryTheory.Bicategory.leftUnitor self.hom ≪≫ (CategoryTheory.Bicategory.rightUnitor self.hom).symm","name":"CategoryTheory.Bicategory.Equivalence.left_triangle","isProp":true,"doc":"The composition of the unit and the counit is equal to the identity up to unitors. ","depth":19},{"type":"∀ {C : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} C] {D : Type u₂} [inst_1 : CategoryTheory.Category.{v₂, u₂} D]\n  {F G H : CategoryTheory.Functor C D} (e : F ≅ G) (e' : G ≅ H) (hF : CategoryTheory.IsEquivalence F),\n  CategoryTheory.IsEquivalence.ofIso e' (CategoryTheory.IsEquivalence.ofIso e hF) =\n    CategoryTheory.IsEquivalence.ofIso (e ≪≫ e') hF","name":"CategoryTheory.IsEquivalence.ofIso_trans","isProp":true,"doc":"Compatibility of `ofIso` with the composition of isomorphisms of functors ","depth":24}],"count":160}
{"noDocExamples":[],"kind":"«term_∆_»","examples":[{"type":"∀ {r s : ℝ},\n  Real.IsConjugateExponent r s → {x | ∃ k > 0, beattySeq r k = x} ∆ {x | ∃ k > 0, beattySeq' s k = x} = {n | 0 < n}","name":"beattySeq_symmDiff_beattySeq'_pos","isProp":true,"doc":"Generalization of Rayleigh's theorem on Beatty sequences. Let `r` be a real number greater\nthan 1, and `1/r + 1/s = 1`. Then `B⁺_r` and `B⁺'_s` partition the positive integers. ","depth":17},{"type":"∀ {r s : ℝ},\n  Real.IsConjugateExponent r s →\n    Irrational r → {x | ∃ k > 0, beattySeq r k = x} ∆ {x | ∃ k > 0, beattySeq s k = x} = {n | 0 < n}","name":"Irrational.beattySeq_symmDiff_beattySeq_pos","isProp":true,"doc":"**Rayleigh's theorem** on Beatty sequences. Let `r` be an irrational number greater than 1, and\n`1/r + 1/s = 1`. Then `B⁺_r` and `B⁺_s` partition the positive integers. ","depth":18},{"type":"∀ {α : Type u_1} [inst : MeasurableSpace α] {s : MeasureTheory.SignedMeasure α} {u v : Set α},\n  MeasurableSet u →\n    MeasurableSet v →\n      MeasureTheory.VectorMeasure.restrict 0 u ≤ MeasureTheory.VectorMeasure.restrict s u →\n        MeasureTheory.VectorMeasure.restrict 0 v ≤ MeasureTheory.VectorMeasure.restrict s v →\n          ↑s (u ∆ v) = 0 → ↑s (u \\ v) = 0 ∧ ↑s (v \\ u) = 0","name":"MeasureTheory.SignedMeasure.of_diff_eq_zero_of_symmDiff_eq_zero_positive","isProp":true,"doc":"If the symmetric difference of two positive sets is a null-set, then so are the differences\nbetween the two sets. ","depth":25}],"count":159}
{"noDocExamples":[],"kind":"MeasureTheory.«term∫⁻_In_,_∂_»","examples":[{"type":"∀ {α : Type u_1} {mα : MeasurableSpace α} (ρ : MeasureTheory.Measure (α × ℝ)) [inst : MeasureTheory.IsFiniteMeasure ρ]\n  (r : ℚ) {s : Set α},\n  MeasurableSet s →\n    ∫⁻ (a : α) in s, ENNReal.ofReal (↑(ProbabilityTheory.condCdf ρ a) ↑r) ∂MeasureTheory.Measure.fst ρ =\n      ↑↑ρ (s ×ˢ Set.Iic ↑r)","name":"ProbabilityTheory.set_lintegral_condCdf_rat","isProp":true,"doc":"Auxiliary lemma for `set_lintegral_cond_cdf`. ","depth":18},{"type":"∀ {α : Type u_1} {m : MeasurableSpace α} {μ : MeasureTheory.Measure α} {ι : Type u_5} {f : α → ENNReal},\n  ∫⁻ (x : α), f x ∂μ ≠ ⊤ →\n    ∀ {l : Filter ι} {s : ι → Set α},\n      Filter.Tendsto (↑↑μ ∘ s) l (nhds 0) → Filter.Tendsto (fun i => ∫⁻ (x : α) in s i, f x ∂μ) l (nhds 0)","name":"MeasureTheory.tendsto_set_lintegral_zero","isProp":true,"doc":"If `f` has finite integral, then `∫⁻ x in s, f x ∂μ` is absolutely continuous in `s`: it tends\nto zero as `μ s` tends to zero. ","depth":19},{"type":"∀ {α : Type u_1} [inst : MeasurableSpace α] {μ : MeasureTheory.Measure α} [inst_1 : MeasureTheory.SigmaFinite μ]\n  (C : ENNReal) {f : α → ENNReal},\n  AEMeasurable f → (∀ (s : Set α), MeasurableSet s → ↑↑μ s ≠ ⊤ → ∫⁻ (x : α) in s, f x ∂μ ≤ C) → ∫⁻ (x : α), f x ∂μ ≤ C","name":"MeasureTheory.lintegral_le_of_forall_fin_meas_le","isProp":true,"doc":"If the Lebesgue integral of a function is bounded by some constant on all sets with finite\nmeasure and the measure is σ-finite, then the integral over the whole space is bounded by that same\nconstant. ","depth":21}],"count":156}
{"noDocExamples":[],"kind":"Multiset.«term_::ₘ_»","examples":[{"type":"{α : Type u_1} →\n  [inst : DecidableEq α] →\n    {δ : α → Sort v} → (m : Multiset α) → (a : α) → δ a → ((a : α) → a ∈ m → δ a) → (a' : α) → a' ∈ a ::ₘ m → δ a'","name":"Multiset.Pi.cons","isProp":false,"doc":"Given `δ : α → Type*`, a multiset `m` and a term `a`, as well as a term `b : δ a` and a\nfunction `f` such that `f a' : δ a'` for all `a'` in `m`, `Pi.cons m a b f` is a function `g` such\nthat `g a'' : δ a''` for all `a''` in `a ::ₘ m`. ","depth":14},{"type":"{α : Type u_1} →\n  {C : Multiset α → Sort u_3} →\n    C 0 →\n      (C_cons : (a : α) → (m : Multiset α) → C m → C (a ::ₘ m)) →\n        (∀ (a a' : α) (m : Multiset α) (b : C m),\n            HEq (C_cons a (a' ::ₘ m) (C_cons a' m b)) (C_cons a' (a ::ₘ m) (C_cons a m b))) →\n          (m : Multiset α) → C m","name":"Multiset.rec","isProp":false,"doc":"Dependent recursor on multisets.\nTODO: should be @[recursor 6], but then the definition of `Multiset.pi` fails with a stack\noverflow in `whnf`.\n","depth":18},{"type":"∀ {A : Type u_2} [inst : CommRing A] [inst_1 : IsDomain A] [inst_2 : IsDedekindDomain A],\n  ¬IsField A →\n    ∀ {I M : Ideal A},\n      I ≠ ⊥ →\n        I ≤ M →\n          ∀ [hM : Ideal.IsMaximal M],\n            ∃ Z,\n              Multiset.prod (M ::ₘ Multiset.map PrimeSpectrum.asIdeal Z) ≤ I ∧\n                ¬Multiset.prod (Multiset.map PrimeSpectrum.asIdeal Z) ≤ I","name":"exists_multiset_prod_cons_le_and_prod_not_le","isProp":true,"doc":"Specialization of `exists_primeSpectrum_prod_le_and_ne_bot_of_domain` to Dedekind domains:\nLet `I : Ideal A` be a nonzero ideal, where `A` is a Dedekind domain that is not a field.\nThen `exists_primeSpectrum_prod_le_and_ne_bot_of_domain` states we can find a product of prime\nideals that is contained within `I`. This lemma extends that result by making the product minimal:\nlet `M` be a maximal ideal that contains `I`, then the product including `M` is contained within `I`\nand the product excluding `M` is not contained within `I`. ","depth":29}],"count":153}
{"noDocExamples":[],"kind":"«term_≃ᵐ_»","examples":[{"type":"{α : Type u_1} → {β : Type u_2} → [inst : MeasurableSpace α] → [inst_1 : MeasurableSpace β] → α ≃ᵐ β → β → α","name":"MeasurableEquiv.Simps.symm_apply","isProp":false,"doc":"See Note [custom simps projection] ","depth":9},{"type":"(α : Type u_8) → (β : Type u_9) → [inst : Unique α] → [inst : MeasurableSpace β] → (α → β) ≃ᵐ β","name":"MeasurableEquiv.funUnique","isProp":false,"doc":"If `α` has a unique term, then the type of function `α → β` is measurably equivalent to `β`. ","depth":9},{"type":"{G : Type u_1} → [inst : MeasurableSpace G] → [inst_1 : Group G] → [inst_2 : MeasurableMul G] → G → G ≃ᵐ G","name":"MeasurableEquiv.divRight","isProp":false,"doc":"`equiv.divRight` as a `MeasurableEquiv`. ","depth":10}],"count":153}
{"noDocExamples":[],"kind":"«term_→ₗ⁅_,_⁆_»","examples":[{"type":"{R : Type u} →\n  {L : Type v} →\n    {M : Type w} →\n      {N : Type w₁} →\n        [inst : CommRing R] →\n          [inst_1 : LieRing L] →\n            [inst_2 : LieAlgebra R L] →\n              [inst_3 : AddCommGroup M] →\n                [inst_4 : Module R M] →\n                  [inst_5 : LieRingModule L M] →\n                    [inst_6 : LieModule R L M] →\n                      [inst_7 : AddCommGroup N] →\n                        [inst_8 : Module R N] →\n                          [inst_9 : LieRingModule L N] →\n                            [inst_10 : LieModule R L N] →\n                              (M →ₗ⁅R,L⁆ N) →\n                                ↥↑(LieModule.maxTrivSubmodule R L M) →ₗ⁅R,L⁆ ↥↑(LieModule.maxTrivSubmodule R L N)","name":"LieModule.maxTrivHom","isProp":false,"doc":"`maxTrivSubmodule` is functorial. ","depth":40},{"type":"∀ {R : Type u} {L : Type v} {M : Type w} [inst : CommRing R] [inst_1 : LieRing L] [inst_2 : LieAlgebra R L]\n  [inst_3 : AddCommGroup M] [inst_4 : Module R M] [inst_5 : LieRingModule L M] [inst_6 : LieModule R L M]\n  (N : LieSubmodule R L M) ⦃f g : M ⧸ N →ₗ⁅R,L⁆ M⦄,\n  LieModuleHom.comp f (LieSubmodule.Quotient.mk' N) = LieModuleHom.comp g (LieSubmodule.Quotient.mk' N) → f = g","name":"LieSubmodule.Quotient.lieModuleHom_ext","isProp":true,"doc":"Two `LieModuleHom`s from a quotient lie module are equal if their compositions with\n`LieSubmodule.Quotient.mk'` are equal.\n\nSee note [partially-applied ext lemmas]. ","depth":42},{"type":"{R : Type u} →\n  {L : Type v} →\n    {M : Type w} →\n      [inst : CommRing R] →\n        [inst_1 : LieRing L] →\n          [inst_2 : AddCommGroup M] → [inst_3 : Module R M] → [inst_4 : LieRingModule L M] → M →ₗ⁅R,L⁆ M","name":"LieModuleHom.id","isProp":false,"doc":"The identity map is a morphism of Lie modules. ","depth":20}],"count":153}
{"noDocExamples":[],"kind":"«term_≃L[_]_»","examples":[{"type":"∀ {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] {F : Type u_3} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F]\n  (p : FormalMultilinearSeries 𝕜 E F) (i : E ≃L[𝕜] F),\n  FormalMultilinearSeries.leftInv (FormalMultilinearSeries.removeZero p) i = FormalMultilinearSeries.leftInv p i","name":"FormalMultilinearSeries.leftInv_removeZero","isProp":true,"doc":"The left inverse does not depend on the zeroth coefficient of a formal multilinear\nseries. ","depth":36},{"type":"{R₁ : Type u_1} →\n  [inst : Semiring R₁] →\n    (M₁ : Type u_4) →\n      [inst_1 : TopologicalSpace M₁] → [inst_2 : AddCommMonoid M₁] → [inst_3 : Module R₁ M₁] → Group (M₁ ≃L[R₁] M₁)","name":"ContinuousLinearEquiv.automorphismGroup","isProp":false,"doc":"The continuous linear equivalences from `M` to itself form a group under composition. ","depth":23},{"type":"(ι : Type u_1) → (𝕜 : Type u_3) → [inst : IsROrC 𝕜] → [inst_1 : Fintype ι] → EuclideanSpace 𝕜 ι ≃L[𝕜] ι → 𝕜","name":"EuclideanSpace.equiv","isProp":false,"doc":"A shorthand for `PiLp.continuousLinearEquiv`. ","depth":25}],"count":150}
{"noDocExamples":[],"kind":"«term_⇨_»","examples":[{"type":"∀ {α : Type u} [self : BooleanAlgebra α] (x y : α), x ⇨ y = y ⊔ xᶜ","name":"BooleanAlgebra.himp_eq","isProp":true,"doc":"`x ⇨ y` is equal to `y ⊔ xᶜ` ","depth":13},{"type":"∀ {α : Type u} [self : CompleteAtomicBooleanAlgebra α] (x y : α), x ⇨ y = y ⊔ xᶜ","name":"CompleteAtomicBooleanAlgebra.himp_eq","isProp":true,"doc":"`x ⇨ y` is equal to `y ⊔ xᶜ` ","depth":14},{"type":"∀ {α : Type u_2} [inst : GeneralizedHeytingAlgebra α] {a b c : α}, Codisjoint a c → b ≤ a → c ⇨ b ≤ a","name":"Codisjoint.himp_le_of_right_le","isProp":true,"doc":"See `himp_le` for a stronger version in Boolean algebras. ","depth":16}],"count":148}
{"noDocExamples":[],"kind":"Filter.«term∃ᶠ_In_,_»","examples":[{"type":"∀ {α : Type u} {f : Ultrafilter α} {p : α → Prop}, (∃ᶠ (x : α) in ↑f, p x) → ∀ᶠ (x : α) in ↑f, p x","name":"Filter.Frequently.eventually","isProp":true,"doc":"**Alias** of the forward direction of `Ultrafilter.frequently_iff_eventually`.","depth":8},{"type":"∀ {n : ℕ}, n ≠ 0 → ∀ (d : ℕ), ∃ᶠ (m : ℕ) in Filter.atTop, m ≡ d [MOD n]","name":"Nat.frequently_modEq","isProp":true,"doc":"Infinitely many natural numbers are equal to `d` mod `n`. ","depth":9},{"type":"∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α} {a : α}, (∃ᶠ (x : α) in nhds a, x ∈ s) → a ∈ closure s","name":"Filter.Frequently.mem_closure","isProp":true,"doc":"**Alias** of the reverse direction of `mem_closure_iff_frequently`.","depth":13}],"count":148}
{"noDocExamples":[],"kind":"«term_→ₙ+*_»","examples":[{"type":"(α : Type u_1) → (β : Type u_2) → [inst : NonUnitalNonAssocSemiring β] → β →ₙ+* α → β","name":"Pi.constNonUnitalRingHom","isProp":false,"doc":"`Function.const` as a `NonUnitalRingHom`. ","depth":7},{"type":"{R : Type u} →\n  {S : Type v} →\n    [inst : NonUnitalNonAssocRing R] → [inst_1 : NonUnitalNonAssocRing S] → (R →ₙ+* S) → (R →ₙ+* S) → NonUnitalSubring R","name":"NonUnitalRingHom.eqLocus","isProp":false,"doc":"The `NonUnitalSubring` of elements `x : R` such that `f x = g x`, i.e.,\nthe equalizer of f and g as a `NonUnitalSubring` of R ","depth":10},{"type":"{α : Type u_1} →\n  {β : Type u_2} →\n    [inst : NonUnitalNonAssocSemiring α] → [inst_1 : NonUnitalNonAssocSemiring β] → (αᵐᵒᵖ →ₙ+* βᵐᵒᵖ) ≃ (α →ₙ+* β)","name":"NonUnitalRingHom.unop","isProp":false,"doc":"The 'unopposite' of a non-unital ring hom `αᵐᵒᵖ →ₙ+* βᵐᵒᵖ`. Inverse to\n`NonUnitalRingHom.op`. ","depth":11}],"count":144}
{"noDocExamples":[],"kind":"Lean.Parser.Term.explicit","examples":[{"type":"RingHom.LocalizationPreserves @RingHom.Finite","name":"localization_finite","isProp":true,"doc":"If `S` is a finite `R`-algebra, then `S' = M⁻¹S` is a finite `R' = M⁻¹R`-algebra. ","depth":1},{"type":"CategoryTheory.UnbundledHom @UniformContinuous","name":"UniformSpaceCat.instUnbundledHomTypeUniformSpaceUniformContinuous","isProp":true,"doc":"The information required to build morphisms for `UniformSpace`. ","depth":4},{"type":"∀ {α : Type u_1} {γ : Type u_3}, Monotone (@UniformFun.uniformSpace α γ)","name":"UniformFun.mono","isProp":true,"doc":"If `u₁` and `u₂` are two uniform structures on `γ` and `u₁ ≤ u₂`, then\n`𝒰(α, γ, u₁) ≤ 𝒰(α, γ, u₂)`. ","depth":9}],"count":140}
{"noDocExamples":[],"kind":"«term_↪o_»","examples":[{"type":"Ordinal.{u_1} ↪o Surreal","name":"Ordinal.toSurreal","isProp":false,"doc":"Converts an ordinal into the corresponding surreal. ","depth":5},{"type":"(V : Type u_3) → SimpleGraph V ↪o Set (Sym2 V)","name":"SimpleGraph.edgeSetEmbedding","isProp":false,"doc":"The edges of G consist of the unordered pairs of vertices related by\n`G.Adj`. This is the order embedding; for the edge set of a particular graph, see\n`SimpleGraph.edgeSet`.\n\nThe way `edgeSet` is defined is such that `mem_edgeSet` is proved by `refl`.\n(That is, `⟦(v, w)⟧ ∈ G.edgeSet` is definitionally equal to `G.Adj v w`.)\n","depth":6},{"type":"ℕ∞ ↪o ENNReal","name":"ENat.toENNRealOrderEmbedding","isProp":false,"doc":"Coercion `ℕ∞ → ℝ≥0∞` as an `OrderEmbedding`. ","depth":8}],"count":139}
{"noDocExamples":[],"kind":"«term_→SL[_]_»","examples":[{"type":"{R₁ : Type u_1} →\n  {R₂ : Type u_2} →\n    [inst : Semiring R₁] →\n      [inst_1 : Semiring R₂] →\n        {σ₁₂ : R₁ →+* R₂} →\n          {M₁ : Type u_4} →\n            [inst_2 : TopologicalSpace M₁] →\n              [inst_3 : AddCommMonoid M₁] →\n                {M₂ : Type u_6} →\n                  [inst_4 : TopologicalSpace M₂] →\n                    [inst_5 : AddCommMonoid M₂] →\n                      [inst_6 : Module R₁ M₁] → [inst_7 : Module R₂ M₂] → Zero (M₁ →SL[σ₁₂] M₂)","name":"ContinuousLinearMap.zero","isProp":false,"doc":"The continuous map that is constantly zero. ","depth":27},{"type":"∀ {R₁ : Type u_1} {R₂ : Type u_2} [inst : Semiring R₁] [inst_1 : Semiring R₂] {σ₁₂ : R₁ →+* R₂} {M₁ : Type u_4}\n  [inst_2 : TopologicalSpace M₁] [inst_3 : AddCommMonoid M₁] {M₂ : Type u_6} [inst_4 : TopologicalSpace M₂]\n  [inst_5 : AddCommMonoid M₂] [inst_6 : Module R₁ M₁] [inst_7 : Module R₂ M₂] [inst_8 : RingHomSurjective σ₁₂]\n  [inst_9 : TopologicalSpace R₁] [inst_10 : TopologicalSpace R₂] [inst_11 : ContinuousSMul R₁ M₁]\n  [inst_12 : ContinuousAdd M₁] [inst_13 : ContinuousSMul R₂ M₂] [inst_14 : ContinuousAdd M₂] (f : M₁ →SL[σ₁₂] M₂)\n  (s : Submodule R₁ M₁),\n  Submodule.map (↑f) (Submodule.topologicalClosure s) ≤ Submodule.topologicalClosure (Submodule.map (↑f) s)","name":"Submodule.topologicalClosure_map","isProp":true,"doc":"Under a continuous linear map, the image of the `TopologicalClosure` of a submodule is\ncontained in the `TopologicalClosure` of its image. ","depth":40},{"type":"{R₁ : Type u_1} →\n  {R₂ : Type u_2} →\n    [inst : Semiring R₁] →\n      [inst_1 : Semiring R₂] →\n        {σ₁₂ : R₁ →+* R₂} →\n          {M₁ : Type u_4} →\n            [inst_2 : TopologicalSpace M₁] →\n              [inst_3 : AddCommMonoid M₁] →\n                {M₂ : Type u_6} →\n                  [inst_4 : TopologicalSpace M₂] →\n                    [inst_5 : AddCommMonoid M₂] →\n                      [inst_6 : Module R₁ M₁] → [inst_7 : Module R₂ M₂] → (M₁ →SL[σ₁₂] M₂) → M₁ →ₛₗ[σ₁₂] M₂","name":"ContinuousLinearMap.Simps.coe","isProp":false,"doc":"See Note [custom simps projection]. ","depth":27}],"count":134}
{"noDocExamples":[],"kind":"«term_≃ᵢ_»","examples":[{"type":"{V : Type u_2} →\n  {P : Type u_3} →\n    [inst : SeminormedAddCommGroup V] → [inst_1 : PseudoMetricSpace P] → [inst_2 : NormedAddTorsor V P] → P → P ≃ᵢ V","name":"IsometryEquiv.constVSub","isProp":false,"doc":"Isometry between the tangent space `V` of a (semi)normed add torsor `P` and `P` given by\nsubtraction from `x : P`. ","depth":10},{"type":"{G : Type v} → [inst : AddGroup G] → [inst_1 : PseudoEMetricSpace G] → [inst : IsometricVAdd G G] → G → G ≃ᵢ G","name":"IsometryEquiv.addLeft","isProp":false,"doc":"Addition `y ↦ x + y` as an `IsometryEquiv`.","depth":10},{"type":"{G : Type v} → [inst : Group G] → [inst_1 : PseudoEMetricSpace G] → [inst : IsometricSMul Gᵐᵒᵖ G] → G → G ≃ᵢ G","name":"IsometryEquiv.mulRight","isProp":false,"doc":"Multiplication `y ↦ y * x` as an `IsometryEquiv`. ","depth":11}],"count":132}
{"noDocExamples":[],"kind":"«term_→ₙₐ[_]_»","examples":[{"type":"{S : Type u_1} →\n  {R : Type u_2} →\n    {A : Type u_3} →\n      [inst : CommSemiring R] →\n        [inst_1 : NonUnitalNonAssocSemiring A] →\n          [inst_2 : Module R A] →\n            [inst_3 : SetLike S A] →\n              [inst_4 : NonUnitalSubsemiringClass S A] → [hSR : SMulMemClass S R A] → (s : S) → ↥s →ₙₐ[R] A","name":"NonUnitalSubalgebraClass.subtype","isProp":false,"doc":"Embedding of a non-unital subalgebra into the non-unital algebra. ","depth":25},{"type":"∀ (k : Type u₁) {G : Type u₂} [inst : Semiring k] [inst_1 : Add G] {A : Type u₃} [inst_2 : NonUnitalNonAssocSemiring A]\n  [inst_3 : DistribMulAction k A] {φ₁ φ₂ : AddMonoidAlgebra k G →ₙₐ[k] A},\n  (∀ (x : G), φ₁ (AddMonoidAlgebra.single x 1) = φ₂ (AddMonoidAlgebra.single x 1)) → φ₁ = φ₂","name":"AddMonoidAlgebra.nonUnitalAlgHom_ext","isProp":true,"doc":"A non_unital `k`-algebra homomorphism from `k[G]` is uniquely defined by its\nvalues on the functions `single a 1`. ","depth":29},{"type":"(R : Type u) →\n  (A : Type v) →\n    (B : Type w) →\n      [inst : Monoid R] →\n        [inst_1 : NonUnitalNonAssocSemiring A] →\n          [inst_2 : DistribMulAction R A] →\n            [inst_3 : NonUnitalNonAssocSemiring B] → [inst_4 : DistribMulAction R B] → B →ₙₐ[R] A × B","name":"NonUnitalAlgHom.inr","isProp":false,"doc":"The right injection into a product is a non-unital algebra homomorphism. ","depth":17}],"count":128}
{"noDocExamples":[],"kind":"«term_[Λ^_]→L[_]_»","examples":[{"type":"{R : Type u_1} →\n  {M : Type u_2} →\n    {N : Type u_3} →\n      {ι : Type u_4} →\n        [inst : Semiring R] →\n          [inst_1 : AddCommMonoid M] →\n            [inst_2 : Module R M] →\n              [inst_3 : TopologicalSpace M] →\n                [inst_4 : AddCommMonoid N] →\n                  [inst_5 : Module R N] → [inst_6 : TopologicalSpace N] → M[Λ^ι]→L[R]N → M [Λ^ι]→ₗ[R] N","name":"ContinuousAlternatingMap.toAlternatingMap","isProp":false,"doc":"Projection to `AlternatingMap`s. ","depth":23},{"type":"{R : Type u_1} →\n  {M : Type u_2} →\n    {N : Type u_4} →\n      {ι : Type u_6} →\n        [inst : Semiring R] →\n          [inst_1 : AddCommMonoid M] →\n            [inst_2 : Module R M] →\n              [inst_3 : TopologicalSpace M] →\n                [inst_4 : AddCommMonoid N] →\n                  [inst_5 : Module R N] →\n                    [inst_6 : TopologicalSpace N] →\n                      [inst_7 : ContinuousAdd N] → M[Λ^ι]→L[R]N →+ ContinuousMultilinearMap R (fun x => M) N","name":"ContinuousAlternatingMap.toMultilinearAddHom","isProp":false,"doc":"Projection to `ContinuousMultilinearMap`s as a bundled `AddMonoidHom`. ","depth":28},{"type":"{R : Type u_1} →\n  {M : Type u_2} →\n    {N : Type u_4} →\n      {ι : Type u_6} →\n        [inst : Semiring R] →\n          [inst_1 : AddCommMonoid M] →\n            [inst_2 : Module R M] →\n              [inst_3 : TopologicalSpace M] →\n                [inst_4 : AddCommMonoid N] →\n                  [inst_5 : Module R N] →\n                    [inst_6 : TopologicalSpace N] → [inst_7 : ContinuousAdd N] → (ι → M) → M[Λ^ι]→L[R]N →+ N","name":"ContinuousAlternatingMap.applyAddHom","isProp":false,"doc":"Evaluation of a `ContinuousAlternatingMap` at a vector as an `AddMonoidHom`. ","depth":29}],"count":128}
{"noDocExamples":[],"kind":"«term_→*₀_»","examples":[{"type":"ℕ∞ →*₀ ℕ","name":"ENat.toNat","isProp":false,"doc":"Conversion of `ℕ∞` to `ℕ` sending `∞` to `0`. ","depth":8},{"type":"{α : Type u_1} → [inst : LinearOrderedRing α] → α →*₀ α","name":"absHom","isProp":false,"doc":"`abs` as a `MonoidWithZeroHom`. ","depth":10},{"type":"∀ {M : Type u_9} {N : Type u_10} [inst : MulZeroOneClass M] [inst_1 : MulZeroOneClass N] (self : M →*₀ N) (x y : M),\n  ZeroHom.toFun (↑self) (x * y) = ZeroHom.toFun (↑self) x * ZeroHom.toFun (↑self) y","name":"MonoidWithZeroHom.map_mul'","isProp":true,"doc":"The proposition that the function preserves multiplication ","depth":17}],"count":127}
{"noDocExamples":[],"kind":"«term_≃ₗᵢ[_]_»","examples":[{"type":"∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : InnerProductSpace ℝ E]\n  [inst_2 : Fact (FiniteDimensional.finrank ℝ E = 2)] (o : Orientation ℝ E (Fin 2)) (φ : E ≃ₗᵢ[ℝ] E),\n  0 < LinearMap.det ↑φ.toLinearEquiv →\n    LinearIsometryEquiv.trans (Orientation.rightAngleRotation o) φ =\n      LinearIsometryEquiv.trans φ (Orientation.rightAngleRotation o)","name":"Orientation.linearIsometryEquiv_comp_rightAngleRotation'","isProp":true,"doc":"`J` commutes with any positively-oriented isometric automorphism. ","depth":40},{"type":"{E : Type u_1} →\n  {F : Type u_3} →\n    [inst : NormedAddCommGroup E] →\n      [inst_1 : NormedSpace ℝ E] →\n        [inst_2 : NormedAddCommGroup F] → [inst_3 : NormedSpace ℝ F] → (f : E ≃ᵢ F) → f 0 = 0 → E ≃ₗᵢ[ℝ] F","name":"IsometryEquiv.toRealLinearIsometryEquivOfMapZero","isProp":false,"doc":"**Mazur-Ulam Theorem**: if `f` is an isometric bijection between two normed vector spaces\nover `ℝ` and `f 0 = 0`, then `f` is a linear isometry equivalence. ","depth":24},{"type":"{ι : Type u_1} →\n  {𝕜 : Type u_2} →\n    [inst : IsROrC 𝕜] →\n      {E : Type u_3} →\n        [inst_1 : NormedAddCommGroup E] →\n          [inst_2 : InnerProductSpace 𝕜 E] → HilbertBasis ι 𝕜 E → E ≃ₗᵢ[𝕜] ↥(lp (fun i => 𝕜) 2)","name":"HilbertBasis.repr","isProp":false,"doc":"The linear isometric equivalence implementing identifying the Hilbert space with `ℓ²`. ","depth":34}],"count":125}
{"noDocExamples":[],"kind":"CategoryTheory.Limits.«term_⨯_»","examples":[{"type":"{C : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} C] →\n    {A : C} → CategoryTheory.IsSubterminal A → [inst_1 : CategoryTheory.Limits.HasBinaryProduct A A] → A ⨯ A ≅ A","name":"CategoryTheory.IsSubterminal.isoDiag","isProp":false,"doc":"If `A` is subterminal, it is isomorphic to `A ⨯ A`. ","depth":12},{"type":"{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] →\n    {X Y : C} → [inst_1 : CategoryTheory.Limits.HasBinaryProduct X Y] → X ⨯ Y ⟶ X","name":"CategoryTheory.Limits.prod.fst","isProp":false,"doc":"The projection map to the first component of the product. ","depth":12},{"type":"{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] →\n    {X Y : C} → [inst_1 : CategoryTheory.Limits.HasBinaryProduct X Y] → X ⨯ Y ⟶ Y","name":"CategoryTheory.Limits.prod.snd","isProp":false,"doc":"The projection map to the second component of the product. ","depth":12}],"count":123}
{"noDocExamples":[],"kind":"«term_⤳_»","examples":[{"type":"∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : RegularSpace X] {a b : X}, a ⤳ b → b ⤳ a","name":"Specializes.symm","isProp":true,"doc":"**Alias** of the forward direction of `specializes_comm`.","depth":10},{"type":"∀ {X : Type u_1} [inst : TopologicalSpace X] {x y : X}, x ⤳ y → y ∈ closure {x}","name":"Specializes.mem_closure","isProp":true,"doc":"**Alias** of the forward direction of `specializes_iff_mem_closure`.","depth":11},{"type":"∀ {X : Type u_1} [inst : TopologicalSpace X] {x y : X}, x ⤳ y → pure x ≤ nhds y","name":"Specializes.pure_le_nhds","isProp":true,"doc":"**Alias** of the forward direction of `specializes_iff_pure`.","depth":12}],"count":123}
{"noDocExamples":[],"kind":"Prefunctor.«term_⥤q_»","examples":[{"type":"∀ {U : Type u_1} {V : Type u_2} [inst : Quiver U] [inst_1 : Quiver V] [inst_2 : Quiver.HasReverse U]\n  [inst_3 : Quiver.HasReverse V] {φ : U ⥤q V} [self : Prefunctor.MapReverse φ] {u v : U} (e : u ⟶ v),\n  φ.map (Quiver.reverse e) = Quiver.reverse (φ.map e)","name":"Prefunctor.MapReverse.map_reverse'","isProp":true,"doc":"The image of a reverse is the reverse of the image. ","depth":22},{"type":"{B : Type u} → [inst : Quiver B] → B ⥤q CategoryTheory.FreeBicategory B","name":"CategoryTheory.FreeBicategory.of","isProp":false,"doc":"Canonical prefunctor from `B` to `free_bicategory B`. ","depth":6},{"type":"(V : Type u_1) → [inst : Quiver V] → V ⥤q V","name":"Prefunctor.id","isProp":false,"doc":"The identity morphism between quivers. ","depth":6}],"count":122}
{"noDocExamples":[],"kind":"CategoryTheory.Limits.«term⊤__»","examples":[{"type":"{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] →\n    [inst_1 : CategoryTheory.Limits.HasFiniteProducts C] → CategoryTheory.Exponentiable (⊤_ C)","name":"CategoryTheory.terminalExponentiable","isProp":false,"doc":"The terminal object is always exponentiable.\nThis isn't an instance because most of the time we'll prove cartesian closed for all objects\nat once, rather than just for this one.\n","depth":10},{"type":"∀ {C : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} C] [inst_1 : CategoryTheory.Limits.HasInitial C]\n  [inst_2 : CategoryTheory.Limits.HasTerminal C],\n  CategoryTheory.Mono (CategoryTheory.Limits.initial.to (⊤_ C)) → CategoryTheory.Limits.InitialMonoClass C","name":"CategoryTheory.Limits.InitialMonoClass.of_terminal","isProp":true,"doc":"To show a category is an `InitialMonoClass` it suffices to show the unique morphism from the\ninitial object to a terminal object is a monomorphism. ","depth":11},{"type":"{C : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} C] → [inst_1 : CategoryTheory.Limits.HasTerminal C] → (P : C) → P ⟶ ⊤_ C","name":"CategoryTheory.Limits.terminal.from","isProp":false,"doc":"The map from an object to the terminal object. ","depth":10}],"count":122}
{"noDocExamples":[],"kind":"«term_↪r_»","examples":[{"type":"{α : Type u_1} → {β : Type u_2} → (r : α → α → Prop) → (s : β → β → Prop) → r ↪r Sum.Lex r s","name":"RelEmbedding.sumLexInl","isProp":false,"doc":"`Sum.inl` as a relation embedding into `Sum.Lex r s`. ","depth":9},{"type":"{X : Type u_5} → (r : X → X → Prop) → (p : X → Prop) → Subtype.val ⁻¹'o r ↪r r","name":"Subtype.relEmbedding","isProp":false,"doc":"The induced relation on a subtype is an embedding under the natural inclusion. ","depth":11},{"type":"{α : Type u_1} → {β : Type u_2} → (r : α → α → Prop) → (s : β → β → Prop) → r ↪r Sum.LiftRel r s","name":"RelEmbedding.sumLiftRelInl","isProp":false,"doc":"`Sum.inl` as a relation embedding into `Sum.LiftRel r s`. ","depth":11}],"count":121}
{"noDocExamples":[],"kind":"Hyperreal.«termℝ*»","examples":[{"type":"ℝ*","name":"Hyperreal.epsilon","isProp":false,"doc":"A sample infinitesimal hyperreal","depth":0},{"type":"ℝ*","name":"Hyperreal.omega","isProp":false,"doc":"A sample infinite hyperreal","depth":0},{"type":"ℝ* → Prop","name":"Hyperreal.InfiniteNeg","isProp":false,"doc":"A hyperreal number is negative infinite if it is smaller than all real numbers ","depth":1}],"count":117}
{"noDocExamples":[],"kind":"CategoryTheory.Limits.«term⨁_»","examples":[{"type":"{J : Type w} →\n  {C : Type u} →\n    [inst : CategoryTheory.Category.{v, u} C] →\n      [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C] →\n        (f : J → C) → [inst_2 : CategoryTheory.Limits.HasBiproduct f] → ⨁ f ≅ ∐ f","name":"CategoryTheory.Limits.biproduct.isoCoproduct","isProp":false,"doc":"The canonical isomorphism between the chosen biproduct and the chosen coproduct. ","depth":14},{"type":"{J : Type w} →\n  {C : Type u} →\n    [inst : CategoryTheory.Category.{v, u} C] →\n      [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C] →\n        (f : J → C) → [inst_2 : CategoryTheory.Limits.HasBiproduct f] → (b : J) → ⨁ f ⟶ f b","name":"CategoryTheory.Limits.biproduct.π","isProp":false,"doc":"The projection onto a summand of a biproduct. ","depth":15},{"type":"{C : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} C] →\n    [inst_1 : CategoryTheory.Preadditive C] →\n      (M : CategoryTheory.Mat_ C) → M ≅ ⨁ fun i => (CategoryTheory.Mat_.embedding C).obj (CategoryTheory.Mat_.X M i)","name":"CategoryTheory.Mat_.isoBiproductEmbedding","isProp":false,"doc":"Every object in `Mat_ C` is isomorphic to the biproduct of its summands.\n","depth":16}],"count":113}
{"noDocExamples":[],"kind":"Nat.«term_≡_[MOD_]»","examples":[{"type":"∀ {n : ℕ}, n ≠ 0 → ∀ (d : ℕ), ∃ᶠ (m : ℕ) in Filter.atTop, m ≡ d [MOD n]","name":"Nat.frequently_modEq","isProp":true,"doc":"Infinitely many natural numbers are equal to `d` mod `n`. ","depth":9},{"type":"∀ {k : ℕ}, k ≠ 0 → Set.Infinite {p | Nat.Prime p ∧ p ≡ 1 [MOD k]}","name":"Nat.infinite_setOf_prime_modEq_one","isProp":true,"doc":"For any positive `k : ℕ` there are infinitely many primes `p` such that `p ≡ 1 [MOD k]`. ","depth":10},{"type":"∀ {n a b : ℕ}, a ≡ b [MOD n] → ↑n ∣ ↑b - ↑a","name":"Nat.ModEq.dvd","isProp":true,"doc":"**Alias** of the forward direction of `Nat.modEq_iff_dvd`.","depth":11}],"count":112}
{"noDocExamples":[],"kind":"«termℤ_[_]»","examples":[{"type":"{p : ℕ} → [inst : Fact (Nat.Prime p)] → Mul ℤ_[p]","name":"PadicInt.instMulPadicInt","isProp":false,"doc":"Multiplication on `ℤ_[p]` is inherited from `ℚ_[p]`. ","depth":5},{"type":"{p : ℕ} → [inst : Fact (Nat.Prime p)] → Zero ℤ_[p]","name":"PadicInt.instZeroPadicInt","isProp":false,"doc":"Zero on `ℤ_[p]` is inherited from `ℚ_[p]`. ","depth":5},{"type":"{p : ℕ} → [hp : Fact (Nat.Prime p)] → ℤ_[p] → ℤ","name":"PadicInt.valuation","isProp":false,"doc":"`PadicInt.valuation` lifts the `p`-adic valuation on `ℚ` to `ℤ_[p]`.  ","depth":5}],"count":112}
{"noDocExamples":[],"kind":"term!_","examples":[{"type":"∀ (x y : Bool), (!(x && y)) = (!x || !y)","name":"Bool.not_and","isProp":true,"doc":"De Morgan's law for boolean and ","depth":7},{"type":"∀ {x y : Bool}, (!x) = !y ↔ x = y","name":"Bool.not_inj'","isProp":true,"doc":"**Alias** of `Bool.not_inj_iff`.","depth":7},{"type":"∀ (x y : Bool), (!(x || y)) = (!x && !y)","name":"Bool.not_or","isProp":true,"doc":"De Morgan's law for boolean or ","depth":7}],"count":111}
{"noDocExamples":[{"type":"{M : Type u_1} → [inst : DivInvMonoid Mᵐᵒᵖ] → DivInvMonoid Mᵈᵐᵃ","name":"DomMulAct.instDivInvMonoidDomMulAct","isProp":false,"depth":4},{"type":"∀ {M : Type u_1} {α : Type u_3} {N : Type u_4} {β : Type u_2} [inst : SMul M α] [inst_1 : SMul N α]\n  [inst_2 : SMulCommClass M N α] [inst_3 : SMul N β] (c : Mᵈᵐᵃ) (f : α →[N] β) (a : α),\n  (c • f) a = f (DomMulAct.mk.symm c • a)","name":"DomMulAct.smul_mulActionHom_apply","isProp":true,"depth":28}],"kind":"«term_ᵈᵐᵃ»","examples":[{"type":"{M : Type u_1} → M ≃ Mᵈᵐᵃ","name":"DomMulAct.mk","isProp":false,"doc":"Equivalence between `M` and `Mᵈᵐᵃ`. ","depth":3}],"count":111}
{"noDocExamples":[],"kind":"«term_×'_»","examples":[{"type":"(M : Type u_1) →\n  (N : Type u_2) →\n    (α : Type u_5) →\n      [inst : AddMonoid M] →\n        [inst_1 : AddMonoid N] →\n          AddAction (M × N) α ≃ (x : AddAction M α) ×' (x_1 : AddAction N α) ×' VAddCommClass M N α","name":"AddAction.prodEquiv","isProp":false,"doc":"An `AddAction` by a product monoid is equivalent to\ncommuting `AddAction`s by the factors.","depth":16},{"type":"∀ {α : Sort u_1} {β : Sort u_3} {p : α → β → Prop} {x₀ x₁ : (a : α) ×' Subtype (p a)},\n  x₀.fst = x₁.fst → ↑x₀.snd = ↑x₁.snd → x₀ = x₁","name":"PSigma.subtype_ext","isProp":true,"doc":"A specialized ext lemma for equality of `PSigma` types over an indexed subtype. ","depth":17},{"type":"{V : Type u} →\n  [inst : CategoryTheory.Category.{v, u} V] →\n    [inst_1 : CategoryTheory.Limits.HasZeroMorphisms V] →\n      CochainComplex.MkStruct V →\n        (X₀ : V) ×'\n          (X₁ : V) ×' (X₂ : V) ×' (d₀ : X₀ ⟶ X₁) ×' (d₁ : X₁ ⟶ X₂) ×' CategoryTheory.CategoryStruct.comp d₀ d₁ = 0","name":"CochainComplex.MkStruct.flat","isProp":false,"doc":"Flatten to a tuple. ","depth":24}],"count":111}
{"noDocExamples":[],"kind":"Int.«term⌊_⌋»","examples":[{"type":"∀ (ξ : ℝ), Real.convergent ξ 0 = ↑⌊ξ⌋","name":"Real.convergent_zero","isProp":true,"doc":"The zeroth convergent of `ξ` is `⌊ξ⌋`. ","depth":7},{"type":"∀ {K : Type u_1} [inst : LinearOrderedField K] [inst_1 : FloorRing K] {v : K},\n  (GeneralizedContinuedFraction.of v).h = ↑⌊v⌋","name":"GeneralizedContinuedFraction.of_h_eq_floor","isProp":true,"doc":"The head term of the gcf of `v` is `⌊v⌋`. ","depth":12},{"type":"∀ (ξ : ℝ) (n : ℕ), Real.convergent ξ (n + 1) = ↑⌊ξ⌋ + (Real.convergent (Int.fract ξ)⁻¹ n)⁻¹","name":"Real.convergent_succ","isProp":true,"doc":"The `(n+1)`th convergent of `ξ` is the `n`th convergent of `1/(fract ξ)`. ","depth":12}],"count":107}
{"noDocExamples":[],"kind":"Submodule.«term_ᗮ»","examples":[{"type":"∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {K : Submodule 𝕜 E} [inst_3 : CompleteSpace E], Kᗮᗮᗮ = Kᗮ","name":"Submodule.triorthogonal_eq_orthogonal","isProp":true,"doc":"The orthogonal complement satisfies `Kᗮᗮᗮ = Kᗮ`. ","depth":20},{"type":"∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  (K : Submodule 𝕜 E) [inst_3 : HasOrthogonalProjection K], Kᗮᗮ = K","name":"Submodule.orthogonal_orthogonal","isProp":true,"doc":"If `K` admits an orthogonal projection, then the orthogonal complement of its orthogonal\ncomplement is itself. ","depth":20},{"type":"∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  (K : Submodule 𝕜 E), IsClosed ↑Kᗮ","name":"Submodule.isClosed_orthogonal","isProp":true,"doc":"The orthogonal complement of any submodule `K` is closed. ","depth":21}],"count":107}
{"noDocExamples":[],"kind":"«term∫_In_.._,_∂_»","examples":[{"type":"∀ {E : Type u_3} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] {f g : ℝ → E} {μ : MeasureTheory.Measure ℝ}\n  {a b : ℝ}, Set.EqOn f g (Set.uIcc a b) → ∫ (x : ℝ) in a..b, f x ∂μ = ∫ (x : ℝ) in a..b, g x ∂μ","name":"intervalIntegral.integral_congr","isProp":true,"doc":"If two functions are equal in the relevant interval, their interval integrals are also equal. ","depth":18},{"type":"∀ {f : ℝ → ℝ} {a b : ℝ} {μ : MeasureTheory.Measure ℝ},\n  0 ≤ᶠ[MeasureTheory.Measure.ae (MeasureTheory.Measure.restrict μ (Ι a b))] f →\n    IntervalIntegrable f μ a b → (0 < ∫ (x : ℝ) in a..b, f x ∂μ ↔ a < b ∧ 0 < ↑↑μ (Function.support f ∩ Set.Ioc a b))","name":"intervalIntegral.integral_pos_iff_support_of_nonneg_ae'","isProp":true,"doc":"If `f` is nonnegative and integrable on the unordered interval `Set.uIoc a b`, then its\nintegral over `a..b` is positive if and only if `a < b` and the measure of\n`Function.support f ∩ Set.Ioc a b` is positive. ","depth":19},{"type":"∀ {f : ℝ → ℝ} {a b : ℝ} {μ : MeasureTheory.Measure ℝ},\n  0 ≤ᶠ[MeasureTheory.Measure.ae μ] f →\n    IntervalIntegrable f μ a b → (0 < ∫ (x : ℝ) in a..b, f x ∂μ ↔ a < b ∧ 0 < ↑↑μ (Function.support f ∩ Set.Ioc a b))","name":"intervalIntegral.integral_pos_iff_support_of_nonneg_ae","isProp":true,"doc":"If `f` is nonnegative a.e.-everywhere and it is integrable on the unordered interval\n`Set.uIoc a b`, then its integral over `a..b` is positive if and only if `a < b` and the\nmeasure of `Function.support f ∩ Set.Ioc a b` is positive. ","depth":19}],"count":101}
{"noDocExamples":[],"kind":"«termℚ_[_]»","examples":[{"type":"{p : ℕ} → [inst : Fact (Nat.Prime p)] → PadicSeq p → ℚ_[p]","name":"Padic.mk","isProp":false,"doc":"Builds the equivalence class of a Cauchy sequence of rationals. ","depth":5},{"type":"∀ {p : ℕ} [inst : Fact (Nat.Prime p)] {q r : ℚ_[p]},\n  padicNormE q ≠ padicNormE r → padicNormE (q + r) = max (padicNormE q) (padicNormE r)","name":"padicNormE.add_eq_max_of_ne'","isProp":true,"doc":"Theorems about `padicNormE` are named with a `'` so the names do not conflict with the\nequivalent theorems about `norm` (`‖ ‖`). ","depth":26},{"type":"{p : ℕ} → [inst : Fact (Nat.Prime p)] → ℤ_[p] →+* ℚ_[p]","name":"PadicInt.Coe.ringHom","isProp":false,"doc":"The coercion from `ℤ_[p]` to `ℚ_[p]` as a ring homomorphism. ","depth":10}],"count":99}
{"noDocExamples":[],"kind":"«term_⊼_»","examples":[{"type":"∀ {α : Type u_1} [inst : DistribLattice α] [inst_1 : DecidableEq α] (s t : Finset α),\n  Finset.card s * Finset.card t ≤ Finset.card (s ⊼ t) * Finset.card (s ⊻ t)","name":"Finset.le_card_infs_mul_card_sups","isProp":true,"doc":"An inequality of Daykin. Interestingly, any lattice in which this inequality holds is\ndistributive. ","depth":18},{"type":"∀ {α : Type u_1} {β : Type u_2} [inst : DistribLattice α] [inst_1 : DecidableEq α]\n  [inst_2 : LinearOrderedCommSemiring β] [inst_3 : ExistsAddOfLE β] (f₁ f₂ f₃ f₄ : α → β),\n  0 ≤ f₁ →\n    0 ≤ f₂ →\n      0 ≤ f₃ →\n        0 ≤ f₄ →\n          (∀ (a b : α), f₁ a * f₂ b ≤ f₃ (a ⊓ b) * f₄ (a ⊔ b)) →\n            ∀ (s t : Finset α),\n              ((Finset.sum s fun a => f₁ a) * Finset.sum t fun a => f₂ a) ≤\n                (Finset.sum (s ⊼ t) fun a => f₃ a) * Finset.sum (s ⊻ t) fun a => f₄ a","name":"four_functions_theorem","isProp":true,"doc":"The **Four Functions Theorem**, aka **Ahlswede-Daykin Inequality**. ","depth":31},{"type":"∀ {α : Type u_1} {β : Type u_2} [inst : DecidableEq α] [inst_1 : LinearOrderedCommSemiring β] [inst_2 : ExistsAddOfLE β]\n  {f₁ f₂ f₃ f₄ : Finset α → β} (u : Finset α),\n  0 ≤ f₁ →\n    0 ≤ f₂ →\n      0 ≤ f₃ →\n        0 ≤ f₄ →\n          (∀ ⦃s : Finset α⦄, s ⊆ u → ∀ ⦃t : Finset α⦄, t ⊆ u → f₁ s * f₂ t ≤ f₃ (s ∩ t) * f₄ (s ∪ t)) →\n            ∀ {𝒜 ℬ : Finset (Finset α)},\n              𝒜 ⊆ Finset.powerset u →\n                ℬ ⊆ Finset.powerset u →\n                  ((Finset.sum 𝒜 fun s => f₁ s) * Finset.sum ℬ fun s => f₂ s) ≤\n                    (Finset.sum (𝒜 ⊼ ℬ) fun s => f₃ s) * Finset.sum (𝒜 ⊻ ℬ) fun s => f₄ s","name":"Finset.four_functions_theorem","isProp":true,"doc":"The **Four Functions Theorem** on a powerset algebra. See `four_functions_theorem` for the\nfinite distributive lattice generalisation. ","depth":38}],"count":99}
{"noDocExamples":[],"kind":"«term_→⋆ₐ[_]_»","examples":[{"type":"∀ {R : Type u_1} {A : Type u_2} {B : Type u_3} [inst : CommSemiring R] [inst_1 : Semiring A] [inst_2 : Algebra R A]\n  [inst_3 : Star A] [inst_4 : Semiring B] [inst_5 : Algebra R B] [inst_6 : Star B] (self : A →⋆ₐ[R] B) (x : A),\n  OneHom.toFun (↑↑↑self.toAlgHom) (star x) = star (OneHom.toFun (↑↑↑self.toAlgHom) x)","name":"StarAlgHom.map_star'","isProp":true,"doc":"By definition, a ⋆-algebra homomorphism preserves the `star` operation. ","depth":30},{"type":"(R : Type u_2) →\n  (A : Type u_3) →\n    [inst : CommSemiring R] → [inst_1 : Semiring A] → [inst_2 : Algebra R A] → [inst_3 : Star A] → A →⋆ₐ[R] A","name":"StarAlgHom.id","isProp":false,"doc":"The identity as a `StarAlgHom`. ","depth":16},{"type":"{R : Type u_1} →\n  {A : Type u_2} →\n    {B : Type u_3} →\n      {C : Type u_4} →\n        [inst : CommSemiring R] →\n          [inst_1 : Semiring A] →\n            [inst_2 : Algebra R A] →\n              [inst_3 : Star A] →\n                [inst_4 : Semiring B] →\n                  [inst_5 : Algebra R B] →\n                    [inst_6 : Star B] →\n                      [inst_7 : Semiring C] →\n                        [inst_8 : Algebra R C] → [inst_9 : Star C] → (A →⋆ₐ[R] B) → (A →⋆ₐ[R] C) → A →⋆ₐ[R] B × C","name":"StarAlgHom.prod","isProp":false,"doc":"The `Pi.prod` of two morphisms is a morphism. ","depth":26}],"count":98}
{"noDocExamples":[],"kind":"«term_⊻_»","examples":[{"type":"∀ {α : Type u_1} [inst : DistribLattice α] [inst_1 : DecidableEq α] (s t : Finset α),\n  Finset.card s * Finset.card t ≤ Finset.card (s ⊼ t) * Finset.card (s ⊻ t)","name":"Finset.le_card_infs_mul_card_sups","isProp":true,"doc":"An inequality of Daykin. Interestingly, any lattice in which this inequality holds is\ndistributive. ","depth":18},{"type":"∀ {α : Type u_1} {β : Type u_2} [inst : DistribLattice α] [inst_1 : DecidableEq α]\n  [inst_2 : LinearOrderedCommSemiring β] [inst_3 : ExistsAddOfLE β] (f₁ f₂ f₃ f₄ : α → β),\n  0 ≤ f₁ →\n    0 ≤ f₂ →\n      0 ≤ f₃ →\n        0 ≤ f₄ →\n          (∀ (a b : α), f₁ a * f₂ b ≤ f₃ (a ⊓ b) * f₄ (a ⊔ b)) →\n            ∀ (s t : Finset α),\n              ((Finset.sum s fun a => f₁ a) * Finset.sum t fun a => f₂ a) ≤\n                (Finset.sum (s ⊼ t) fun a => f₃ a) * Finset.sum (s ⊻ t) fun a => f₄ a","name":"four_functions_theorem","isProp":true,"doc":"The **Four Functions Theorem**, aka **Ahlswede-Daykin Inequality**. ","depth":31},{"type":"∀ {α : Type u_1} {β : Type u_2} [inst : DecidableEq α] [inst_1 : LinearOrderedCommSemiring β] [inst_2 : ExistsAddOfLE β]\n  {f₁ f₂ f₃ f₄ : Finset α → β} (u : Finset α),\n  0 ≤ f₁ →\n    0 ≤ f₂ →\n      0 ≤ f₃ →\n        0 ≤ f₄ →\n          (∀ ⦃s : Finset α⦄, s ⊆ u → ∀ ⦃t : Finset α⦄, t ⊆ u → f₁ s * f₂ t ≤ f₃ (s ∩ t) * f₄ (s ∪ t)) →\n            ∀ {𝒜 ℬ : Finset (Finset α)},\n              𝒜 ⊆ Finset.powerset u →\n                ℬ ⊆ Finset.powerset u →\n                  ((Finset.sum 𝒜 fun s => f₁ s) * Finset.sum ℬ fun s => f₂ s) ≤\n                    (Finset.sum (𝒜 ⊼ ℬ) fun s => f₃ s) * Finset.sum (𝒜 ⊻ ℬ) fun s => f₄ s","name":"Finset.four_functions_theorem","isProp":true,"doc":"The **Four Functions Theorem** on a powerset algebra. See `four_functions_theorem` for the\nfinite distributive lattice generalisation. ","depth":38}],"count":97}
{"noDocExamples":[],"kind":"«term_≃ᵃ[_]_»","examples":[{"type":"(k : Type u_1) →\n  {P₁ : Type u_2} →\n    {V₁ : Type u_6} →\n      [inst : Ring k] →\n        [inst_1 : AddCommGroup V₁] → [inst_2 : Module k V₁] → [inst_3 : AddTorsor V₁ P₁] → P₁ → P₁ ≃ᵃ[k] P₁","name":"AffineEquiv.pointReflection","isProp":false,"doc":"Point reflection in `x` as a permutation. ","depth":20},{"type":"(k : Type u_1) →\n  (P₁ : Type u_2) →\n    {V₁ : Type u_6} →\n      [inst : Ring k] →\n        [inst_1 : AddCommGroup V₁] →\n          [inst_2 : Module k V₁] → [inst_3 : AddTorsor V₁ P₁] → Multiplicative V₁ →* P₁ ≃ᵃ[k] P₁","name":"AffineEquiv.constVAddHom","isProp":false,"doc":"A more bundled version of `AffineEquiv.constVAdd`. ","depth":24},{"type":"{R : Type u_10} →\n  {V : Type u_11} →\n    {P : Type u_12} →\n      [inst : CommRing R] →\n        [inst_1 : AddCommGroup V] → [inst_2 : Module R V] → [inst_3 : AddTorsor V P] → P → Rˣ →* P ≃ᵃ[R] P","name":"AffineEquiv.homothetyUnitsMulHom","isProp":false,"doc":"Fixing a point in affine space, homothety about this point gives a group homomorphism from (the\ncentre of) the units of the scalars into the group of affine equivalences. ","depth":25}],"count":97}
{"noDocExamples":[],"kind":"«term_≃r_»","examples":[{"type":"{α : Type u_1} → (r : α → α → Prop) → r ≃r r","name":"RelIso.refl","isProp":false,"doc":"Identity map is a relation isomorphism. ","depth":6},{"type":"{α : Type u_1} → {β : Type u_2} → {r : α → α → Prop} → {s : β → β → Prop} → r ≃r s → s ≃r r","name":"RelIso.symm","isProp":false,"doc":"Inverse map of a relation isomorphism is a relation isomorphism. ","depth":9},{"type":"{α : Type u_1} → {β : Type u_2} → {r : α → α → Prop} → {s : β → β → Prop} → r ≃r s → β → α","name":"RelIso.Simps.symm_apply","isProp":false,"doc":"See Note [custom simps projection]. ","depth":9}],"count":96}
{"noDocExamples":[],"kind":"Set.«term⋂₀_»","examples":[{"type":"∀ {X : Type u_1} [inst : TopologicalSpace X] {S : Set (Set X)}, (∀ s ∈ S, IsGδ s) → Set.Countable S → IsGδ (⋂₀ S)","name":"isGδ_sInter","isProp":true,"doc":"A countable intersection of Gδ sets is a Gδ set. ","depth":12},{"type":"∀ {α : Type u_1} [inst : TopologicalSpace α] [self : AlexandrovDiscrete α] (S : Set (Set α)),\n  (∀ s ∈ S, IsOpen s) → IsOpen (⋂₀ S)","name":"AlexandrovDiscrete.isOpen_sInter","isProp":true,"doc":"The intersection of a family of open sets is an open set. Use `isOpen_sInter` in the root\nnamespace instead. ","depth":13},{"type":"∀ {α : Type u_2} {l : Filter α} [self : CountableInterFilter l] (S : Set (Set α)),\n  Set.Countable S → (∀ s ∈ S, s ∈ l) → ⋂₀ S ∈ l","name":"CountableInterFilter.countable_sInter_mem","isProp":true,"doc":"For a countable collection of sets `s ∈ l`, their intersection belongs to `l` as well. ","depth":14}],"count":95}
{"noDocExamples":[],"kind":"FirstOrder.Language.«term_→ᴸ_»","examples":[{"type":"(L : FirstOrder.Language) → L →ᴸ L","name":"FirstOrder.Language.LHom.id","isProp":false,"doc":"The identity language homomorphism. ","depth":3},{"type":"(L : FirstOrder.Language) → [inst : FirstOrder.Language.IsOrdered L] → FirstOrder.Language.order →ᴸ L","name":"FirstOrder.Language.orderLHom","isProp":false,"doc":"The language homomorphism sending the unique symbol `≤` of `Language.order` to `≤` in an ordered\nlanguage. ","depth":4},{"type":"{L : FirstOrder.Language} → {L' : FirstOrder.Language} → (L →ᴸ L') → Prop","name":"FirstOrder.Language.LHom.Injective","isProp":false,"doc":"A language homomorphism is injective when all the maps between symbol types are. ","depth":5}],"count":92}
{"noDocExamples":[],"kind":"«term_≃ᵤ_»","examples":[{"type":"{α : Type u_1} →\n  [inst : UniformSpace α] → [inst_1 : CompleteSpace α] → [inst_2 : SeparatedSpace α] → UniformSpace.Completion α ≃ᵤ α","name":"UniformSpace.Completion.UniformCompletion.completeEquivSelf","isProp":false,"doc":"The uniform bijection between a complete space and its uniform completion. ","depth":10},{"type":"∀ {α : Type u_4} {β : Type u_5} [inst : UniformSpace α] [inst_1 : UniformSpace β] (self : α ≃ᵤ β),\n  UniformContinuous self.invFun","name":"UniformEquiv.uniformContinuous_invFun","isProp":true,"doc":"Uniform continuity of the inverse ","depth":12},{"type":"CompareReals.Bourbakiℝ ≃ᵤ ℝ","name":"CompareReals.compareEquiv","isProp":false,"doc":"The uniform bijection between Bourbaki and Cauchy reals. ","depth":4}],"count":92}
{"noDocExamples":[],"kind":"CategoryTheory.Limits.«term_⊞_»","examples":[{"type":"{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] →\n    [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C] →\n      {X Y : C} → [inst_2 : CategoryTheory.Limits.HasBinaryBiproduct X Y] → X ⟶ X ⊞ Y","name":"CategoryTheory.Limits.biprod.inl","isProp":false,"doc":"The inclusion into the first summand of a binary biproduct. ","depth":13},{"type":"{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] →\n    [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C] →\n      (X Y : C) → [inst_2 : CategoryTheory.Limits.HasBinaryBiproduct X Y] → X ⊞ Y ≅ X ⨿ Y","name":"CategoryTheory.Limits.biprod.isoCoprod","isProp":false,"doc":"The canonical isomorphism between the chosen biproduct and the chosen coproduct. ","depth":14},{"type":"{C : Type u_1} →\n  [inst : CategoryTheory.Category.{u_3, u_1} C] →\n    [inst_1 : CategoryTheory.Preadditive C] →\n      {S : CategoryTheory.ShortComplex C} →\n        CategoryTheory.ShortComplex.Splitting S →\n          [inst_2 : CategoryTheory.Limits.HasBinaryBiproduct S.X₁ S.X₃] → S.X₂ ≅ S.X₁ ⊞ S.X₃","name":"CategoryTheory.ShortComplex.Splitting.isoBinaryBiproduct","isProp":false,"doc":"The isomorphism `S.X₂ ≅ S.X₁ ⊞ S.X₃` induced by a splitting of the short complex `S`. ","depth":15}],"count":90}
{"noDocExamples":[],"kind":"Lean.Parser.Term.subst","examples":[{"type":"{α : Sort u} →\n  {r : α → α → Prop} →\n    {motive : Quot r → Sort v} →\n      (f : (a : α) → motive (Quot.mk r a)) →\n        (∀ (a b : α) (p : r a b), (_ : Quot.mk r a = Quot.mk r b) ▸ f a = f b) → (q : Quot r) → motive q","name":"Quot.rec","isProp":false,"doc":"Dependent recursion principle for `Quot`. This constructor can be tricky to use,\nso you should consider the simpler versions if they apply:\n* `Quot.lift`, for nondependent functions\n* `Quot.ind`, for theorems / proofs of propositions about quotients\n* `Quot.recOnSubsingleton`, when the target type is a `Subsingleton`\n* `Quot.hrecOn`, which uses `HEq (f a) (f b)` instead of a `sound p ▸ f a = f b` assummption\n","depth":18},{"type":"∀ {β : Sort u_1} {α : Sort u_2} (P : β → Sort w) (e : α ≃ β) (f : (a : α) → P (e a)) (b : β),\n  (Equiv.piCongrLeft P e) f b = (_ : e (e.symm b) = b) ▸ f (e.symm b)","name":"Equiv.piCongrLeft_apply","isProp":true,"doc":"Note: the \"obvious\" statement `(piCongrLeft P e) f b = f (e.symm b)` doesn't typecheck: the\nLHS would have type `P b` while the RHS would have type `P (e (e.symm b))`. For that reason,\nwe have to explicitly substitute along `e (e.symm b) = b` in the statement of this lemma. ","depth":27},{"type":"{α : Sort u_1} →\n  {C : Trunc α → Sort u_3} →\n    (f : (a : α) → C (Trunc.mk a)) → (∀ (a b : α), (_ : Trunc.mk a = Trunc.mk b) ▸ f a = f b) → (q : Trunc α) → C q","name":"Trunc.rec","isProp":false,"doc":"Recursion/induction principle for `Trunc`. ","depth":15}],"count":90}
{"noDocExamples":[],"kind":"SimpleGraph.«term_→g_»","examples":[{"type":"∀ {V : Type u} {W : Type v} {G : SimpleGraph V} {F : SimpleGraph W} [inst : Finite W],\n  ((G' : SimpleGraph.Subgraph G) → Set.Finite G'.verts → SimpleGraph.Subgraph.coe G' →g F) → Nonempty (G →g F)","name":"SimpleGraph.nonempty_hom_of_forall_finite_subgraph_hom","isProp":true,"doc":"If every finite subgraph of a graph `G` has a homomorphism to a finite graph `F`, then there is\na homomorphism from the whole of `G` to `F`. ","depth":16},{"type":"∀ {V : Type u} {V' : Type v} {G : SimpleGraph V} {G' : SimpleGraph V'} {f : G →g G'} {u : V}\n  {p : SimpleGraph.Walk G u u},\n  Function.Injective ⇑f → SimpleGraph.Walk.IsCycle p → SimpleGraph.Walk.IsCycle (SimpleGraph.Walk.map f p)","name":"SimpleGraph.Walk.map_isCycle_of_injective","isProp":true,"doc":"**Alias** of the reverse direction of `SimpleGraph.Walk.map_isCycle_iff_of_injective`.","depth":24},{"type":"∀ {V : Type u} {V' : Type v} {G : SimpleGraph V} {G' : SimpleGraph V'} {u v : V} (p : SimpleGraph.Walk G u v)\n  {f : G →g G'} (f' : G →g G') (h : f = f'),\n  SimpleGraph.Walk.map f p = SimpleGraph.Walk.copy (SimpleGraph.Walk.map f' p) (_ : f' u = f u) (_ : f' v = f v)","name":"SimpleGraph.Walk.map_eq_of_eq","isProp":true,"doc":"Unlike categories, for graphs vertex equality is an important notion, so needing to be able to\nwork with equality of graph homomorphisms is a necessary evil. ","depth":34}],"count":89}
{"noDocExamples":[{"type":"∀ {α : Type u_1} (a : Array α) (i : Fin (Array.size a)), Array.get a i = a[↑i]","name":"Array.get_eq_getElem","isProp":true,"depth":15}],"kind":"«term__[_]»","examples":[{"type":"∀ {α : Type u_1} (self : Array.PrefixTable α) {i : ℕ} (h : i < Array.size self.toArray), self.toArray[i].2 ≤ i","name":"Array.PrefixTable.valid","isProp":true,"doc":"Validity condition to help with termination proofs ","depth":19},{"type":"∀ {α β δ : Type} [inst : CanonicallyLinearOrderedAddCommMonoid δ] {C : Levenshtein.Cost α β δ} {xs : List α}\n  {ys : List β} (self : LevenshteinEstimator' C xs ys),\n  self.bound =\n    match self.pre_rev, (_ : List.reverse self.pre_rev ++ self.suff = ys) with\n    | [], split => ((↑self.distances)[0], List.length ys)\n    | x, split => (List.minimum_of_length_pos (_ : 0 < List.length ↑self.distances), List.length self.suff)","name":"LevenshteinEstimator'.bound_eq","isProp":true,"doc":"Predicate describing the current bound. ","depth":27}],"count":88}
{"noDocExamples":[],"kind":"«term_>>=_»","examples":[{"type":"∀ {m : Type u_1 → Type u_2} {α β : Type u_1} {q : β → Prop} {x : m α} [inst : Monad m] [inst_1 : LawfulMonad m]\n  {f : α → m β}, SatisfiesM (fun a => SatisfiesM q (f a)) x → SatisfiesM q (x >>= f)","name":"SatisfiesM.bind_pre","isProp":true,"doc":"`SatisfiesM` distributes over `>>=`, weakest precondition version. ","depth":18},{"type":"∀ {m : Type u_1 → Type u_2} {α β : Type u_1} {p : α → Prop} {x : m α} {q : β → Prop} [inst : Monad m]\n  [inst_1 : LawfulMonad m] {f : α → m β},\n  SatisfiesM p x → (∀ (a : α), p a → SatisfiesM q (f a)) → SatisfiesM q (x >>= f)","name":"SatisfiesM.bind","isProp":true,"doc":"`SatisfiesM` distributes over `>>=`, general version. ","depth":19},{"type":"{α β : Type u_1} →\n  [inst : DecidableEq β] →\n    (s : Set α) → [inst : Fintype ↑s] → (f : α → Set β) → ((a : α) → a ∈ s → Fintype ↑(f a)) → Fintype ↑(s >>= f)","name":"Set.fintypeBind","isProp":false,"doc":"If `s : Set α` is a set with `Fintype` instance and `f : α → Set β` is a function such that\neach `f a`, `a ∈ s`, has a `Fintype` structure, then `s >>= f` has a `Fintype` structure. ","depth":16}],"count":88}
{"noDocExamples":[],"kind":"«term_→A[_]_»","examples":[{"type":"{𝕜 : Type u_1} →\n  {V : Type u_3} →\n    {W : Type u_4} →\n      [inst : NormedAddCommGroup V] →\n        [inst_1 : NormedAddCommGroup W] →\n          [inst_2 : NontriviallyNormedField 𝕜] →\n            [inst_3 : NormedSpace 𝕜 V] → [inst_4 : NormedSpace 𝕜 W] → Norm (V →A[𝕜] W)","name":"ContinuousAffineMap.hasNorm","isProp":false,"doc":"Note that unlike the operator norm for linear maps, this norm is _not_ submultiplicative:\nwe do _not_ necessarily have `‖f.comp g‖ ≤ ‖f‖ * ‖g‖`. See `norm_comp_le` for what we can say. ","depth":23},{"type":"∀ {𝕜 : Type u_1} {V : Type u_2} {W : Type u_3} [inst : NontriviallyNormedField 𝕜] [inst_1 : NormedAddCommGroup V]\n  [inst_2 : NormedSpace 𝕜 V] [inst_3 : NormedAddCommGroup W] [inst_4 : NormedSpace 𝕜 W] {n : ℕ∞} (f : V →A[𝕜] W),\n  ContDiff 𝕜 n ⇑f","name":"ContinuousAffineMap.contDiff","isProp":true,"doc":"A continuous affine map between normed vector spaces is smooth. ","depth":33},{"type":"(R : Type u_1) →\n  {V : Type u_2} →\n    {W : Type u_3} →\n      (P : Type u_4) →\n        {Q : Type u_5} →\n          [inst : Ring R] →\n            [inst_1 : AddCommGroup V] →\n              [inst_2 : Module R V] →\n                [inst_3 : TopologicalSpace P] →\n                  [inst_4 : AddTorsor V P] →\n                    [inst_5 : AddCommGroup W] →\n                      [inst_6 : Module R W] → [inst_7 : TopologicalSpace Q] → [inst_8 : AddTorsor W Q] → Q → P →A[R] Q","name":"ContinuousAffineMap.const","isProp":false,"doc":"The constant map is a continuous affine map. ","depth":29}],"count":86}
{"noDocExamples":[],"kind":"«term_⩿_»","examples":[{"type":"∀ {α : Type u_1} {s t : Finset α}, s ⩿ t → s.val ⩿ t.val","name":"wcovby.finset_val","isProp":true,"doc":"**Alias** of the reverse direction of `Finset.val_wcovby_val`.","depth":10},{"type":"∀ {α : Type u_1} [inst : Preorder α] {a b : α}, a ≤ b → b ≤ a → a ⩿ b","name":"LE.le.wcovby_of_le","isProp":true,"doc":"**Alias** of `wcovby_of_le_of_le`.","depth":11},{"type":"∀ {α : Type u_1} [inst : PartialOrder α] {a b : α}, a ⩿ b → a = b ∨ a ⋖ b","name":"Wcovby.eq_or_covby","isProp":true,"doc":"**Alias** of the forward direction of `wcovby_iff_eq_or_covby`.","depth":12}],"count":86}
{"noDocExamples":[],"kind":"CategoryTheory.Limits.«term_⨿_»","examples":[{"type":"{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] →\n    [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C] →\n      (X Y : C) → [inst_2 : CategoryTheory.Limits.HasBinaryBiproduct X Y] → X ⊞ Y ≅ X ⨿ Y","name":"CategoryTheory.Limits.biprod.isoCoprod","isProp":false,"doc":"The canonical isomorphism between the chosen biproduct and the chosen coproduct. ","depth":14},{"type":"{C : Type u_1} →\n  [inst : CategoryTheory.Category.{u_2, u_1} C] →\n    [inst_1 : CategoryTheory.Limits.HasZeroObject C] →\n      [inst_2 : CategoryTheory.Limits.HasZeroMorphisms C] → (X : C) → 0 ⨿ X ≅ X","name":"CategoryTheory.Limits.zeroCoprodIso","isProp":false,"doc":"A zero object is a left unit for categorical coproduct. ","depth":15},{"type":"{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] →\n    [inst_1 : CategoryTheory.Limits.HasBinaryCoproducts C] →\n      (X Y : C) →\n        CategoryTheory.Limits.coprod.functor.obj (X ⨿ Y) ≅\n          CategoryTheory.Functor.comp (CategoryTheory.Limits.coprod.functor.obj Y)\n            (CategoryTheory.Limits.coprod.functor.obj X)","name":"CategoryTheory.Limits.coprod.functorLeftComp","isProp":false,"doc":"The coproduct functor can be decomposed. ","depth":18}],"count":86}
{"noDocExamples":[{"type":"∀ {X Y : Type u} {x : X} {y : Y}, (β_ X Y).hom (x, y) = (y, x)","name":"CategoryTheory.braiding_hom_apply","isProp":true,"depth":16},{"type":"∀ {X Y : Type u} {x : X} {y : Y}, (β_ X Y).inv (y, x) = (x, y)","name":"CategoryTheory.braiding_inv_apply","isProp":true,"depth":16}],"kind":"CategoryTheory.termβ_","examples":[{"type":"{C : Type u_1} →\n  {D : Type u_2} →\n    [inst : CategoryTheory.Category.{u_3, u_1} C] →\n      [inst_1 : CategoryTheory.Category.{u_4, u_2} D] →\n        [inst_2 : CategoryTheory.MonoidalCategory C] →\n          [inst_3 : CategoryTheory.MonoidalCategory D] →\n            (F : CategoryTheory.MonoidalFunctor C D) →\n              [inst_4 : CategoryTheory.Faithful F.toFunctor] →\n                [inst_5 : CategoryTheory.BraidedCategory D] →\n                  (β :\n                      (X Y : C) →\n                        CategoryTheory.MonoidalCategory.tensorObj X Y ≅ CategoryTheory.MonoidalCategory.tensorObj Y X) →\n                    (∀ (X Y : C),\n                        CategoryTheory.CategoryStruct.comp\n                            (CategoryTheory.LaxMonoidalFunctor.μ F.toLaxMonoidalFunctor X Y) (F.map (β X Y).hom) =\n                          CategoryTheory.CategoryStruct.comp (β_ (F.obj X) (F.obj Y)).hom\n                            (CategoryTheory.LaxMonoidalFunctor.μ F.toLaxMonoidalFunctor Y X)) →\n                      CategoryTheory.BraidedCategory C","name":"CategoryTheory.braidedCategoryOfFaithful","isProp":false,"doc":"Verifying the axioms for a braiding by checking that the candidate braiding is sent to a braiding\nby a faithful monoidal functor.\n","depth":33}],"count":86}
{"noDocExamples":[],"kind":"AddCommGroup.«term_≡_[PMOD_]»","examples":[{"type":"∀ {α : Type u_1} [inst : AddCommGroup α] {p a b : α}, a ≡ b [PMOD p] → b ≡ a [PMOD p]","name":"AddCommGroup.ModEq.symm","isProp":true,"doc":"**Alias** of the forward direction of `AddCommGroup.modEq_comm`.","depth":11},{"type":"∀ {α : Type u_1} [inst : AddCommGroupWithOne α] [inst_1 : CharZero α] {a b z : ℤ}, a ≡ b [PMOD z] → ↑a ≡ ↑b [PMOD ↑z]","name":"AddCommGroup.ModEq.int_cast","isProp":true,"doc":"**Alias** of the reverse direction of `AddCommGroup.int_cast_modEq_int_cast`.","depth":14},{"type":"∀ {α : Type u_1} [inst : AddCommGroupWithOne α] [inst_1 : CharZero α] {a b n : ℕ}, a ≡ b [MOD n] → ↑a ≡ ↑b [PMOD ↑n]","name":"AddCommGroup.ModEq.nat_cast","isProp":true,"doc":"**Alias** of the reverse direction of `AddCommGroup.nat_cast_modEq_nat_cast`.","depth":14}],"count":80}
{"noDocExamples":[],"kind":"FirstOrder.Language.«term_⊨__1»","examples":[{"type":"(V : Type w') →\n  [inst : FirstOrder.Language.Structure FirstOrder.Language.graph V] →\n    [inst : V ⊨ FirstOrder.Language.Theory.simpleGraph] → SimpleGraph V","name":"FirstOrder.Language.simpleGraphOfStructure","isProp":false,"doc":"Any model of the theory of simple graphs represents a simple graph. ","depth":7},{"type":"{L : FirstOrder.Language} →\n  (T : FirstOrder.Language.Theory L) →\n    (M : Type w) →\n      [inst : FirstOrder.Language.Structure L M] →\n        [inst : M ⊨ T] → [inst : Nonempty M] → FirstOrder.Language.Theory.ModelType T","name":"FirstOrder.Language.Theory.ModelType.of","isProp":false,"doc":"The object in the category of R-algebras associated to a type equipped with the appropriate\ntypeclasses. ","depth":9},{"type":"{L : FirstOrder.Language} →\n  (T : FirstOrder.Language.Theory L) →\n    (M : Type w') →\n      [inst : FirstOrder.Language.Structure L M] →\n        [inst_1 : Nonempty M] → [inst : M ⊨ T] → (α : Type w) → Set (FirstOrder.Language.Theory.CompleteType T α)","name":"FirstOrder.Language.Theory.realizedTypes","isProp":false,"doc":"A complete type `p` is realized in a particular structure when there is some\ntuple `v` whose type is `p`. ","depth":11}],"count":80}
{"noDocExamples":[],"kind":"Asymptotics.«term_=Θ[_]_»","examples":[{"type":"∀ {α : Type u_1} {l : Filter α} {f : α → ℝ},\n  ((fun x => Real.exp (f x)) =Θ[l] fun x => 1) ↔ Filter.IsBoundedUnder (fun x x_1 => x ≤ x_1) l fun x => |f x|","name":"Real.isTheta_exp_comp_one","isProp":true,"doc":"`Real.exp (f x)` is bounded away from zero and infinity along a filter `l` if and only if\n`|f x|` is bounded from above along this filter. ","depth":13},{"type":"∀ {α : Type u_1} {E : Type u_3} {F' : Type u_7} [inst : Norm E] [inst_1 : SeminormedAddCommGroup F'] {f : α → E}\n  {g' : α → F'} {l : Filter α}, (f =Θ[l] fun x => ‖g' x‖) → f =Θ[l] g'","name":"Asymptotics.IsTheta.of_norm_right","isProp":true,"doc":"**Alias** of the forward direction of `Asymptotics.isTheta_norm_right`.","depth":17},{"type":"∀ {α : Type u_1} [inst : Fintype α] [inst_1 : Nonempty α] {T : ℕ → ℝ} {g : ℝ → ℝ} {a b : α → ℝ} {r : α → ℕ → ℕ},\n  AkraBazziRecurrence T g a b r → T =Θ[Filter.atTop] AkraBazziRecurrence.asympBound g a b","name":"AkraBazziRecurrence.isTheta_asympBound","isProp":true,"doc":"The **Akra-Bazzi theorem**: `T ∈ Θ(n^p (1 + ∑_u^n g(u) / u^{p+1}))` ","depth":17}],"count":77}
{"noDocExamples":[{"type":"∀ {α : Type u_2} [inst : Inf α] [inst_1 : HImp α] (a b : α), a ⇔ b = (b ⇨ a) ⊓ (a ⇨ b)","name":"bihimp_def","isProp":true,"depth":12},{"type":"∀ {α : Type u_2} [inst : GeneralizedHeytingAlgebra α], IsCommutative α fun x x_1 => x ⇔ x_1","name":"bihimp_isCommutative","isProp":true,"depth":12},{"type":"∀ {α : Type u_2} [inst : GeneralizedHeytingAlgebra α] (a b : α), a ⇔ (a ⇨ b) = a ⊓ b","name":"bihimp_himp_eq_inf","isProp":true,"depth":13}],"kind":"«term_⇔_»","examples":[],"count":76}
{"noDocExamples":[],"kind":"«term_ˢʸᵐ»","examples":[{"type":"{α : Type u_1} → α ≃ αˢʸᵐ","name":"SymAlg.sym","isProp":false,"doc":"The element of `SymAlg α` that represents `a : α`. ","depth":3},{"type":"{α : Type u_1} → αˢʸᵐ ≃ α","name":"SymAlg.unsym","isProp":false,"doc":"The element of `α` represented by `x : αˢʸᵐ`. ","depth":4},{"type":"{α : Type u_1} → [inst : Ring α] → [inst : Invertible 2] → NonAssocRing αˢʸᵐ","name":"SymAlg.instNonAssocRingSymAlg","isProp":false,"doc":"The symmetrization of a real (unital, associative) algebra is a non-associative ring. ","depth":10}],"count":75}
{"noDocExamples":[],"kind":"CategoryTheory.Limits.«term∐_»","examples":[{"type":"{J : Type w} →\n  {C : Type u} →\n    [inst : CategoryTheory.Category.{v, u} C] →\n      [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C] →\n        (f : J → C) → [inst_2 : CategoryTheory.Limits.HasBiproduct f] → ⨁ f ≅ ∐ f","name":"CategoryTheory.Limits.biproduct.isoCoproduct","isProp":false,"doc":"The canonical isomorphism between the chosen biproduct and the chosen coproduct. ","depth":14},{"type":"{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] →\n    (I : CategoryTheory.Limits.MultispanIndex C) →\n      [inst_1 : CategoryTheory.Limits.HasMulticoequalizer I] →\n        [inst_2 : CategoryTheory.Limits.HasCoproduct I.left] →\n          [inst_3 : CategoryTheory.Limits.HasCoproduct I.right] → ∐ I.right ⟶ CategoryTheory.Limits.multicoequalizer I","name":"CategoryTheory.Limits.Multicoequalizer.sigmaπ","isProp":false,"doc":"The canonical projection `∐ I.right ⟶ multicoequalizer I`. ","depth":16},{"type":"{α : Type} → [inst : Fintype α] → (X : α → CompHaus) → ↑(CompHaus.finiteCoproduct X).toTop ≃ₜ ↑(∐ X).toTop","name":"CompHaus.coproductHomeoCoproduct","isProp":false,"doc":"The homeomorphism from the explicit finite coproducts to the abstract coproduct. ","depth":18}],"count":75}
{"noDocExamples":[],"kind":"«term_≃ₛₗ[_]_»","examples":[{"type":"{R : Type u_16} →\n  {S : Type u_17} →\n    [inst : Semiring R] →\n      [inst_1 : Semiring S] →\n        {σ : R →+* S} →\n          {σ' : S →+* R} →\n            [inst_2 : RingHomInvPair σ σ'] →\n              [inst_3 : RingHomInvPair σ' σ] →\n                {M : Type u_18} →\n                  {M₂ : Type u_19} →\n                    [inst_4 : AddCommMonoid M] →\n                      [inst_5 : AddCommMonoid M₂] →\n                        [inst_6 : Module R M] → [inst_7 : Module S M₂] → (M ≃ₛₗ[σ] M₂) → M ≃+ M₂","name":"LinearEquiv.toAddEquiv","isProp":false,"doc":"The additive equivalence of types underlying a linear equivalence. ","depth":29},{"type":"{R : Type u_1} →\n  {S : Type u_6} →\n    {M : Type u_7} →\n      {M₂ : Type u_9} →\n        [inst : Semiring R] →\n          [inst_1 : Semiring S] →\n            [inst_2 : AddCommMonoid M] →\n              [inst_3 : AddCommMonoid M₂] →\n                {module_M : Module R M} →\n                  {module_S_M₂ : Module S M₂} →\n                    {σ : R →+* S} →\n                      {σ' : S →+* R} →\n                        {re₁ : RingHomInvPair σ σ'} → {re₂ : RingHomInvPair σ' σ} → (M ≃ₛₗ[σ] M₂) → M₂ ≃ₛₗ[σ'] M","name":"LinearEquiv.symm","isProp":false,"doc":"Linear equivalences are symmetric. ","depth":29},{"type":"{R : Type u_17} →\n  {S : Type u_18} →\n    [inst : Semiring R] →\n      [inst_1 : Semiring S] →\n        {σ : R →+* S} →\n          {σ' : S →+* R} →\n            [inst_2 : RingHomInvPair σ σ'] →\n              [inst_3 : RingHomInvPair σ' σ] →\n                {M : Type u_19} →\n                  {M₂ : Type u_20} →\n                    [inst_4 : AddCommMonoid M] →\n                      [inst_5 : AddCommMonoid M₂] →\n                        [inst_6 : Module R M] → [inst_7 : Module S M₂] → (M ≃ₛₗ[σ] M₂) → M → M₂","name":"LinearEquiv.Simps.apply","isProp":false,"doc":"See Note [custom simps projection] ","depth":29}],"count":74}
{"noDocExamples":[],"kind":"«term_→⋆ₙₐ[_]_»","examples":[{"type":"(R : Type u_1) →\n  (A : Type u_2) →\n    [inst : Monoid R] →\n      [inst_1 : NonUnitalNonAssocSemiring A] → [inst_2 : DistribMulAction R A] → [inst_3 : Star A] → A →⋆ₙₐ[R] A","name":"NonUnitalStarAlgHom.id","isProp":false,"doc":"The identity as a non-unital ⋆-algebra homomorphism. ","depth":16},{"type":"(R : Type u_1) →\n  (A : Type u_2) →\n    [inst : CommSemiring R] →\n      [inst_1 : StarAddMonoid R] →\n        [inst_2 : NonUnitalSemiring A] → [inst_3 : Star A] → [inst_4 : Module R A] → A →⋆ₙₐ[R] Unitization R A","name":"Unitization.inrNonUnitalStarAlgHom","isProp":false,"doc":"The coercion from a non-unital `R`-algebra `A` to its unitization `unitization R A`\nrealized as a non-unital star algebra homomorphism. ","depth":19},{"type":"(R : Type u_1) →\n  (A : Type u_2) →\n    (B : Type u_3) →\n      [inst : Monoid R] →\n        [inst_1 : NonUnitalNonAssocSemiring A] →\n          [inst_2 : DistribMulAction R A] →\n            [inst_3 : StarAddMonoid A] →\n              [inst_4 : NonUnitalNonAssocSemiring B] →\n                [inst_5 : DistribMulAction R B] → [inst_6 : StarAddMonoid B] → A →⋆ₙₐ[R] A × B","name":"NonUnitalStarAlgHom.inl","isProp":false,"doc":"The left injection into a product is a non-unital algebra homomorphism. ","depth":20}],"count":74}
{"noDocExamples":[],"kind":"Lean.Parser.Term.let_fun","examples":[{"type":"∀ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] [inst_2 : MetricSpace P]\n  [inst_3 : NormedAddTorsor V P] {ι : Type u_3} {s : Finset ι} {w₁ w₂ : ι → ℝ} (p : ι → P),\n  (Finset.sum s fun i => w₁ i) = 1 →\n    (Finset.sum s fun i => w₂ i) = 1 →\n      let_fun a₁ := (Finset.affineCombination ℝ s p) w₁;\n      let_fun a₂ := (Finset.affineCombination ℝ s p) w₂;\n      dist a₁ a₂ * dist a₁ a₂ =\n        (-Finset.sum s fun i₁ =>\n              Finset.sum s fun i₂ => (w₁ - w₂) i₁ * (w₁ - w₂) i₂ * (dist (p i₁) (p i₂) * dist (p i₁) (p i₂))) /\n          2","name":"EuclideanGeometry.dist_affineCombination","isProp":true,"doc":"The distance between two points given with `affineCombination`,\nin terms of the pairwise distances between the points in that\ncombination. ","depth":39},{"type":"(V W : SemiNormedGroupCat) →\n  let_fun this := fun V W => inferInstanceAs (AddGroup (NormedAddGroupHom ↑V ↑W));\n  (V ⟶ W) →+ (SemiNormedGroupCat.completion.obj V ⟶ SemiNormedGroupCat.completion.obj W)","name":"SemiNormedGroupCat.completion.mapHom","isProp":false,"doc":"Given a normed group hom `V ⟶ W`, this defines the associated morphism\nfrom the completion of `V` to the completion of `W`.\nThe difference from the definition obtained from the functoriality of completion is in that the\nmap sending a morphism `f` to the associated morphism of completions is itself additive. ","depth":20},{"type":"∀ {ι : Type u_1} {B : Type u_2} {F : Type u_3} [inst : TopologicalSpace B] [inst_1 : TopologicalSpace F]\n  (Z : FiberBundleCore ι B F) (v : F),\n  (∀ (i j : ι),\n      ∀ x ∈ FiberBundleCore.baseSet Z i ∩ FiberBundleCore.baseSet Z j, FiberBundleCore.coordChange Z i j x v = v) →\n    Continuous\n      (let_fun this := fun x => { proj := x, snd := v };\n      this)","name":"FiberBundleCore.continuous_const_section","isProp":true,"doc":"If an element of `F` is invariant under all coordinate changes, then one can define a\ncorresponding section of the fiber bundle, which is continuous. This applies in particular to the\nzero section of a vector bundle. Another example (not yet defined) would be the identity\nsection of the endomorphism bundle of a vector bundle. ","depth":24}],"count":72}
{"noDocExamples":[],"kind":"CategoryTheory.Limits.«term∏_»","examples":[{"type":"{ι : Type v} → (α : ι → TopCatMax) → ∏ α ≅ TopCat.of ((i : ι) → ↑(α i))","name":"TopCat.piIsoPi","isProp":false,"doc":"The product is homeomorphic to the product of the underlying spaces,\nequipped with the product topology.\n","depth":12},{"type":"{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] →\n    {J : Type w} →\n      [inst_1 : CategoryTheory.SmallCategory J] →\n        [inst_2 : CategoryTheory.Limits.HasLimitsOfSize.{w, w, v, u} C] →\n          (F : CategoryTheory.Functor J C) → CategoryTheory.Limits.limit F ⟶ ∏ fun j => F.obj j","name":"CategoryTheory.Limits.limitSubobjectProduct","isProp":false,"doc":"A limit can be realised as a subobject of a product. ","depth":19},{"type":"∀ {β : Type v} {f g : β → Type v} (α : (j : β) → f j ⟶ g j) (b : β) (x : ∏ fun b => f b),\n  CategoryTheory.Limits.Pi.π g b (CategoryTheory.Limits.Pi.map α x) = α b (CategoryTheory.Limits.Pi.π f b x)","name":"CategoryTheory.Limits.Types.pi_map_π_apply'","isProp":true,"doc":"A restatement of `Types.Limit.map_π_apply` that uses `Pi.π` and `Pi.map`,\nwith specialized universes. ","depth":20}],"count":71}
{"noDocExamples":[],"kind":"TypeVec.«term_:::_»","examples":[{"type":"{n : ℕ} →\n  {C : TypeVec.{u_1} (n + 1) → Sort u} →\n    ((α : TypeVec.{u_1} n) → (β : Type u_1) → C (α ::: β)) → (γ : TypeVec.{u_1} (n + 1)) → C γ","name":"TypeVec.append1Cases","isProp":false,"doc":"cases on `(n+1)-length` vectors ","depth":11},{"type":"{n : ℕ} → {α : TypeVec.{u_1} (n + 1)} → TypeVec.Arrow (TypeVec.drop α ::: TypeVec.last α) α","name":"TypeVec.fromAppend1DropLast","isProp":false,"doc":"stitch two bits of a vector back together ","depth":11},{"type":"{n : ℕ} → {α : TypeVec.{u_1} (n + 1)} → TypeVec.Arrow α (TypeVec.drop α ::: TypeVec.last α)","name":"TypeVec.toAppend1DropLast","isProp":false,"doc":"decompose a vector into its prefix appended with its last element ","depth":11}],"count":71}
{"noDocExamples":[],"kind":"«DistribMulActionHomLocal≺»","examples":[{"type":"∀ {M : Type u_5} [inst : Monoid M] {A : Type u_6} [inst_1 : AddMonoid A] [inst_2 : DistribMulAction M A] {B : Type u_8}\n  [inst_3 : AddMonoid B] [inst_4 : DistribMulAction M B] (self : A →+[M] B),\n  MulActionHom.toFun self.toMulActionHom 0 = 0","name":"DistribMulActionHom.map_zero'","isProp":true,"doc":"The proposition that the function preserves 0 ","depth":23},{"type":"{M : Type u_5} →\n  [inst : Monoid M] →\n    {R : Type u_11} →\n      [inst_1 : Semiring R] →\n        [inst_2 : MulSemiringAction M R] →\n          {S : Type u_13} → [inst_3 : Semiring S] → [inst_4 : MulSemiringAction M S] → (R →+*[M] S) → R →+[M] S","name":"MulSemiringActionHom.toDistribMulActionHom","isProp":false,"doc":"Reinterpret an equivariant ring homomorphism as an equivariant additive monoid homomorphism. ","depth":19},{"type":"{M : Type u_5} →\n  [inst : Monoid M] →\n    {A : Type u_6} →\n      [inst_1 : AddMonoid A] →\n        [inst_2 : DistribMulAction M A] →\n          {B : Type u_8} → [inst_3 : AddMonoid B] → [inst_4 : DistribMulAction M B] → (A →+[M] B) → A →[M] B","name":"DistribMulActionHom.toMulActionHom","isProp":false,"doc":"Reinterpret an equivariant additive monoid homomorphism as an equivariant function. ","depth":19}],"count":70}
{"noDocExamples":[],"kind":"«term_≃ᵃⁱ[_]_»","examples":[{"type":"(𝕜 : Type u_1) →\n  {V : Type u_2} →\n    (P : Type u_8) →\n      [inst : NormedField 𝕜] →\n        [inst_1 : SeminormedAddCommGroup V] →\n          [inst_2 : NormedSpace 𝕜 V] → [inst_3 : PseudoMetricSpace P] → [inst_4 : NormedAddTorsor V P] → P ≃ᵃⁱ[𝕜] P","name":"AffineIsometryEquiv.refl","isProp":false,"doc":"Identity map as an `AffineIsometryEquiv`. ","depth":22},{"type":"(𝕜 : Type u_1) →\n  {V : Type u_2} →\n    {P : Type u_8} →\n      [inst : NormedField 𝕜] →\n        [inst_1 : SeminormedAddCommGroup V] →\n          [inst_2 : NormedSpace 𝕜 V] → [inst_3 : PseudoMetricSpace P] → [inst_4 : NormedAddTorsor V P] → P → P ≃ᵃⁱ[𝕜] P","name":"AffineIsometryEquiv.pointReflection","isProp":false,"doc":"Point reflection in `x` as an affine isometric automorphism. ","depth":23},{"type":"{𝕜 : Type u_1} →\n  {V : Type u_2} →\n    {P : Type u_8} →\n      [inst : NormedField 𝕜] →\n        [inst_1 : SeminormedAddCommGroup V] →\n          [inst_2 : NormedSpace 𝕜 V] →\n            [inst_3 : PseudoMetricSpace P] → [inst_4 : NormedAddTorsor V P] → Group (P ≃ᵃⁱ[𝕜] P)","name":"AffineIsometryEquiv.instGroupAffineIsometryEquiv","isProp":false,"doc":"The group of affine isometries of a `NormedAddTorsor`, `P`. ","depth":23}],"count":70}
{"noDocExamples":[],"kind":"CategoryTheory.Limits.«term⊥__»","examples":[{"type":"{C : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} C] →\n    [inst_1 : CategoryTheory.Limits.HasInitial C] → CategoryTheory.Limits.IsInitial (⊥_ C)","name":"CategoryTheory.Limits.initialIsInitial","isProp":false,"doc":"An initial object is initial. ","depth":7},{"type":"⊥_ TopCat ≅ TopCat.of PEmpty.{u + 1}","name":"TopCat.initialIsoPEmpty","isProp":false,"doc":"The initial object of `Top` is `PEmpty`. ","depth":8},{"type":"⊥_ Type u ≅ PEmpty.{u + 1}","name":"CategoryTheory.Limits.Types.initialIso","isProp":false,"doc":"The initial object in `Type u` is `PEmpty`. ","depth":8}],"count":69}
{"noDocExamples":[],"kind":"Nat.«term⌊_⌋₊»","examples":[{"type":"∀ {α : Type u_2} [inst : LinearOrderedSemifield α] [inst_1 : FloorSemiring α] (m n : ℕ), ⌊↑m / ↑n⌋₊ = m / n","name":"Nat.floor_div_eq_div","isProp":true,"doc":"Natural division is the floor of field division. ","depth":17},{"type":"∀ (u : ℕ → ℝ) (l : ℝ),\n  Monotone u →\n    ∀ (c : ℕ → ℝ),\n      (∀ (k : ℕ), 1 < c k) →\n        Filter.Tendsto c Filter.atTop (nhds 1) →\n          (∀ (k : ℕ), Filter.Tendsto (fun n => u ⌊c k ^ n⌋₊ / ↑⌊c k ^ n⌋₊) Filter.atTop (nhds l)) →\n            Filter.Tendsto (fun n => u n / ↑n) Filter.atTop (nhds l)","name":"tendsto_div_of_monotone_of_tendsto_div_floor_pow","isProp":true,"doc":"If a monotone sequence `u` is such that `u ⌊c^n⌋₊ / ⌊c^n⌋₊` converges to a limit `l` for all\n`c > 1`, then `u n / n` tends to `l`. It is even enough to have the assumption for a sequence of\n`c`s converging to `1`. ","depth":22},{"type":"∀ (N : ℕ) {j : ℝ},\n  0 < j →\n    ∀ {c : ℝ},\n      1 < c →\n        (Finset.sum (Finset.filter (fun x => j < ↑⌊c ^ x⌋₊) (Finset.range N)) fun i => 1 / ↑⌊c ^ i⌋₊ ^ 2) ≤\n          c ^ 5 * (c - 1)⁻¹ ^ 3 / j ^ 2","name":"sum_div_nat_floor_pow_sq_le_div_sq","isProp":true,"doc":"The sum of `1/⌊c^i⌋₊^2` above a threshold `j` is comparable to `1/j^2`, up to a multiplicative\nconstant. ","depth":22}],"count":69}
{"noDocExamples":[],"kind":"«term_≃ₗ⁅_⁆_»","examples":[{"type":"{R : Type u} → {L₁ : Type v} → [inst : CommRing R] → [inst_1 : LieRing L₁] → [inst_2 : LieAlgebra R L₁] → L₁ ≃ₗ⁅R⁆ L₁","name":"LieEquiv.refl","isProp":false,"doc":"Lie algebra equivalences are reflexive. ","depth":13},{"type":"∀ {R : Type u} {L : Type v} {L' : Type w} [inst : CommRing R] [inst_1 : LieRing L] [inst_2 : LieAlgebra R L]\n  [inst_3 : LieRing L'] [inst_4 : LieAlgebra R L'] (self : L ≃ₗ⁅R⁆ L'), Function.RightInverse self.invFun self.toFun","name":"LieEquiv.right_inv","isProp":true,"doc":"The inverse function of an equivalence of Lie algebras is a right inverse of the underlying\nfunction. ","depth":24},{"type":"{R : Type u} →\n  {L : Type v} →\n    {L' : Type w} →\n      [inst : CommRing R] →\n        [inst_1 : LieRing L] →\n          [inst_2 : LieAlgebra R L] → [inst_3 : LieRing L'] → [inst_4 : LieAlgebra R L'] → (L ≃ₗ⁅R⁆ L') → L' → L","name":"LieEquiv.invFun","isProp":false,"doc":"The inverse function of an equivalence of Lie algebras ","depth":17}],"count":69}
{"noDocExamples":[],"kind":"Int.«term_≡_[ZMOD_]»","examples":[{"type":"∀ {n a b : ℤ}, a ≡ b [ZMOD n] → n ∣ b - a","name":"Int.ModEq.dvd","isProp":true,"doc":"**Alias** of the forward direction of `Int.modEq_iff_dvd`.","depth":11},{"type":"∀ {n a b : ℤ}, n ∣ b - a → a ≡ b [ZMOD n]","name":"Int.modEq_of_dvd","isProp":true,"doc":"**Alias** of the reverse direction of `Int.modEq_iff_dvd`.","depth":11},{"type":"∀ {p : ℕ}, Nat.Prime p → ∀ {n : ℤ}, IsCoprime n ↑p → n ^ (p - 1) ≡ 1 [ZMOD ↑p]","name":"Int.ModEq.pow_card_sub_one_eq_one","isProp":true,"doc":"**Fermat's Little Theorem**: for all `a : ℤ` coprime to `p`, we have\n`a ^ (p - 1) ≡ 1 [ZMOD p]`. ","depth":13}],"count":68}
{"noDocExamples":[],"kind":"«term_→ₗᵢ[_]_»","examples":[{"type":"∀ {ι : Type u_1} {𝕜 : Type u_2} [inst : IsROrC 𝕜] {E : Type u_3} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : InnerProductSpace 𝕜 E] [cplt : CompleteSpace E] {G : ι → Type u_4}\n  [inst_3 : (i : ι) → NormedAddCommGroup (G i)] [inst_4 : (i : ι) → InnerProductSpace 𝕜 (G i)]\n  {V : (i : ι) → G i →ₗᵢ[𝕜] E} (hV : OrthogonalFamily 𝕜 G V) [inst_5 : ∀ (i : ι), CompleteSpace (G i)],\n  LinearMap.range (OrthogonalFamily.linearIsometry hV).toLinearMap =\n    Submodule.topologicalClosure (⨆ i, LinearMap.range (V i).toLinearMap)","name":"OrthogonalFamily.range_linearIsometry","isProp":true,"doc":"The canonical linear isometry from the `lp 2` of a mutually orthogonal family of subspaces of\n`E` into E, has range the closure of the span of the subspaces. ","depth":42},{"type":"{K : Type u_1} → [inst : IsROrC K] → ℝ →ₗᵢ[ℝ] K","name":"IsROrC.ofRealLi","isProp":false,"doc":"The ℝ → K coercion, as a linear isometry ","depth":13},{"type":"{R : Type u_1} →\n  {E : Type u_5} → [inst : Semiring R] → [inst_1 : SeminormedAddCommGroup E] → [inst_2 : Module R E] → E →ₗᵢ[R] E","name":"LinearIsometry.id","isProp":false,"doc":"The identity linear isometry. ","depth":16}],"count":66}
{"noDocExamples":[{"type":"∀ {α : Type u_2} [inst : LinearOrderedRing α] [inst_1 : FloorRing α] (a : α), ⌊a⌋ ≤ ⌈a⌉","name":"Int.floor_le_ceil","isProp":true,"depth":10},{"type":"∀ {α : Type u_2} [inst : LinearOrderedRing α] [inst_1 : FloorRing α] (a : α), ⌈a⌉ ≤ ⌊a⌋ + 1","name":"Int.ceil_le_floor_add_one","isProp":true,"depth":11}],"kind":"Int.«term⌈_⌉»","examples":[{"type":"∀ {ξ q : ℚ}, |ξ - q| < 1 / ↑q.den ^ 2 → q.den ≤ ξ.den ∧ ⌈ξ * ↑q.den⌉ - 1 ≤ q.num ∧ q.num ≤ ⌊ξ * ↑q.den⌋ + 1","name":"Rat.den_le_and_le_num_le_of_sub_lt_one_div_den_sq","isProp":true,"doc":"If `ξ` is rational, then the good rational approximations to `ξ` have bounded\nnumerator and denominator. ","depth":17}],"count":66}
{"noDocExamples":[],"kind":"TopCat.Presheaf.«term__*_»","examples":[{"type":"{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] →\n    {X : TopCat} → (ℱ : TopCat.Presheaf C X) → CategoryTheory.CategoryStruct.id X _* ℱ ≅ ℱ","name":"TopCat.Presheaf.Pushforward.id","isProp":false,"doc":"The natural isomorphism between the pushforward of a presheaf along the identity continuous map\nand the original presheaf. ","depth":12},{"type":"∀ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] {X Y : TopCat} (f : X ⟶ Y) {F : TopCat.Presheaf C X},\n  TopCat.Presheaf.IsSheaf F → TopCat.Presheaf.IsSheaf (f _* F)","name":"TopCat.Sheaf.pushforward_sheaf_of_sheaf","isProp":true,"doc":"The pushforward of a sheaf (by a continuous map) is a sheaf.\n","depth":14},{"type":"{C : Type u_1} →\n  [inst : CategoryTheory.Category.{u_2, u_1} C] →\n    {X Y : AlgebraicGeometry.PresheafedSpace C} → (H : X ≅ Y) → Y.presheaf ≅ H.hom.base _* X.presheaf","name":"AlgebraicGeometry.PresheafedSpace.sheafIsoOfIso","isProp":false,"doc":"Isomorphic `PresheafedSpace`s have naturally isomorphic presheaves. ","depth":16}],"count":66}
{"noDocExamples":[],"kind":"OmegaCompletePartialOrder.«term_→𝒄_»","examples":[{"type":"∀ {α : Type u} {β : Type v} [inst : OmegaCompletePartialOrder α] [inst_1 : OmegaCompletePartialOrder β] (self : α →𝒄 β),\n  OmegaCompletePartialOrder.Continuous self.toOrderHom","name":"OmegaCompletePartialOrder.ContinuousHom.cont","isProp":true,"doc":"The underlying function of a `ContinuousHom` is continuous, i.e. it preserves `ωSup` ","depth":11},{"type":"{α : Type u} →\n  {β : Type v} →\n    [inst : OmegaCompletePartialOrder α] →\n      [inst_1 : OmegaCompletePartialOrder β] → OmegaCompletePartialOrder.Chain (α →𝒄 β) → α →𝒄 β","name":"OmegaCompletePartialOrder.ContinuousHom.ωSup","isProp":false,"doc":"The `ωSup` operator for continuous functions, which takes the pointwise countable supremum\nof the functions in the `ω`-chain. ","depth":12},{"type":"∀ {α : Type u} {β : Type v} [inst : OmegaCompletePartialOrder α] [inst_1 : OmegaCompletePartialOrder β]\n  (c₀ : OmegaCompletePartialOrder.Chain (α →𝒄 β)) (c₁ : OmegaCompletePartialOrder.Chain α) (z : β),\n  (∀ (i j : ℕ), (c₀ i) (c₁ j) ≤ z) ↔ ∀ (i : ℕ), (c₀ i) (c₁ i) ≤ z","name":"OmegaCompletePartialOrder.ContinuousHom.forall_forall_merge","isProp":true,"doc":"When proving that a chain of applications is below a bound `z`, it suffices to consider the\nfunctions and values being selected from the same index in the chains.\n\nThis lemma is more specific than necessary, i.e. `c₀` only needs to be a\nchain of monotone functions, but it is only used with continuous functions. ","depth":32}],"count":66}
{"noDocExamples":[],"kind":"Lean.Parser.Term.do","examples":[{"type":"∀ (cf cg : Nat.Partrec.Code) (a k : ℕ),\n  Nat.Partrec.Code.eval (Nat.Partrec.Code.prec cf cg) (Nat.pair a (Nat.succ k)) = do\n    let ih ← Nat.Partrec.Code.eval (Nat.Partrec.Code.prec cf cg) (Nat.pair a k)\n    Nat.Partrec.Code.eval cg (Nat.pair a (Nat.pair k ih))","name":"Nat.Partrec.Code.eval_prec_succ","isProp":true,"doc":"Helper lemma for the evaluation of `prec` in the recursive case. ","depth":12},{"type":"∀ (m : Type u → Type v) [inst : Monad m],\n  (∀ {α : Type u} (x : m α), id <$> x = x) →\n    (∀ {α β : Type u} (x : α) (f : α → m β), pure x >>= f = f x) →\n      (∀ {α β γ : Type u} (x : m α) (f : α → m β) (g : β → m γ), x >>= f >>= g = x >>= fun x => f x >>= g) →\n        autoParam (∀ {α β : Type u} (x : α) (y : m β), Functor.mapConst x y = Function.const β x <$> y) _auto✝ →\n          autoParam\n              (∀ {α β : Type u} (x : m α) (y : m β),\n                (SeqLeft.seqLeft x fun x => y) = do\n                  let a ← x\n                  let _ ← y\n                  pure a)\n              _auto✝¹ →\n            autoParam\n                (∀ {α β : Type u} (x : m α) (y : m β),\n                  (SeqRight.seqRight x fun x => y) = do\n                    let _ ← x\n                    y)\n                _auto✝² →\n              autoParam\n                  (∀ {α β : Type u} (f : α → β) (x : m α),\n                    (do\n                        let y ← x\n                        pure (f y)) =\n                      f <$> x)\n                  _auto✝³ →\n                autoParam\n                    (∀ {α β : Type u} (f : m (α → β)) (x : m α),\n                      (do\n                          let x_1 ← f\n                          x_1 <$> x) =\n                        Seq.seq f fun x_1 => x)\n                    _auto✝⁴ →\n                  LawfulMonad m","name":"LawfulMonad.mk'","isProp":true,"doc":"An alternative constructor for `LawfulMonad` which has more\ndefaultable fields in the common case.\n","depth":28},{"type":"Bool →\n  List Lean.Expr →\n    optParam Linarith.LinarithConfig\n        {\n          discharger := do\n            let __do_lift ←\n              do\n                let info ← Lean.MonadRef.mkInfoFromRefPos\n                let _ ← Lean.getCurrMacroScope\n                let _ ← Lean.getMainModule\n                pure\n                    {\n                      raw :=\n                        Lean.Syntax.node2 info `Mathlib.Tactic.Ring.ring1 (Lean.Syntax.atom info \"ring1\")\n                          (Lean.Syntax.node info `null #[]) }\n            Lean.Elab.Tactic.evalTactic __do_lift.raw,\n          exfalso := true, transparency := Lean.Meta.TransparencyMode.reducible, splitHypotheses := true,\n          splitNe := false, preprocessors := none, oracle := none } →\n      Lean.MVarId → Lean.MetaM Unit","name":"Linarith.linarith","isProp":false,"doc":"`linarith only_on hyps cfg` tries to close the goal using linear arithmetic. It fails\nif it does not succeed at doing this.\n\n* `hyps` is a list of proofs of comparisons to include in the search.\n* If `only_on` is true, the search will be restricted to `hyps`. Otherwise it will use all\n  comparisons in the local context.\n* If `cfg.transparency := semireducible`,\n  it will unfold semireducible definitions when trying to match atomic expressions.\n","depth":33}],"count":64}
{"noDocExamples":[],"kind":"Relator.«term_⇒_»","examples":[{"type":"{α : Sort u_1} →\n  {β : Sort u_2} →\n    {s₁ : Setoid α} → {s₂ : Setoid β} → (f : α → β) → (Setoid.r ⇒ Setoid.r) f f → Quotient s₁ → Quotient s₂","name":"Quotient.map'","isProp":false,"doc":"Map a function `f : α → β` that sends equivalent elements to equivalent elements\nto a function `Quotient sa → Quotient sb`. Useful to define unary operations on quotients. ","depth":14},{"type":"{α : Sort u_1} →\n  {β : Sort u_2} → {ra : α → α → Prop} → {rb : β → β → Prop} → (f : α → β) → (ra ⇒ rb) f f → Quot ra → Quot rb","name":"Quot.map","isProp":false,"doc":"Map a function `f : α → β` such that `ra x y` implies `rb (f x) (f y)`\nto a map `Quot ra → Quot rb`. ","depth":14},{"type":"{α : Type u_1} →\n  {β : Type u_2} →\n    {l : Filter α} →\n      {γ : Sort u_5} → Filter.Germ l β → (F : (α → β) → γ) → (Filter.EventuallyEq l ⇒ fun x x_1 => x = x_1) F F → γ","name":"Filter.Germ.liftOn","isProp":false,"doc":"Given a germ `f : Germ l β` and a function `F : (α → β) → γ` sending eventually equal functions\nto the same value, returns the value `F` takes on functions having germ `f` at `l`. ","depth":16}],"count":64}
{"noDocExamples":[],"kind":"«term￢_»","examples":[{"type":"∀ {α : Type u_2} [inst : CoheytingAlgebra α] {a b : α}, Codisjoint b a → ￢a ≤ b","name":"Codisjoint.hnot_le_left","isProp":true,"doc":"**Alias** of the reverse direction of `hnot_le_iff_codisjoint_left`.","depth":15},{"type":"∀ {α : Type u_2} [inst : CoheytingAlgebra α] {a b : α}, Codisjoint a b → ￢a ≤ b","name":"Codisjoint.hnot_le_right","isProp":true,"doc":"**Alias** of the reverse direction of `hnot_le_iff_codisjoint_right`.","depth":15},{"type":"∀ {α : Type u_4} [self : CoheytingAlgebra α] (a : α), ⊤ \\ a = ￢a","name":"CoheytingAlgebra.top_sdiff","isProp":true,"doc":"`⊤ \\ a` is `￢a` ","depth":17}],"count":63}
{"noDocExamples":[],"kind":"«term_&&_»","examples":[{"type":"∀ (x y : Bool), (!(x && y)) = (!x || !y)","name":"Bool.not_and","isProp":true,"doc":"De Morgan's law for boolean and ","depth":7},{"type":"∀ (x y : Bool), (!(x || y)) = (!x && !y)","name":"Bool.not_or","isProp":true,"doc":"De Morgan's law for boolean or ","depth":7},{"type":"∀ {m x y : Bool}, (x && m) = (y && m) ∧ (x || m) = (y || m) ↔ x = y","name":"Bool.and_or_inj_right'","isProp":true,"doc":"**Alias** of `Bool.and_or_inj_right_iff`.","depth":11}],"count":63}
{"noDocExamples":[{"type":"∀ (n : ℕ), Nat.div2 (Nat.succ n) = bif Nat.bodd n then Nat.succ (Nat.div2 n) else Nat.div2 n","name":"Nat.div2_succ","isProp":true,"depth":6},{"type":"∀ {α : Type u} (b : Bool) (a : α), (bif b then a else a) = a","name":"Bool.cond_self","isProp":true,"depth":9}],"kind":"boolIfThenElse","examples":[{"type":"∀ (p : ENNReal) (h : p ≤ 1), PMF.binomial p h 1 = PMF.map (fun x => bif x then 1 else 0) (PMF.bernoulli p h)","name":"PMF.binomial_one_eq_bernoulli","isProp":true,"doc":"The binomial distribution on one coin is the bernoully distribution. ","depth":18}],"count":63}
{"noDocExamples":[],"kind":"«term_→ₛₗᵢ[_]_»","examples":[{"type":"{R : Type u_1} →\n  {R₂ : Type u_2} →\n    {E : Type u_5} →\n      {E₂ : Type u_6} →\n        [inst : Semiring R] →\n          [inst_1 : Semiring R₂] →\n            {σ₁₂ : R →+* R₂} →\n              [inst_2 : SeminormedAddCommGroup E] →\n                [inst_3 : SeminormedAddCommGroup E₂] →\n                  [inst_4 : Module R E] → [inst_5 : Module R₂ E₂] → (f : E →ₛₗ[σ₁₂] E₂) → Isometry ⇑f → E →ₛₗᵢ[σ₁₂] E₂","name":"LinearMap.toLinearIsometry","isProp":false,"doc":"Construct a `LinearIsometry` from a `LinearMap` satisfying `Isometry`. ","depth":30},{"type":"∀ {R : Type u_1} {R₂ : Type u_2} {E : Type u_5} {E₂ : Type u_6} [inst : Semiring R] [inst_1 : Semiring R₂]\n  {σ₁₂ : R →+* R₂} [inst_2 : SeminormedAddCommGroup E] [inst_3 : SeminormedAddCommGroup E₂] [inst_4 : Module R E]\n  [inst_5 : Module R₂ E₂] {ι : Type u_11} (b : Basis ι R E) {f₁ f₂ : E →ₛₗᵢ[σ₁₂] E₂},\n  (∀ (i : ι), f₁ (b i) = f₂ (b i)) → f₁ = f₂","name":"Basis.ext_linearIsometry","isProp":true,"doc":"Two linear isometries are equal if they are equal on basis vectors. ","depth":49},{"type":"{R : Type u_1} →\n  {R₂ : Type u_2} →\n    [inst : Semiring R] →\n      [inst_1 : Semiring R₂] →\n        (σ₁₂ : R →+* R₂) →\n          (E : Type u_11) →\n            (E₂ : Type u_12) →\n              [inst_2 : SeminormedAddCommGroup E] →\n                [inst_3 : SeminormedAddCommGroup E₂] →\n                  [inst_4 : Module R E] → [inst_5 : Module R₂ E₂] → (E →ₛₗᵢ[σ₁₂] E₂) → E → E₂","name":"LinearIsometry.Simps.apply","isProp":false,"doc":"See Note [custom simps projection]. We need to specify this projection explicitly in this case,\nbecause it is a composition of multiple projections. ","depth":23}],"count":61}
{"noDocExamples":[],"kind":"«term_≺i_»","examples":[{"type":"EmptyRelation ≺i EmptyRelation","name":"PrincipalSeg.pemptyToPunit","isProp":false,"doc":"Principal segment from the empty relation on `PEmpty` to the empty relation on `PUnit`. ","depth":4},{"type":"∀ {α : Type u_1} {β : Type u_2} {r : α → α → Prop} {s : β → β → Prop} [inst : IsWellOrder β s], Subsingleton (r ≺i s)","name":"PrincipalSeg.instSubsingletonPrincipalSeg","isProp":true,"doc":"Given a well order `s`, there is a most one principal segment embedding of `r` into `s`. ","depth":10},{"type":"{α β : Ordinal.{u_3}} → α < β → (fun x x_1 => x < x_1) ≺i fun x x_1 => x < x_1","name":"Ordinal.principalSegOut","isProp":false,"doc":"Given two ordinals `α < β`, then `principalSegOut α β` is the principal segment embedding\nof `α` to `β`, as map from a model type for `α` to a model type for `β`. ","depth":21}],"count":60}
{"noDocExamples":[],"kind":"AlgebraicGeometry.«term_⁻¹ᵁ_»","examples":[{"type":"{X Y : AlgebraicGeometry.Scheme} →\n  (f : X ⟶ Y) → (U : TopologicalSpace.Opens ↑↑Y.toPresheafedSpace) → X ∣_ᵤ f⁻¹ᵁ U ⟶ Y ∣_ᵤ U","name":"AlgebraicGeometry.morphismRestrict","isProp":false,"doc":"The restriction of a morphism `X ⟶ Y` onto `X |_{f ⁻¹ U} ⟶ Y |_ U`. ","depth":30},{"type":"{X Y : AlgebraicGeometry.Scheme} →\n  (f : X ⟶ Y) →\n    [inst : CategoryTheory.IsIso f] → (U : TopologicalSpace.Opens ↑↑Y.toPresheafedSpace) → X ∣_ᵤ f⁻¹ᵁ U ≅ Y ∣_ᵤ U","name":"AlgebraicGeometry.Scheme.restrictMapIso","isProp":false,"doc":"The restriction of an isomorphism onto an open set. ","depth":31},{"type":"{X Y : AlgebraicGeometry.Scheme} →\n  (f : X ⟶ Y) →\n    (U : TopologicalSpace.Opens ↑↑Y.toPresheafedSpace) →\n      CategoryTheory.Limits.pullback f (AlgebraicGeometry.Scheme.ιOpens U) ≅ X ∣_ᵤ f⁻¹ᵁ U","name":"AlgebraicGeometry.pullbackRestrictIsoRestrict","isProp":false,"doc":"Given a morphism `f : X ⟶ Y` and an open set `U ⊆ Y`, we have `X ×[Y] U ≅ X |_{f ⁻¹ U}` ","depth":36}],"count":60}
{"noDocExamples":[{"type":"∀ {M : Type u_1} [inst : Add Mᵃᵒᵖ] [inst_1 : IsRightCancelAdd Mᵃᵒᵖ], IsRightCancelAdd Mᵈᵃᵃ","name":"DomAddAct.instIsAddRightCancelDomAddActInstAddDomAddAct","isProp":true,"depth":6},{"type":"∀ {M : Type u_1} [inst : Neg M] (a : Mᵈᵃᵃ), DomAddAct.mk.symm (-a) = -DomAddAct.mk.symm a","name":"DomAddAct.symm_mk_neg","isProp":true,"depth":14}],"kind":"«term_ᵈᵃᵃ»","examples":[{"type":"{M : Type u_1} → M ≃ Mᵈᵃᵃ","name":"DomAddAct.mk","isProp":false,"doc":"Equivalence between `M` and `Mᵈᵐᵃ`.","depth":3}],"count":60}
{"noDocExamples":[],"kind":"«term_≃._»","examples":[{"type":"(α : Type u_1) → α ≃. α","name":"PEquiv.refl","isProp":false,"doc":"The identity map as a partial equivalence. ","depth":3},{"type":"{α : Type u} → {β : Type v} → (α ≃. β) → β ≃. α","name":"PEquiv.symm","isProp":false,"doc":"The inverse partial equivalence. ","depth":5},{"type":"{α : Type u} → {β : Type v} → (α ≃. β) → β → Option α","name":"PEquiv.invFun","isProp":false,"doc":"The partial inverse of `toFun` ","depth":5}],"count":59}
{"noDocExamples":[],"kind":"MeasureTheory.«term∫_In_,_»","examples":[{"type":"∀ {s : ℂ},\n  0 < s.re →\n    HasDerivAt Complex.GammaIntegral (∫ (t : ℝ) in Set.Ioi 0, ↑t ^ (s - 1) * (↑(Real.log t) * ↑(Real.exp (-t)))) s","name":"Complex.hasDerivAt_GammaIntegral","isProp":true,"doc":"The derivative of the `Γ` integral, at any `s ∈ ℂ` with `1 < re s`, is given by the Melllin\ntransform of `log t * exp (-t)`. ","depth":15},{"type":"∀ {a b : ℝ} (n : ℕ), ∫ (x : ℝ) in Ι a b, |x - a| ^ n = |b - a| ^ (n + 1) / (↑n + 1)","name":"integral_pow_abs_sub_uIoc","isProp":true,"doc":"Integral of `|x - a| ^ n` over `Ι a b`. This integral appears in the proof of the\nPicard-Lindelöf/Cauchy-Lipschitz theorem. ","depth":16},{"type":"∀ {α : Type u_1} [inst : MeasurableSpace α] {μ : MeasureTheory.Measure α} {f : α → ℝ},\n  MeasureTheory.Integrable f →\n    0 ≤ᶠ[MeasureTheory.Measure.ae μ] f → ∫ (ω : α), f ω ∂μ = ∫ (t : ℝ) in Set.Ioi 0, ENNReal.toReal (↑↑μ {a | t < f a})","name":"MeasureTheory.Integrable.integral_eq_integral_meas_lt","isProp":true,"doc":"The standard case of the layer cake formula / Cavalieri's principle / tail probability formula:\n\nFor an integrable a.e.-nonnegative real-valued function `f`, the Bochner integral of `f` can be\nwritten (roughly speaking) as: `∫ f ∂μ = ∫ t in 0..∞, μ {ω | f(ω) > t}`.\n\nSee `lintegral_eq_lintegral_meas_lt` for a version with Lebesgue integral `∫⁻` instead. ","depth":17}],"count":58}
{"noDocExamples":[],"kind":"Set.termΙ","examples":[{"type":"∀ {E : Type u_3} [inst : NormedAddCommGroup E] {f : ℝ → E} {a b : ℝ} {μ : MeasureTheory.Measure ℝ},\n  IntervalIntegrable f μ a b → MeasureTheory.IntegrableOn f (Ι a b)","name":"IntervalIntegrable.def","isProp":true,"doc":"If a function is interval integrable with respect to a given measure `μ` on `a..b` then\nit is integrable on `uIoc a b` with respect to `μ`. ","depth":14},{"type":"∀ {E : Type u_3} [inst : NormedAddCommGroup E] {f : ℝ → E} {a b : ℝ} {μ : MeasureTheory.Measure ℝ},\n  IntervalIntegrable f μ a b ↔ MeasureTheory.IntegrableOn f (Ι a b)","name":"intervalIntegrable_iff","isProp":true,"doc":"A function is interval integrable with respect to a given measure `μ` on `a..b` if and\nonly if it is integrable on `uIoc a b` with respect to `μ`. This is an equivalent\ndefinition of `IntervalIntegrable`. ","depth":14},{"type":"∀ {a b : ℝ} (n : ℕ), ∫ (x : ℝ) in Ι a b, |x - a| ^ n = |b - a| ^ (n + 1) / (↑n + 1)","name":"integral_pow_abs_sub_uIoc","isProp":true,"doc":"Integral of `|x - a| ^ n` over `Ι a b`. This integral appears in the proof of the\nPicard-Lindelöf/Cauchy-Lipschitz theorem. ","depth":16}],"count":58}
{"noDocExamples":[],"kind":"«term_≃ᵈ_»","examples":[{"type":"(X : Type u_4) → [inst : PseudoEMetricSpace X] → X ≃ᵈ X","name":"DilationEquiv.refl","isProp":false,"doc":"Identity map as a `DilationEquiv`. ","depth":6},{"type":"{X : Type u_1} → {Y : Type u_2} → [inst : PseudoEMetricSpace X] → [inst_1 : PseudoEMetricSpace Y] → X ≃ᵈ Y → Y ≃ᵈ X","name":"DilationEquiv.symm","isProp":false,"doc":"Inverse `DilationEquiv`. ","depth":9},{"type":"{X : Type u_1} → {Y : Type u_2} → [inst : PseudoEMetricSpace X] → [inst_1 : PseudoEMetricSpace Y] → X ≃ᵈ Y → Y → X","name":"DilationEquiv.Simps.symm_apply","isProp":false,"doc":"See Note [custom simps projection]. ","depth":9}],"count":57}
{"noDocExamples":[],"kind":"Vector.«term_::ᵥ_»","examples":[{"type":"∀ {α : Type u} {n : ℕ} (a : α) (v : Vector α n), Vector.toList (a ::ᵥ v) = a :: Vector.toList v","name":"Vector.toList_cons","isProp":true,"doc":"`toList` of `cons` of a vector and an element is\nthe `cons` of the list obtained by `toList` and the element ","depth":11},{"type":"∀ {α : Type u} {n : ℕ} (a : α) (v : Vector α n), Vector.head (a ::ᵥ v) = a","name":"Vector.head_cons","isProp":true,"doc":"The head of a vector obtained by prepending is the element prepended. ","depth":11},{"type":"∀ {α : Type u_1} {ix : Fin 1} (x : α), Vector.get (x ::ᵥ Vector.nil) ix = x","name":"Vector.get_cons_nil","isProp":true,"doc":"Accessing the nth element of a vector made up\nof one element `x : α` is `x` itself. ","depth":13}],"count":57}
{"noDocExamples":[],"kind":"«FreimanHomLocal≺»","examples":[{"type":"{α : Type u_2} → [inst : CommMonoid α] → (A : Set α) → (n : ℕ) → A →*[n] α","name":"FreimanHom.id","isProp":false,"doc":"The identity map from a commutative monoid to itself. ","depth":10},{"type":"{α : Type u_2} →\n  {β : Type u_3} → [inst : CommMonoid α] → [inst_1 : CommMonoid β] → {A : Set α} → {n : ℕ} → CommMonoid (A →*[n] β)","name":"FreimanHom.commMonoid","isProp":false,"doc":"`A →*[n] β` is a `CommMonoid`. ","depth":13},{"type":"{α : Type u_2} →\n  {β : Type u_3} → [inst : CommMonoid α] → [inst_1 : CommMonoid β] → {A : Set α} → {n : ℕ} → Mul (A →*[n] β)","name":"FreimanHom.instMulFreimanHom","isProp":false,"doc":"`f * g` is the Freiman homomorphism sends `x` to `f x * g x`. ","depth":13}],"count":57}
{"noDocExamples":[],"kind":"«term_≃ₛₗᵢ[_]_»","examples":[{"type":"{R : Type u_1} →\n  {R₂ : Type u_2} →\n    {E : Type u_5} →\n      {E₂ : Type u_6} →\n        [inst : Semiring R] →\n          [inst_1 : Semiring R₂] →\n            {σ₁₂ : R →+* R₂} →\n              {σ₂₁ : R₂ →+* R} →\n                [inst_2 : RingHomInvPair σ₁₂ σ₂₁] →\n                  [inst_3 : RingHomInvPair σ₂₁ σ₁₂] →\n                    [inst_4 : SeminormedAddCommGroup E] →\n                      [inst_5 : SeminormedAddCommGroup E₂] →\n                        [inst_6 : Module R E] → [inst_7 : Module R₂ E₂] → (E ≃ₛₗᵢ[σ₁₂] E₂) → E₂ ≃ₛₗᵢ[σ₂₁] E","name":"LinearIsometryEquiv.symm","isProp":false,"doc":"The inverse `LinearIsometryEquiv`. ","depth":29},{"type":"{R : Type u_1} →\n  {R₂ : Type u_2} →\n    [inst : Semiring R] →\n      [inst_1 : Semiring R₂] →\n        (σ₁₂ : R →+* R₂) →\n          {σ₂₁ : R₂ →+* R} →\n            [inst_2 : RingHomInvPair σ₁₂ σ₂₁] →\n              [inst_3 : RingHomInvPair σ₂₁ σ₁₂] →\n                (E : Type u_11) →\n                  (E₂ : Type u_12) →\n                    [inst_4 : SeminormedAddCommGroup E] →\n                      [inst_5 : SeminormedAddCommGroup E₂] →\n                        [inst_6 : Module R E] → [inst_7 : Module R₂ E₂] → (E ≃ₛₗᵢ[σ₁₂] E₂) → E₂ → E","name":"LinearIsometryEquiv.Simps.symm_apply","isProp":false,"doc":"See Note [custom simps projection] ","depth":29},{"type":"{R : Type u_1} →\n  {R₂ : Type u_2} →\n    {E : Type u_5} →\n      {E₂ : Type u_6} →\n        [inst : Semiring R] →\n          [inst_1 : Semiring R₂] →\n            {σ₁₂ : R →+* R₂} →\n              {σ₂₁ : R₂ →+* R} →\n                [inst_2 : RingHomInvPair σ₁₂ σ₂₁] →\n                  [inst_3 : RingHomInvPair σ₂₁ σ₁₂] →\n                    [inst_4 : SeminormedAddCommGroup E] →\n                      [inst_5 : SeminormedAddCommGroup E₂] →\n                        [inst_6 : Module R E] → [inst_7 : Module R₂ E₂] → (E ≃ₛₗᵢ[σ₁₂] E₂) → E →ₛₗᵢ[σ₁₂] E₂","name":"LinearIsometryEquiv.toLinearIsometry","isProp":false,"doc":"Reinterpret a `LinearIsometryEquiv` as a `LinearIsometry`. ","depth":29}],"count":57}
{"noDocExamples":[],"kind":"«AddFreimanHomLocal≺»","examples":[{"type":"{α : Type u_2} → [inst : AddCommMonoid α] → (A : Set α) → (n : ℕ) → A →+[n] α","name":"AddFreimanHom.id","isProp":false,"doc":"The identity map from an additive commutative monoid to itself.","depth":10},{"type":"{α : Type u_2} →\n  {G : Type u_6} → [inst : AddCommMonoid α] → [inst_1 : AddCommGroup G] → {A : Set α} → {n : ℕ} → Sub (A →+[n] G)","name":"AddFreimanHom.instSubFreimanHomToAddCommMonoid","isProp":false,"doc":"If `f` and `g` are additive Freiman homomorphisms to an additive commutative group,\nthen `f - g` is the additive Freiman homomorphism sending `x` to `f x - g x`","depth":13},{"type":"{α : Type u_2} →\n  {β : Type u_3} → [inst : AddCommMonoid α] → [inst_1 : AddCommMonoid β] → {A : Set α} → {n : ℕ} → Zero (A →+[n] β)","name":"AddFreimanHom.instZeroFreimanHom","isProp":false,"doc":"`0` is the Freiman homomorphism sending everything to `0`.","depth":13}],"count":56}
{"noDocExamples":[],"kind":"«term_≼i_»","examples":[{"type":"{α : Type u_1} → (r : α → α → Prop) → r ≼i r","name":"InitialSeg.refl","isProp":false,"doc":"The identity function shows that `≼i` is reflexive ","depth":6},{"type":"{α : Type u_1} → {β : Type u_2} → {r : α → α → Prop} → {s : β → β → Prop} → r ≃r s → r ≼i s","name":"InitialSeg.ofIso","isProp":false,"doc":"An order isomorphism is an initial segment ","depth":9},{"type":"(fun x x_1 => x < x_1) ≼i fun x x_1 => x < x_1","name":"Cardinal.alephIdx.initialSeg","isProp":false,"doc":"The `aleph'` index function, which gives the ordinal index of a cardinal.\n(The `aleph'` part is because unlike `aleph` this counts also the\nfinite stages. So `alephIdx n = n`, `alephIdx ω = ω`,\n`alephIdx ℵ₁ = ω + 1` and so on.)\nIn this definition, we register additionally that this function is an initial segment,\ni.e., it is order preserving and its range is an initial segment of the ordinals.\nFor the basic function version, see `alephIdx`.\nFor an upgraded version stating that the range is everything, see `AlephIdx.rel_iso`. ","depth":10}],"count":55}
{"noDocExamples":[],"kind":"MeasureTheory.«term∫_,_»","examples":[{"type":"∀ (μ : ℝ) {v : NNReal}, v ≠ 0 → ∫ (x : ℝ), ProbabilityTheory.gaussianPdfReal μ v x = 1","name":"ProbabilityTheory.integral_gaussianPdfReal_eq_one","isProp":true,"doc":"The gaussian distribution pdf integrates to 1 when the variance is not zero.  ","depth":14},{"type":"∀ {b : ℂ}, 0 < b.re → (∫ (x : ℝ), Complex.exp (-b * ↑x ^ 2)) ^ 2 = ↑Real.pi / b","name":"integral_gaussian_sq_complex","isProp":true,"doc":"The *square* of the Gaussian integral `∫ x:ℝ, exp (-b * x^2)` is equal to `π / b`. ","depth":18},{"type":"∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] (t : ℝ) (f : UnitAddCircle → E),\n  ∫ (a : ℝ) in Set.Ioc t (t + 1), f ↑a = ∫ (b : UnitAddCircle), f b","name":"UnitAddCircle.integral_preimage","isProp":true,"doc":"The integral of an almost-everywhere strongly measurable function over `UnitAddCircle` is\nequal to the integral over an interval (t, t + 1] in `ℝ` of its lift to `ℝ`. ","depth":18}],"count":55}
{"noDocExamples":[],"kind":"«term_→+*o_»","examples":[{"type":"{α : Type u_6} →\n  {β : Type u_7} →\n    [inst : NonAssocSemiring α] →\n      [inst_1 : Preorder α] → [inst_2 : NonAssocSemiring β] → [inst_3 : Preorder β] → α →+*o β → α →+* β","name":"OrderRingHom.toRingHom","isProp":false,"doc":"Reinterpret an ordered ring homomorphism as a ring homomorphism. ","depth":13},{"type":"{α : Type u_2} →\n  {β : Type u_3} →\n    [inst : NonAssocSemiring α] →\n      [inst_1 : Preorder α] → [inst_2 : NonAssocSemiring β] → [inst_3 : Preorder β] → α →+*o β → α →*₀o β","name":"OrderRingHom.toOrderMonoidWithZeroHom","isProp":false,"doc":"Reinterpret an ordered ring homomorphism as an order homomorphism. ","depth":13},{"type":"{α : Type u_2} →\n  {β : Type u_3} →\n    [inst : NonAssocSemiring α] →\n      [inst_1 : Preorder α] → [inst_2 : NonAssocSemiring β] → [inst_3 : Preorder β] → α →+*o β → α →+o β","name":"OrderRingHom.toOrderAddMonoidHom","isProp":false,"doc":"Reinterpret an ordered ring homomorphism as an ordered additive monoid homomorphism. ","depth":14}],"count":52}
{"noDocExamples":[],"kind":"«term_→ᵃⁱ[_]_»","examples":[{"type":"{𝕜 : Type u_1} →\n  {V : Type u_2} →\n    {P : Type u_8} →\n      [inst : NormedField 𝕜] →\n        [inst_1 : SeminormedAddCommGroup V] →\n          [inst_2 : NormedSpace 𝕜 V] → [inst_3 : PseudoMetricSpace P] → [inst_4 : NormedAddTorsor V P] → P →ᵃⁱ[𝕜] P","name":"AffineIsometry.id","isProp":false,"doc":"The identity affine isometry. ","depth":22},{"type":"{𝕜 : Type u_1} →\n  {V : Type u_2} →\n    {V₂ : Type u_4} →\n      [inst : NormedField 𝕜] →\n        [inst_1 : SeminormedAddCommGroup V] →\n          [inst_2 : SeminormedAddCommGroup V₂] →\n            [inst_3 : NormedSpace 𝕜 V] → [inst_4 : NormedSpace 𝕜 V₂] → (V →ₗᵢ[𝕜] V₂) → V →ᵃⁱ[𝕜] V₂","name":"LinearIsometry.toAffineIsometry","isProp":false,"doc":"Reinterpret a linear isometry as an affine isometry. ","depth":23},{"type":"{𝕜 : Type u_1} →\n  {V : Type u_2} →\n    {V₂ : Type u_4} →\n      {P : Type u_8} →\n        {P₂ : Type u_9} →\n          [inst : NormedField 𝕜] →\n            [inst_1 : SeminormedAddCommGroup V] →\n              [inst_2 : SeminormedAddCommGroup V₂] →\n                [inst_3 : NormedSpace 𝕜 V] →\n                  [inst_4 : NormedSpace 𝕜 V₂] →\n                    [inst_5 : PseudoMetricSpace P] →\n                      [inst_6 : PseudoMetricSpace P₂] →\n                        [inst_7 : NormedAddTorsor V P] → [inst_8 : NormedAddTorsor V₂ P₂] → (P ≃ᵃⁱ[𝕜] P₂) → P →ᵃⁱ[𝕜] P₂","name":"AffineIsometryEquiv.toAffineIsometry","isProp":false,"doc":"Reinterpret an `AffineIsometryEquiv` as an `AffineIsometry`. ","depth":29}],"count":51}
{"noDocExamples":[],"kind":"«term_≃ₗ⁅_,_⁆_»","examples":[{"type":"{R : Type u} →\n  {L : Type v} →\n    {M : Type w} →\n      [inst : CommRing R] →\n        [inst_1 : LieRing L] →\n          [inst_2 : AddCommGroup M] → [inst_3 : Module R M] → [inst_4 : LieRingModule L M] → M ≃ₗ⁅R,L⁆ M","name":"LieModuleEquiv.refl","isProp":false,"doc":"Lie module equivalences are reflexive. ","depth":20},{"type":"{R : Type u} →\n  {L : Type v} →\n    {M : Type w} →\n      {N : Type w₁} →\n        [inst : CommRing R] →\n          [inst_1 : LieRing L] →\n            [inst_2 : AddCommGroup M] →\n              [inst_3 : AddCommGroup N] →\n                [inst_4 : Module R M] →\n                  [inst_5 : Module R N] →\n                    [inst_6 : LieRingModule L M] → [inst_7 : LieRingModule L N] → (M ≃ₗ⁅R,L⁆ N) → M ≃ N","name":"LieModuleEquiv.toEquiv","isProp":false,"doc":"View an equivalence of Lie modules as a type level equivalence. ","depth":25},{"type":"{R : Type u} →\n  {L : Type v} →\n    {M : Type w} →\n      {N : Type w₁} →\n        [inst : CommRing R] →\n          [inst_1 : LieRing L] →\n            [inst_2 : AddCommGroup M] →\n              [inst_3 : AddCommGroup N] →\n                [inst_4 : Module R M] →\n                  [inst_5 : Module R N] →\n                    [inst_6 : LieRingModule L M] → [inst_7 : LieRingModule L N] → (M ≃ₗ⁅R,L⁆ N) → N → M","name":"LieModuleEquiv.invFun","isProp":false,"doc":"The inverse function of an equivalence of Lie modules ","depth":25}],"count":50}
{"noDocExamples":[],"kind":"SimpleGraph.«term_≃g_»","examples":[{"type":"{V : Type u} → {G : SimpleGraph V} → G ≃g G","name":"SimpleGraph.Iso.refl","isProp":false,"doc":"The identity isomorphism of a graph with itself. ","depth":6},{"type":"{α : Type u_1} → [inst : Preorder α] → SimpleGraph.hasse αᵒᵈ ≃g SimpleGraph.hasse α","name":"SimpleGraph.hasseDualIso","isProp":false,"doc":"`αᵒᵈ` and `α` have the same Hasse diagram. ","depth":7},{"type":"{V : Type u} → (G : SimpleGraph V) → SimpleGraph.induce Set.univ G ≃g G","name":"SimpleGraph.induceUnivIso","isProp":false,"doc":"The graph induced on `Set.univ` is isomorphic to the original graph. ","depth":8}],"count":50}
{"noDocExamples":[],"kind":"«term_→*₀o_»","examples":[{"type":"∀ {α : Type u_6} {β : Type u_7} [inst : Preorder α] [inst_1 : Preorder β] [inst_2 : MulZeroOneClass α]\n  [inst_3 : MulZeroOneClass β] (self : α →*₀o β), Monotone self.toFun","name":"OrderMonoidWithZeroHom.monotone'","isProp":true,"doc":"An `OrderMonoidWithZeroHom` is a monotone function. ","depth":17},{"type":"(α : Type u_2) → [inst : Preorder α] → [inst_1 : MulZeroOneClass α] → α →*₀o α","name":"OrderMonoidWithZeroHom.id","isProp":false,"doc":"The identity map as an ordered monoid with zero homomorphism. ","depth":9},{"type":"{α : Type u_2} →\n  {β : Type u_3} →\n    [inst : NonAssocSemiring α] →\n      [inst_1 : Preorder α] → [inst_2 : NonAssocSemiring β] → [inst_3 : Preorder β] → α →+*o β → α →*₀o β","name":"OrderRingHom.toOrderMonoidWithZeroHom","isProp":false,"doc":"Reinterpret an ordered ring homomorphism as an order homomorphism. ","depth":13}],"count":49}
{"noDocExamples":[],"kind":"Lean.Parser.Term.quotedName","examples":[{"type":"CongrState → List (Lean.TSyntax `rcasesPat)","name":"CongrState.patterns","isProp":false,"doc":"Patterns to use when doing intro. ","depth":6},{"type":"CongrMetaM (Option (Lean.TSyntax `rcasesPat))","name":"CongrMetaM.nextPattern","isProp":false,"doc":"Pop the next pattern from the current state. ","depth":6},{"type":"Lean.TSyntaxArray `Lean.Parser.Term.bracketedBinder → Lean.TSyntaxArray `Lean.Parser.Term.bracketedBinder","name":"Mathlib.Command.Variable.cleanBinders","isProp":false,"doc":"Strip off whitespace and comments. ","depth":8}],"count":48}
{"noDocExamples":[],"kind":"«term_→+o_»","examples":[{"type":"(α : Type u_2) → [inst : Preorder α] → [inst_1 : AddZeroClass α] → α →+o α","name":"OrderAddMonoidHom.id","isProp":false,"doc":"The identity map as an ordered additive monoid homomorphism.","depth":9},{"type":"{α : Type u_2} → {β : Type u_3} → [inst : OrderedAddCommMonoid α] → [inst_1 : OrderedAddCommMonoid β] → Add (α →+o β)","name":"OrderAddMonoidHom.instAddOrderAddMonoidHomToPreorderToPartialOrderToPreorderToPartialOrderToAddZeroClassToAddMonoidToAddCommMonoidToAddZeroClassToAddMonoidToAddCommMonoid","isProp":false,"doc":"For two ordered additive monoid morphisms `f` and `g`, their product is the ordered\nadditive monoid morphism sending `a` to `f a + g a`.","depth":12},{"type":"{α : Type u_2} →\n  {β : Type u_3} →\n    [inst : Preorder α] → [inst_1 : Preorder β] → [inst_2 : AddZeroClass α] → [inst_3 : AddZeroClass β] → Zero (α →+o β)","name":"OrderAddMonoidHom.instZeroOrderAddMonoidHom","isProp":false,"doc":"`0` is the homomorphism sending all elements to `0`.","depth":13}],"count":48}
{"noDocExamples":[],"kind":"«term_→*o_»","examples":[{"type":"(α : Type u_2) → [inst : Preorder α] → [inst_1 : MulOneClass α] → α →*o α","name":"OrderMonoidHom.id","isProp":false,"doc":"The identity map as an ordered monoid homomorphism. ","depth":9},{"type":"{α : Type u_2} → {β : Type u_3} → [inst : OrderedCommMonoid α] → [inst_1 : OrderedCommMonoid β] → Mul (α →*o β)","name":"OrderMonoidHom.instMulOrderMonoidHomToPreorderToPartialOrderToPreorderToPartialOrderToMulOneClassToMonoidToCommMonoidToMulOneClassToMonoidToCommMonoid","isProp":false,"doc":"For two ordered monoid morphisms `f` and `g`, their product is the ordered monoid morphism\nsending `a` to `f a * g a`. ","depth":12},{"type":"{α : Type u_2} →\n  {β : Type u_3} →\n    [inst : Preorder α] →\n      [inst_1 : Preorder β] → [inst_2 : MulOneClass α] → [inst_3 : MulOneClass β] → (α →*o β) → α →o β","name":"OrderMonoidHom.toOrderHom","isProp":false,"doc":"Reinterpret an ordered monoid homomorphism as an order homomorphism. ","depth":13}],"count":48}
{"noDocExamples":[],"kind":"List.«term_<+:_»","examples":[{"type":"∀ {α : Type u_1} {l : List α}, l <+: [] → l = []","name":"List.eq_nil_of_prefix_nil","isProp":true,"doc":"**Alias** of the forward direction of `List.prefix_nil`.","depth":7},{"type":"∀ {α : Type u_1} {l₁ l₂ : List α}, l₁ <:+ l₂ → List.reverse l₁ <+: List.reverse l₂","name":"List.isSuffix.reverse","isProp":true,"doc":"**Alias** of the reverse direction of `List.reverse_prefix`.","depth":8},{"type":"∀ {α : Type u_1} {l₁ l₂ : List α}, l₁ <+: l₂ → List.reverse l₁ <:+ List.reverse l₂","name":"List.isPrefix.reverse","isProp":true,"doc":"**Alias** of the reverse direction of `List.reverse_suffix`.","depth":8}],"count":48}
{"noDocExamples":[],"kind":"«term_||_»","examples":[{"type":"∀ (x y : Bool), (!(x && y)) = (!x || !y)","name":"Bool.not_and","isProp":true,"doc":"De Morgan's law for boolean and ","depth":7},{"type":"∀ (x y : Bool), (!(x || y)) = (!x && !y)","name":"Bool.not_or","isProp":true,"doc":"De Morgan's law for boolean or ","depth":7},{"type":"∀ {m x y : Bool}, (x && m) = (y && m) ∧ (x || m) = (y || m) ↔ x = y","name":"Bool.and_or_inj_right'","isProp":true,"doc":"**Alias** of `Bool.and_or_inj_right_iff`.","depth":11}],"count":48}
{"noDocExamples":[],"kind":"«term_≃⋆ₐ[_]_»","examples":[{"type":"∀ {R : Type u_1} {A : Type u_2} {B : Type u_3} [inst : Add A] [inst_1 : Add B] [inst_2 : Mul A] [inst_3 : Mul B]\n  [inst_4 : SMul R A] [inst_5 : SMul R B] [inst_6 : Star A] [inst_7 : Star B] (self : A ≃⋆ₐ[R] B) (r : R) (a : A),\n  Equiv.toFun self.toEquiv (r • a) = r • Equiv.toFun self.toEquiv a","name":"StarAlgEquiv.map_smul'","isProp":true,"doc":"By definition, a ⋆-algebra equivalence commutes with the action of scalars. ","depth":31},{"type":"{R : Type u_2} →\n  {A : Type u_3} →\n    {B : Type u_4} →\n      [inst : Add A] →\n        [inst_1 : Add B] →\n          [inst_2 : Mul A] →\n            [inst_3 : Mul B] →\n              [inst_4 : SMul R A] →\n                [inst_5 : SMul R B] → [inst_6 : Star A] → [inst_7 : Star B] → (A ≃⋆ₐ[R] B) → B ≃⋆ₐ[R] A","name":"StarAlgEquiv.symm","isProp":false,"doc":"Star algebra equivalences are symmetric. ","depth":23},{"type":"{R : Type u_2} →\n  {A : Type u_3} →\n    {B : Type u_4} →\n      [inst : Add A] →\n        [inst_1 : Add B] →\n          [inst_2 : Mul A] →\n            [inst_3 : Mul B] →\n              [inst_4 : SMul R A] → [inst_5 : SMul R B] → [inst_6 : Star A] → [inst_7 : Star B] → (A ≃⋆ₐ[R] B) → A → B","name":"StarAlgEquiv.Simps.apply","isProp":false,"doc":"See Note [custom simps projection] ","depth":23}],"count":47}
{"noDocExamples":[],"kind":"«termΩ[_⁄_]»","examples":[{"type":"(R : Type u) → (S : Type v) → [inst : CommRing R] → [inst_1 : CommRing S] → [inst_2 : Algebra R S] → S →ₗ[R] Ω[S⁄R]","name":"KaehlerDifferential.DLinearMap","isProp":false,"doc":"(Implementation) The underlying linear map of the derivation into `Ω[S⁄R]`. ","depth":17},{"type":"(R : Type u) →\n  (S : Type v) → [inst : CommRing R] → [inst_1 : CommRing S] → [inst_2 : Algebra R S] → Derivation R S (Ω[S⁄R])","name":"KaehlerDifferential.D","isProp":false,"doc":"The universal derivation into `Ω[S⁄R]`. ","depth":17},{"type":"{R : Type u} →\n  {S : Type v} →\n    [inst : CommRing R] →\n      [inst_1 : CommRing S] →\n        [inst_2 : Algebra R S] →\n          {M : Type u_1} →\n            [inst_3 : AddCommGroup M] →\n              [inst_4 : Module R M] →\n                [inst_5 : Module S M] → [inst_6 : IsScalarTower R S M] → Derivation R S M → Ω[S⁄R] →ₗ[S] M","name":"Derivation.liftKaehlerDifferential","isProp":false,"doc":"The linear map from `Ω[S⁄R]`, associated with a derivation. ","depth":23}],"count":46}
{"noDocExamples":[],"kind":"QuadraticForm.Isometry.«term_→qᵢ_»","examples":[{"type":"{R : Type u_2} →\n  {M : Type u_3} →\n    [inst : CommSemiring R] → [inst_1 : AddCommMonoid M] → [inst_2 : Module R M] → (Q : QuadraticForm R M) → Q →qᵢ Q","name":"QuadraticForm.Isometry.id","isProp":false,"doc":"The identity isometry from a quadratic form to itself. ","depth":16},{"type":"{R : Type u} →\n  [inst : CommRing R] →\n    {X : Type v} →\n      [inst_1 : AddCommGroup X] →\n        [inst_2 : Module R X] →\n          {Q₁ Q₂ : QuadraticForm R X} → (Q₁ →qᵢ Q₂) → (QuadraticModuleCat.of Q₁ ⟶ QuadraticModuleCat.of Q₂)","name":"QuadraticModuleCat.ofHom","isProp":false,"doc":"Typecheck a `QuadraticForm.Isometry` as a morphism in `Module R`. ","depth":18},{"type":"{R : Type u} → [inst : CommRing R] → {V W : QuadraticModuleCat R} → QuadraticModuleCat.Hom V W → V.form →qᵢ W.form","name":"QuadraticModuleCat.Hom.toIsometry","isProp":false,"doc":"The underlying isometry ","depth":18}],"count":44}
{"noDocExamples":[],"kind":"«term_→ᵈ_»","examples":[{"type":"{α : Type u_1} → [inst : PseudoEMetricSpace α] → (α →ᵈ α) →* NNReal","name":"Dilation.ratioHom","isProp":false,"doc":"`Dilation.ratio` as a monoid homomorphism from `α →ᵈ α` to `ℝ≥0`. ","depth":10},{"type":"∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : PseudoEMetricSpace α] [inst_1 : PseudoEMetricSpace β]\n  [inst_2 : PseudoEMetricSpace γ] {g : β →ᵈ γ} {f : α →ᵈ β},\n  (∃ x y, edist x y ≠ 0 ∧ edist x y ≠ ⊤) → Dilation.ratio (Dilation.comp g f) = Dilation.ratio g * Dilation.ratio f","name":"Dilation.ratio_comp'","isProp":true,"doc":"Ratio of the composition `g.comp f` of two dilations is the product of their ratios. We assume\nthat there exist two points in `α` at extended distance neither `0` nor `∞` because otherwise\n`Dilation.ratio (g.comp f) = Dilation.ratio f = 1` while `Dilation.ratio g` can be any number. This\nversion works for most general spaces, see also `Dilation.ratio_comp` for a version assuming that\n`α` is a nontrivial metric space. ","depth":22},{"type":"(α : Type u_6) → [inst : PseudoEMetricSpace α] → α →ᵈ α","name":"Dilation.id","isProp":false,"doc":"The identity is a dilation ","depth":6}],"count":44}
{"noDocExamples":[{"type":"∀ (x : ℕ) (r : ℝ), Metric.closedBall x r = Set.Icc ⌈↑x - r⌉₊ ⌊↑x + r⌋₊","name":"Nat.closedBall_eq_Icc","isProp":true,"depth":12},{"type":"∀ {α : Type u_2} [inst : LinearOrderedSemiring α] [inst_1 : FloorSemiring α], ⌈1⌉₊ = 1","name":"Nat.ceil_one","isProp":true,"depth":12}],"kind":"Nat.«term⌈_⌉₊»","examples":[{"type":"∀ {Fq : Type u_1} [inst : Fintype Fq] [inst_1 : Field Fq] {b : Polynomial Fq},\n  b ≠ 0 →\n    ∀ {ε : ℝ},\n      0 < ε →\n        ∀ (A : Fin (Nat.succ (Fintype.card Fq ^ ⌈-Real.log ε / Real.log ↑(Fintype.card Fq)⌉₊)) → Polynomial Fq),\n          ∃ i₀ i₁, i₀ ≠ i₁ ∧ ↑(Polynomial.cardPowDegree (A i₁ % b - A i₀ % b)) < Polynomial.cardPowDegree b • ε","name":"Polynomial.exists_approx_polynomial","isProp":true,"doc":"If `A` is a family of enough low-degree polynomials over a finite field,\nthere is a pair of elements in `A` (with different indices but not necessarily\ndistinct), such that the difference of their remainders is close together. ","depth":35}],"count":43}
{"noDocExamples":[],"kind":"«term_⁺»","examples":[{"type":"∀ {α : Type u} [inst : Lattice α] [inst_1 : Group α] (a : α), 1 ≤ a → a⁺ = a","name":"LatticeOrderedGroup.pos_of_one_le","isProp":true,"doc":"If `a` is positive, then it is equal to its positive component `a⁺`. ","depth":14},{"type":"∀ {α : Type u} [inst : Lattice α] [inst_1 : AddGroup α] (a : α), 0 ≤ a → a⁺ = a","name":"LatticeOrderedGroup.pos_of_nonneg","isProp":true,"doc":"If `a` is positive, then it is equal to its positive component `a⁺`.","depth":14},{"type":"∀ {Ω : Type u_1} {m0 : MeasurableSpace Ω} {μ : MeasureTheory.Measure Ω} {f : ℕ → Ω → ℝ}\n  {ℱ : MeasureTheory.Filtration ℕ m0} [inst : MeasureTheory.IsFiniteMeasure μ] (a b : ℝ),\n  MeasureTheory.Submartingale f ℱ μ →\n    ENNReal.ofReal (b - a) * ∫⁻ (ω : Ω), MeasureTheory.upcrossings a b f ω ∂μ ≤\n      ⨆ N, ∫⁻ (ω : Ω), ENNReal.ofReal (f N ω - a)⁺ ∂μ","name":"MeasureTheory.Submartingale.mul_lintegral_upcrossings_le_lintegral_pos_part","isProp":true,"doc":"A variant of Doob's upcrossing estimate obtained by taking the supremum on both sides. ","depth":24}],"count":42}
{"noDocExamples":[],"kind":"«term∮_InC(_,_),_»","examples":[{"type":"∀ {c w : ℂ} {R : ℝ}, w ∈ Metric.ball c R → (∮ (z : ℂ) in C(c, R), (z - w)⁻¹) = 2 * ↑Real.pi * Complex.I","name":"circleIntegral.integral_sub_inv_of_mem_ball","isProp":true,"doc":"Integral $\\oint_{|z-c|=R} \\frac{dz}{z-w} = 2πi$ whenever $|w-c| < R$. ","depth":17},{"type":"∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] (f : (Fin 1 → ℂ) → E) (c : Fin 1 → ℂ)\n  (R : Fin 1 → ℝ), (∯ (x : Fin 1 → ℂ) in T(c, R), f x) = ∮ (z : ℂ) in C(c 0, R 0), f fun x => z","name":"torusIntegral_dim1","isProp":true,"doc":"In dimension one, `torusIntegral` is the same as `circleIntegral`\n(up to the natural equivalence between `ℂ` and `Fin 1 → ℂ`). ","depth":18},{"type":"∀ {n : ℤ}, n ≠ -1 → ∀ (c w : ℂ) (R : ℝ), (∮ (z : ℂ) in C(c, R), (z - w) ^ n) = 0","name":"circleIntegral.integral_sub_zpow_of_ne","isProp":true,"doc":"If `n ≠ -1` is an integer number, then the integral of `(z - w) ^ n` over the circle equals\nzero. ","depth":20}],"count":42}
{"noDocExamples":[],"kind":"«term_≃+*o_»","examples":[{"type":"{α : Type u_2} →\n  {β : Type u_3} →\n    [inst : Mul α] →\n      [inst_1 : Add α] → [inst_2 : LE α] → [inst_3 : Mul β] → [inst_4 : Add β] → [inst_5 : LE β] → α ≃+*o β → α ≃o β","name":"OrderRingIso.toOrderIso","isProp":false,"doc":"Reinterpret an ordered ring isomorphism as an order isomorphism. ","depth":17},{"type":"∀ {α : Type u_2} {β : Type u_3} [inst : Mul α] [inst_1 : Add α] [inst_2 : LE α] [inst_3 : Mul β] [inst_4 : Add β]\n  [inst_5 : LE β] (f : α ≃+*o β), f.toFun = ⇑f","name":"OrderRingIso.toFun_eq_coe","isProp":true,"doc":"Helper instance for when there's too many metavariables to apply `FunLike.has_coe_to_fun`\ndirectly. ","depth":32},{"type":"{α : Type u_2} →\n  {β : Type u_3} →\n    [inst : Mul α] →\n      [inst_1 : Add α] → [inst_2 : LE α] → [inst_3 : Mul β] → [inst_4 : Add β] → [inst_5 : LE β] → α ≃+*o β → β ≃+*o α","name":"OrderRingIso.symm","isProp":false,"doc":"The inverse of an ordered ring isomorphism as an ordered ring isomorphism. ","depth":17}],"count":42}
{"noDocExamples":[],"kind":"«term_⋊[_]_»","examples":[{"type":"{N : Type u_1} → {G : Type u_2} → [inst : Group N] → [inst_1 : Group G] → {φ : G →* MulAut N} → N ⋊[φ] G → N","name":"SemidirectProduct.left","isProp":false,"doc":"The element of N ","depth":16},{"type":"{N : Type u_1} → {G : Type u_2} → [inst : Group N] → [inst_1 : Group G] → {φ : G →* MulAut N} → N →* N ⋊[φ] G","name":"SemidirectProduct.inl","isProp":false,"doc":"The canonical map `N →* N ⋊[φ] G` sending `n` to `⟨n, 1⟩` ","depth":16},{"type":"{N : Type u_1} → {G : Type u_2} → [inst : Group N] → [inst_1 : Group G] → {φ : G →* MulAut N} → N ⋊[φ] G → G","name":"SemidirectProduct.right","isProp":false,"doc":"The element of G ","depth":16}],"count":41}
{"noDocExamples":[],"kind":"List.«term_<:+_»","examples":[{"type":"∀ {α : Type u_1} {l : List α}, l <:+ [] → l = []","name":"List.eq_nil_of_suffix_nil","isProp":true,"doc":"**Alias** of the forward direction of `List.suffix_nil`.","depth":7},{"type":"∀ {α : Type u_1} {l₁ l₂ : List α}, l₁ <:+ l₂ → List.reverse l₁ <+: List.reverse l₂","name":"List.isSuffix.reverse","isProp":true,"doc":"**Alias** of the reverse direction of `List.reverse_prefix`.","depth":8},{"type":"∀ {α : Type u_1} {l₁ l₂ : List α}, l₁ <+: l₂ → List.reverse l₁ <:+ List.reverse l₂","name":"List.isPrefix.reverse","isProp":true,"doc":"**Alias** of the reverse direction of `List.reverse_suffix`.","depth":8}],"count":41}
{"noDocExamples":[],"kind":"«MulSemiringActionHomLocal≺»","examples":[{"type":"(M : Type u_5) →\n  [inst : Monoid M] → {R : Type u_11} → [inst_1 : Semiring R] → [inst_2 : MulSemiringAction M R] → R →+*[M] R","name":"MulSemiringActionHom.id","isProp":false,"doc":"The identity map as an equivariant ring homomorphism. ","depth":13},{"type":"{M : Type u_5} →\n  [inst : Monoid M] →\n    {R : Type u_11} →\n      [inst_1 : Semiring R] →\n        [inst_2 : MulSemiringAction M R] →\n          {S : Type u_13} → [inst_3 : Semiring S] → [inst_4 : MulSemiringAction M S] → (R →+*[M] S) → R →+* S","name":"MulSemiringActionHom.toRingHom","isProp":false,"doc":"Reinterpret an equivariant ring homomorphism as a ring homomorphism. ","depth":17},{"type":"{M : Type u_1} →\n  [inst : Monoid M] →\n    {P : Type u_2} →\n      [inst_1 : CommSemiring P] →\n        [inst_2 : MulSemiringAction M P] →\n          {Q : Type u_3} →\n            [inst_3 : CommSemiring Q] →\n              [inst_4 : MulSemiringAction M Q] → (P →+*[M] Q) → Polynomial P →+*[M] Polynomial Q","name":"MulSemiringActionHom.polynomial","isProp":false,"doc":"An equivariant map induces an equivariant map on polynomials. ","depth":18}],"count":41}
{"noDocExamples":[],"kind":"Polynomial.«term_%ₘ_»","examples":[{"type":"∀ {R : Type u} [inst : CommRing R] {n : Type v} [inst_1 : DecidableEq n] [inst_2 : Fintype n] (M : Matrix n n R)\n  (k : ℕ), M ^ k = (Polynomial.aeval M) (Polynomial.X ^ k %ₘ Matrix.charpoly M)","name":"Matrix.pow_eq_aeval_mod_charpoly","isProp":true,"doc":"Any matrix power can be computed as the sum of matrix powers less than `Fintype.card n`.\n\nTODO: add the statement for negative powers phrased with `zpow`. ","depth":34},{"type":"∀ {R : Type u} [inst : CommRing R] {n : Type v} [inst_1 : DecidableEq n] [inst_2 : Fintype n] (M : Matrix n n R)\n  (p : Polynomial R), (Polynomial.aeval M) p = (Polynomial.aeval M) (p %ₘ Matrix.charpoly M)","name":"Matrix.aeval_eq_aeval_mod_charpoly","isProp":true,"doc":"Any matrix polynomial `p` is equivalent under evaluation to `p %ₘ M.charpoly`; that is, `p`\nis equivalent to a polynomial with degree less than the dimension of the matrix. ","depth":35},{"type":"∀ {R : Type u} {M : Type v} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  [inst_3 : Module.Free R M] [inst_4 : Module.Finite R M] (f : M →ₗ[R] M) (k : ℕ),\n  f ^ k = (Polynomial.aeval f) (Polynomial.X ^ k %ₘ LinearMap.charpoly f)","name":"LinearMap.pow_eq_aeval_mod_charpoly","isProp":true,"doc":"Any endomorphism power can be computed as the sum of endomorphism powers less than the\ndimension of the module. ","depth":43}],"count":38}
{"noDocExamples":[],"kind":"OreLocalization.«term_/ₒ_»","examples":[{"type":"∀ {R : Type u_1} [inst : Monoid R] {S : Submonoid R} [inst_1 : OreLocalization.OreSet S] {r r' r₁ r₂ : R} {s t : ↥S},\n  r * ↑t = r' * ↑t → r₁ * r * r₂ /ₒ s = r₁ * r' * r₂ /ₒ s","name":"OreLocalization.eq_of_num_factor_eq","isProp":true,"doc":"Fractions which differ by a factor of the numerator can be proven equal if\nthose factors expand to equal elements of `R`. ","depth":25},{"type":"∀ {R : Type u_1} [inst : Monoid R] {S : Submonoid R} [inst_1 : OreLocalization.OreSet S] (r : R) (s : ↥S) (t : R)\n  (hst : ↑s * t ∈ S), r /ₒ s = r * t /ₒ { val := ↑s * t, property := hst }","name":"OreLocalization.expand","isProp":true,"doc":"A fraction `r /ₒ s` is equal to its expansion by an arbitrary factor `t` if `s * t ∈ S`. ","depth":25},{"type":"∀ {R : Type u_1} [inst : Monoid R] {S : Submonoid R} [inst_1 : OreLocalization.OreSet S] (r : R) (s s' : ↥S),\n  r /ₒ s = r * ↑s' /ₒ (s * s')","name":"OreLocalization.expand'","isProp":true,"doc":"A fraction is equal to its expansion by a factor from s. ","depth":26}],"count":38}
{"noDocExamples":[{"type":"∀ {α : Type u} [inst : Lattice α] [inst_1 : AddGroup α] (a : α), -a ≤ a⁻","name":"LatticeOrderedGroup.neg_le_neg","isProp":true,"depth":13},{"type":"∀ {α : Type u} [inst : Lattice α] [inst_1 : AddGroup α], 0⁻ = 0","name":"LatticeOrderedGroup.neg_zero","isProp":true,"depth":13},{"type":"∀ {α : Type u} [inst : Lattice α] [inst_1 : AddGroup α] (a : α), 0 ≤ a⁻","name":"LatticeOrderedGroup.neg_nonneg","isProp":true,"depth":13}],"kind":"«term_⁻»","examples":[],"count":38}
{"noDocExamples":[{"type":"∀ {C : Type u} {X Y X' Y' : C} [inst : CategoryTheory.Category.{v, u} C] [inst_1 : CategoryTheory.MonoidalCategory C]\n  (f : X ≅ Y) (g : X' ≅ Y'), (f ⊗ g).inv = CategoryTheory.MonoidalCategory.tensorHom f.inv g.inv","name":"CategoryTheory.tensorIso_inv","isProp":true,"depth":21},{"type":"∀ {C : Type u} {X Y X' Y' : C} [inst : CategoryTheory.Category.{v, u} C] [inst_1 : CategoryTheory.MonoidalCategory C]\n  (f : X ≅ Y) (g : X' ≅ Y'), (f ⊗ g).hom = CategoryTheory.MonoidalCategory.tensorHom f.hom g.hom","name":"CategoryTheory.tensorIso_hom","isProp":true,"depth":21},{"type":"∀ {C : Type u_1} [inst : CategoryTheory.Category.{u_2, u_1} C] [inst_1 : CategoryTheory.MonoidalCategory C]\n  (P : C → Prop) (X : CategoryTheory.FullSubcategory P),\n  (CategoryTheory.MonoidalCategory.rightUnitor X.obj).hom =\n    ((CategoryTheory.Iso.refl (CategoryTheory.MonoidalCategory.tensorObj X.obj (𝟙_ C)) ≪≫\n          (CategoryTheory.Iso.refl X.obj ⊗ CategoryTheory.Iso.refl (𝟙_ C))) ≪≫\n        CategoryTheory.MonoidalCategory.rightUnitor X.obj).hom","name":"CategoryTheory.MonoidalCategory.fullMonoidalSubcategory.proof_8","isProp":true,"depth":21}],"kind":"CategoryTheory.«term_⊗_»","examples":[],"count":38}
{"noDocExamples":[],"kind":"Submodule.«term_⟂_»","examples":[{"type":"∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {U V : Submodule 𝕜 E}, U ⟂ V → Disjoint U V","name":"Submodule.IsOrtho.disjoint","isProp":true,"doc":"Orthogonal submodules are disjoint. ","depth":25},{"type":"∀ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] [inst_2 : MetricSpace P]\n  [inst_3 : NormedAddTorsor V P] {n : ℕ} (s : Affine.Simplex ℝ P (n + 1)) (i : Fin (n + 2)),\n  vectorSpan ℝ (s.points '' ↑(Finset.erase Finset.univ i)) ⟂ AffineSubspace.direction (Affine.Simplex.altitude s i)","name":"Affine.Simplex.vectorSpan_isOrtho_altitude_direction","isProp":true,"doc":"The vector span of the opposite face lies in the direction\northogonal to an altitude. ","depth":28},{"type":"∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {ι : Type u_4} {V : ι → Submodule 𝕜 E},\n  (OrthogonalFamily 𝕜 (fun i => ↥(V i)) fun i => Submodule.subtypeₗᵢ (V i)) → Pairwise ((fun x x_1 => x ⟂ x_1) on V)","name":"OrthogonalFamily.pairwise","isProp":true,"doc":"**Alias** of the forward direction of `orthogonalFamily_iff_pairwise`.","depth":31}],"count":36}
{"noDocExamples":[{"type":"∀ {α : Type u} (l : List α), l ~r l","name":"List.IsRotated.refl","isProp":true,"depth":5},{"type":"∀ {α : Type u} {l : List α}, [] ~r l ↔ [] = l","name":"List.isRotated_nil_iff'","isProp":true,"depth":7},{"type":"∀ {α : Type u} {l l' : List α}, l ~r l' → List.Perm l l'","name":"List.IsRotated.perm","isProp":true,"depth":7}],"kind":"List.«term_~r_»","examples":[],"count":36}
{"noDocExamples":[],"kind":"«MulActionHomLocal≺»","examples":[{"type":"(M' : Type u_1) → {X : Type u_2} → [inst : SMul M' X] → X →[M'] X","name":"MulActionHom.id","isProp":false,"doc":"The identity map as an equivariant map. ","depth":8},{"type":"{α : Type u} → [inst : Group α] → (H : Subgroup α) → α →[α] α ⧸ H","name":"MulActionHom.toQuotient","isProp":false,"doc":"The canonical map to the left cosets. ","depth":12},{"type":"{X : Type u_2} →\n  {Y : Type u_3} →\n    {M : Type u_5} →\n      {F : Type u_16} → [inst : SMul M X] → [inst_1 : SMul M Y] → [inst_2 : SMulHomClass F M X Y] → F → X →[M] Y","name":"SMulHomClass.toMulActionHom","isProp":false,"doc":"Turn an element of a type `F` satisfying `SMulHomClass F M X Y` into an actual\n`MulActionHom`. This is declared as the default coercion from `F` to `MulActionHom M X Y`. ","depth":13}],"count":36}
{"noDocExamples":[],"kind":"SimpleGraph.«term_↪g_»","examples":[{"type":"{V : Type u} → {G : SimpleGraph V} → G ↪g G","name":"SimpleGraph.Embedding.refl","isProp":false,"doc":"The identity embedding from a graph to itself. ","depth":6},{"type":"{V : Type u} → {s : Set V} → (G : SimpleGraph ↑s) → G ↪g SimpleGraph.spanningCoe G","name":"SimpleGraph.Embedding.spanningCoe","isProp":false,"doc":"Graphs on a set of vertices embed in their `spanningCoe`. ","depth":9},{"type":"{V : Type u} → {W : Type v} → (f : V ↪ W) → (G : SimpleGraph V) → G ↪g SimpleGraph.map f G","name":"SimpleGraph.Embedding.map","isProp":false,"doc":"Given an injective function, there is an embedding from a graph into the mapped graph. ","depth":9}],"count":36}
{"noDocExamples":[{"type":"∀ {M : Type w'} [inst : LE M] [h : NoTopOrder M], M ⊨ FirstOrder.Language.noTopOrderSentence FirstOrder.Language.order","name":"FirstOrder.Language.realize_noTopOrder","isProp":true,"depth":7},{"type":"∀ {M : Type w'} [inst : LE M] [h : NoBotOrder M], M ⊨ FirstOrder.Language.noBotOrderSentence FirstOrder.Language.order","name":"FirstOrder.Language.realize_noBotOrder","isProp":true,"depth":7}],"kind":"FirstOrder.Language.«term_⊨_»","examples":[{"type":"∀ {α : Type u_1} {M : α → Type u_2} {u : Ultrafilter α} {L : FirstOrder.Language}\n  [inst : (a : α) → FirstOrder.Language.Structure L (M a)] [inst_1 : ∀ (a : α), Nonempty (M a)]\n  (φ : FirstOrder.Language.Sentence L), Filter.Product (↑u) M ⊨ φ ↔ ∀ᶠ (a : α) in ↑u, M a ⊨ φ","name":"FirstOrder.Language.Ultraproduct.sentence_realize","isProp":true,"doc":"**Łoś's Theorem**: A sentence is true in an ultraproduct if and only if the set of structures\nit is true in is in the ultrafilter. ","depth":16}],"count":35}
{"noDocExamples":[],"kind":"«term_==_»","examples":[{"type":"∀ {α : Type u} [inst : BEq α] [self : LawfulBEq α] {a : α}, (a == a) = true","name":"LawfulBEq.rfl","isProp":true,"doc":"`==` is reflexive, that is, `(a == a) = true`. ","depth":10},{"type":"∀ {α : Type u} [inst : BEq α] [self : LawfulBEq α] {a b : α}, (a == b) = true → a = b","name":"LawfulBEq.eq_of_beq","isProp":true,"doc":"If `a == b` evaluates to `true`, then `a` and `b` are equal in the logic. ","depth":12},{"type":"∀ {α : Type u_1} [inst : BEq α] [self : PartialEquivBEq α] {a b : α}, (a == b) = true → (b == a) = true","name":"PartialEquivBEq.symm","isProp":true,"doc":"Symmetry for `BEq`. If `a == b` then `b == a`. ","depth":12}],"count":35}
{"noDocExamples":[],"kind":"MeasureTheory.«term⨍_,_∂_»","examples":[{"type":"∀ {α : Type u_1} {m0 : MeasurableSpace α} {μ : MeasureTheory.Measure α} {f : α → ℝ}\n  [inst : MeasureTheory.IsFiniteMeasure μ], μ ≠ 0 → MeasureTheory.Integrable f → ∃ x, f x ≤ ⨍ (a : α), f a ∂μ","name":"MeasureTheory.exists_le_average","isProp":true,"doc":"**First moment method**. The minimum of an integrable function is smaller than its mean. ","depth":17},{"type":"∀ {α : Type u_1} {m0 : MeasurableSpace α} {μ : MeasureTheory.Measure α} {f : α → ℝ}\n  [inst : MeasureTheory.IsFiniteMeasure μ], μ ≠ 0 → MeasureTheory.Integrable f → ∃ x, ⨍ (a : α), f a ∂μ ≤ f x","name":"MeasureTheory.exists_average_le","isProp":true,"doc":"**First moment method**. The maximum of an integrable function is greater than its mean. ","depth":18},{"type":"∀ {α : Type u_1} {m0 : MeasurableSpace α} {μ : MeasureTheory.Measure α} {f : α → ℝ}\n  [inst : MeasureTheory.IsFiniteMeasure μ], μ ≠ 0 → MeasureTheory.Integrable f → 0 < ↑↑μ {x | f x ≤ ⨍ (a : α), f a ∂μ}","name":"MeasureTheory.measure_le_average_pos","isProp":true,"doc":"**First moment method**. An integrable function is smaller than its mean on a set of positive\nmeasure. ","depth":19}],"count":35}
{"noDocExamples":[],"kind":"«term_→Co_»","examples":[{"type":"(α : Type u_2) → [inst : TopologicalSpace α] → [inst_1 : Preorder α] → α →Co α","name":"ContinuousOrderHom.id","isProp":false,"doc":"`id` as a `ContinuousOrderHom`. ","depth":9},{"type":"{α : Type u_2} →\n  {β : Type u_3} →\n    [inst : TopologicalSpace α] →\n      [inst_1 : Preorder α] → [inst_2 : TopologicalSpace β] → [inst_3 : Preorder β] → (α →Co β) → C(α, β)","name":"ContinuousOrderHom.toContinuousMap","isProp":false,"doc":"Reinterpret a `ContinuousOrderHom` as a `ContinuousMap`. ","depth":13},{"type":"{F : Type u_1} →\n  {α : Type u_2} →\n    {β : Type u_3} →\n      [inst : Preorder α] →\n        [inst_1 : Preorder β] →\n          [inst_2 : TopologicalSpace α] →\n            [inst_3 : TopologicalSpace β] → [inst_4 : ContinuousOrderHomClass F α β] → F → α →Co β","name":"ContinuousOrderHomClass.toContinuousOrderHom","isProp":false,"doc":"Turn an element of a type `F` satisfying `ContinuousOrderHomClass F α β` into an actual\n`ContinuousOrderHom`. This is declared as the default coercion from `F` to `α →Co β`. ","depth":15}],"count":35}
{"noDocExamples":[],"kind":"TypeVec.«term_:::__1»","examples":[{"type":"(n : ℕ) →\n  {β : (v : TypeVec.{u_2} (n + 1)) → (v' : TypeVec.{u_3} (n + 1)) → TypeVec.Arrow v v' → Sort u_1} →\n    ((t : Type u_2) →\n        (t' : Type u_3) →\n          (f : t → t') →\n            (v : TypeVec.{u_2} n) →\n              (v' : TypeVec.{u_3} n) → (fs : TypeVec.Arrow v v') → β (v ::: t) (v' ::: t') (fs ::: f)) →\n      (v : TypeVec.{u_2} (n + 1)) → (v' : TypeVec.{u_3} (n + 1)) → (fs : TypeVec.Arrow v v') → β v v' fs","name":"TypeVec.typevecCasesCons₃","isProp":false,"doc":"cases distinction for an arrow in the category of (n+1)-length type vectors ","depth":17},{"type":"(n : ℕ) →\n  (t : Type u_1) →\n    (t' : Type u_2) →\n      (v : TypeVec.{u_1} n) →\n        (v' : TypeVec.{u_2} n) →\n          {β : TypeVec.Arrow (v ::: t) (v' ::: t') → Sort u_3} →\n            ((f : t → t') → (fs : TypeVec.Arrow v v') → β (fs ::: f)) →\n              (fs : TypeVec.Arrow (v ::: t) (v' ::: t')) → β fs","name":"TypeVec.typevecCasesCons₂","isProp":false,"doc":"specialized cases distinction for an arrow in the category of (n+1)-length type vectors ","depth":17},{"type":"{n : ℕ} →\n  {F : TypeVec.{u} (n + 1) → Type u} →\n    [inst : MvFunctor F] →\n      [q : MvQPF F] →\n        {α : TypeVec.{u} n} →\n          {β : MvQPF.Fix F α → Type u} →\n            ((x : F (α ::: Sigma β)) → β (MvQPF.Fix.mk (MvFunctor.map (TypeVec.id ::: Sigma.fst) x))) →\n              (x : MvQPF.Fix F α) → β x","name":"MvQPF.Fix.drec","isProp":false,"doc":"Dependent recursor for `fix F` ","depth":23}],"count":35}
{"noDocExamples":[],"kind":"Polynomial.«term_/ₘ_»","examples":[{"type":"∀ {R : Type u} [inst : CommRing R] {p q : Polynomial R},\n  Polynomial.Monic q →\n    Polynomial.degree q ≤ Polynomial.degree p → Polynomial.leadingCoeff (p /ₘ q) = Polynomial.leadingCoeff p","name":"Polynomial.leadingCoeff_divByMonic_of_monic","isProp":true,"doc":"Division by a monic polynomial doesn't change the leading coefficient. ","depth":14},{"type":"∀ {R : Type u_1} [inst : CommRing R] {n : ℕ},\n  0 < n →\n    Polynomial.cyclotomic n R =\n      (Polynomial.X ^ n - 1) /ₘ Finset.prod (Nat.properDivisors n) fun i => Polynomial.cyclotomic i R","name":"Polynomial.cyclotomic_eq_X_pow_sub_one_div","isProp":true,"doc":"We have\n`cyclotomic n R = (X ^ k - 1) /ₘ (∏ i in Nat.properDivisors k, cyclotomic i K)`. ","depth":21},{"type":"∀ {K : Type u_2} [inst : CommRing K] [inst_1 : IsDomain K] {ζ : K} {n : ℕ},\n  0 < n →\n    IsPrimitiveRoot ζ n →\n      Polynomial.cyclotomic' n K =\n        (Polynomial.X ^ n - 1) /ₘ Finset.prod (Nat.properDivisors n) fun i => Polynomial.cyclotomic' i K","name":"Polynomial.cyclotomic'_eq_X_pow_sub_one_div","isProp":true,"doc":"If there is a primitive `n`-th root of unity in `K`, then\n`cyclotomic' n K = (X ^ k - 1) /ₘ (∏ i in Nat.properDivisors k, cyclotomic' i K)`. ","depth":24}],"count":35}
{"noDocExamples":[],"kind":"Sigma.Lex.«termΣₗ_,_»","examples":[{"type":"{ι : Type u_1} → {α : ι → Type u_2} → [inst : LT ι] → [inst : (i : ι) → LT (α i)] → LT (Σₗ (i : ι), α i)","name":"Sigma.Lex.LT","isProp":false,"doc":"The lexicographical `<` on a sigma type. ","depth":9},{"type":"{ι : Type u_1} →\n  {α : ι → Type u_2} → [inst : Preorder ι] → [inst : (i : ι) → Preorder (α i)] → Preorder (Σₗ (i : ι), α i)","name":"Sigma.Lex.preorder","isProp":false,"doc":"The lexicographical preorder on a sigma type. ","depth":9},{"type":"{ι : Type u_1} →\n  {α : ι → Type u_2} → [inst : Preorder ι] → [inst : (i : ι) → PartialOrder (α i)] → PartialOrder (Σₗ (i : ι), α i)","name":"Sigma.Lex.partialOrder","isProp":false,"doc":"The lexicographical partial order on a sigma type. ","depth":9}],"count":35}
{"noDocExamples":[],"kind":"«term_/ₚ_»","examples":[{"type":"∀ {α : Type u} [inst : Monoid α] (u : αˣ), ↑u⁻¹ = 1 /ₚ u","name":"inv_eq_one_divp","isProp":true,"doc":"Used for `field_simp` to deal with inverses of units. ","depth":11},{"type":"∀ {α : Type u} [inst : Monoid α] (x y : α) (u : αˣ), x * (y /ₚ u) = x * y /ₚ u","name":"divp_assoc'","isProp":true,"doc":"`field_simp` needs the reverse direction of `divp_assoc` to move all `/ₚ` to the right. ","depth":15},{"type":"∀ {α : Type u} [inst : Monoid α] (u₁ u₂ : αˣ), ↑(u₁ / u₂) = ↑u₁ /ₚ u₂","name":"val_div_eq_divp","isProp":true,"doc":"`field_simp` moves division inside `αˣ` to the right, and this lemma\nlifts the calculation to `α`.\n","depth":16}],"count":34}
{"noDocExamples":[],"kind":"PSigma.«termΣₗ'_,_»","examples":[{"type":"{ι : Type u_1} →\n  {α : ι → Type u_2} → [inst : LinearOrder ι] → [inst : (i : ι) → LinearOrder (α i)] → LinearOrder (Σₗ' (i : ι), α i)","name":"PSigma.Lex.linearOrder","isProp":false,"doc":"Dictionary / lexicographic linear_order for pairs. ","depth":9},{"type":"{ι : Type u_1} →\n  {α : ι → Type u_2} → [inst : PartialOrder ι] → [inst : (i : ι) → PartialOrder (α i)] → PartialOrder (Σₗ' (i : ι), α i)","name":"PSigma.Lex.partialOrder","isProp":false,"doc":"Dictionary / lexicographic partial_order for dependent pairs. ","depth":9},{"type":"{ι : Type u_1} → {α : ι → Type u_2} → [inst : LT ι] → [inst : (i : ι) → LT (α i)] → LT (Σₗ' (i : ι), α i)","name":"PSigma.Lex.lt","isProp":false,"doc":"The lexicographical `<` on a sigma type. ","depth":9}],"count":34}
{"noDocExamples":[],"kind":"FirstOrder.Language.«term_≃ᴸ_»","examples":[{"type":"(L : FirstOrder.Language) → L ≃ᴸ L","name":"FirstOrder.Language.LEquiv.refl","isProp":false,"doc":"The identity equivalence from a first-order language to itself. ","depth":3},{"type":"{L : FirstOrder.Language} → {L' : FirstOrder.Language} → (L ≃ᴸ L') → (L' ≃ᴸ L)","name":"FirstOrder.Language.LEquiv.symm","isProp":false,"doc":"The inverse of an equivalence of first-order languages. ","depth":5},{"type":"{L : FirstOrder.Language} →\n  {L' : FirstOrder.Language} → (L ≃ᴸ L') → FirstOrder.Language.Sentence L ≃ FirstOrder.Language.Sentence L'","name":"FirstOrder.Language.LEquiv.onSentence","isProp":false,"doc":"Maps a sentence's symbols along a language equivalence. ","depth":6}],"count":34}
{"noDocExamples":[],"kind":"CategoryTheory.exp.«term_⟹_»","examples":[{"type":"{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] →\n    {A Y : C} →\n      [inst_1 : CategoryTheory.Limits.HasFiniteProducts C] →\n        [inst_2 : CategoryTheory.Exponentiable A] → (A ⟶ Y) → (⊤_ C ⟶ A ⟹ Y)","name":"CategoryTheory.internalizeHom","isProp":false,"doc":"The internal element which points at the given morphism. ","depth":16},{"type":"{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] →\n    {X : C} →\n      [inst_1 : CategoryTheory.Limits.HasFiniteProducts C] →\n        [inst_2 : CategoryTheory.Exponentiable (⊤_ C)] → (⊤_ C) ⟹ X ≅ X","name":"CategoryTheory.expTerminalIsoSelf","isProp":false,"doc":"Show that the exponential of the terminal object is isomorphic to itself, i.e. `X^1 ≅ X`.\n\nThe typeclass argument is explicit: any instance can be used.\n","depth":19},{"type":"∀ {C : Type u₁} {D : Type u₂} [inst : CategoryTheory.Category.{v₁, u₁} C] [inst_1 : CategoryTheory.Category.{v₁, u₂} D]\n  (i : CategoryTheory.Functor D C) [inst_2 : CategoryTheory.Limits.HasFiniteProducts C]\n  [inst_3 : CategoryTheory.CartesianClosed C],\n  (∀ (B : D) (A : C), (A ⟹ i.obj B) ∈ CategoryTheory.Functor.essImage i) → CategoryTheory.ExponentialIdeal i","name":"CategoryTheory.ExponentialIdeal.mk'","isProp":true,"doc":"To show `i` is an exponential ideal it suffices to show that `A ⟹ iB` is \"in\" `D` for any `A` in\n`C` and `B` in `D`.\n","depth":24}],"count":33}
{"noDocExamples":[],"kind":"MeasureTheory.«term⨍_In_,_∂_»","examples":[{"type":"∀ {α : Type u_1} {m0 : MeasurableSpace α} {μ : MeasureTheory.Measure α} {s : Set α} {f : α → ℝ},\n  ↑↑μ s ≠ 0 → ↑↑μ s ≠ ⊤ → MeasureTheory.IntegrableOn f s → ∃ x ∈ s, f x ≤ ⨍ (a : α) in s, f a ∂μ","name":"MeasureTheory.exists_le_setAverage","isProp":true,"doc":"**First moment method**. The minimum of an integrable function is smaller than its mean. ","depth":19},{"type":"∀ {α : Type u_1} {m0 : MeasurableSpace α} {μ : MeasureTheory.Measure α} {s : Set α} {f : α → ℝ},\n  ↑↑μ s ≠ 0 → ↑↑μ s ≠ ⊤ → MeasureTheory.IntegrableOn f s → ∃ x ∈ s, ⨍ (a : α) in s, f a ∂μ ≤ f x","name":"MeasureTheory.exists_setAverage_le","isProp":true,"doc":"**First moment method**. The maximum of an integrable function is greater than its mean. ","depth":20},{"type":"∀ {α : Type u_1} {m0 : MeasurableSpace α} {μ : MeasureTheory.Measure α} {s : Set α} {f : α → ℝ},\n  ↑↑μ s ≠ 0 → ↑↑μ s ≠ ⊤ → MeasureTheory.IntegrableOn f s → 0 < ↑↑μ {x | x ∈ s ∧ f x ≤ ⨍ (a : α) in s, f a ∂μ}","name":"MeasureTheory.measure_le_setAverage_pos","isProp":true,"doc":"**First moment method**. An integrable function is smaller than its mean on a set of positive\nmeasure. ","depth":21}],"count":33}
{"noDocExamples":[],"kind":"«term_⁻¹'o_»","examples":[{"type":"{α : Type u_1} → {β : Type u_2} → (f : α → β) → (s : β → β → Prop) → f ⁻¹'o s →r s","name":"RelHom.preimage","isProp":false,"doc":"A function is a relation homomorphism from the preimage relation of `s` to `s`. ","depth":10},{"type":"{α : Sort u_3} → {β : Sort u_4} → (f : α → β) → (s : β → β → Prop) → [H : DecidableRel s] → DecidableRel (f ⁻¹'o s)","name":"Order.Preimage.decidable","isProp":false,"doc":"The preimage of a decidable order is decidable. ","depth":10},{"type":"{X : Type u_5} → (r : X → X → Prop) → (p : X → Prop) → Subtype.val ⁻¹'o r ↪r r","name":"Subtype.relEmbedding","isProp":false,"doc":"The induced relation on a subtype is an embedding under the natural inclusion. ","depth":11}],"count":33}
{"noDocExamples":[],"kind":"«term_⊕'_»","examples":[{"type":"(α : Type u_4) → Fintype α ⊕' Infinite α","name":"fintypeOrInfinite","isProp":false,"doc":"Any type is (classically) either a `Fintype`, or `Infinite`.\n\nOne can obtain the relevant typeclasses via `cases fintypeOrInfinite α`.\n","depth":4},{"type":"{α : Sort u} → {β : Sort v} → α → α ⊕' β","name":"PSum.inl","isProp":false,"doc":"Left injection into the sum type `α ⊕' β`. If `a : α` then `.inl a : α ⊕' β`. ","depth":5},{"type":"(α : Type u_3) → [inst : Inhabited α] → Nontrivial α ⊕' Unique α","name":"nontrivialPSumUnique","isProp":false,"doc":"An inhabited type is either nontrivial, or has a unique element. ","depth":5}],"count":33}
{"noDocExamples":[],"kind":"AlgebraicGeometry.«term_∣__»","examples":[{"type":"∀ {P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme},\n  AlgebraicGeometry.PropertyIsLocalAtTarget P →\n    ∀ {X Y : AlgebraicGeometry.Scheme} (f : X ⟶ Y) (U : TopologicalSpace.Opens ↑↑Y.toPresheafedSpace), P f → P (f ∣_ U)","name":"AlgebraicGeometry.PropertyIsLocalAtTarget.restrict","isProp":true,"doc":"If `P` holds for `f : X ⟶ Y`, then `P` holds for `f ∣_ U` for any `U`. ","depth":34},{"type":"∀ {P : AlgebraicGeometry.AffineTargetMorphismProperty},\n  AlgebraicGeometry.AffineTargetMorphismProperty.IsLocal P →\n    ∀ {X Y : AlgebraicGeometry.Scheme} [inst : AlgebraicGeometry.IsAffine Y] (f : X ⟶ Y)\n      (r : ↑(Y.presheaf.obj (Opposite.op ⊤))), P f → P (f ∣_ Y.basicOpen r)","name":"AlgebraicGeometry.AffineTargetMorphismProperty.IsLocal.toBasicOpen","isProp":true,"doc":"`P` is stable under restriction to basic open set of global sections. ","depth":36},{"type":"∀ {P : AlgebraicGeometry.AffineTargetMorphismProperty},\n  AlgebraicGeometry.AffineTargetMorphismProperty.IsLocal P →\n    ∀ {X Y : AlgebraicGeometry.Scheme} [inst : AlgebraicGeometry.IsAffine Y] (f : X ⟶ Y)\n      (s : Finset ↑(Y.presheaf.obj (Opposite.op ⊤))),\n      Ideal.span ↑s = ⊤ → (∀ (r : { x // x ∈ s }), P (f ∣_ Y.basicOpen ↑r)) → P f","name":"AlgebraicGeometry.AffineTargetMorphismProperty.IsLocal.ofBasicOpenCover","isProp":true,"doc":"`P` for `f` if `P` holds for `f` restricted to basic sets of a spanning set of the global\nsections ","depth":50}],"count":32}
{"noDocExamples":[],"kind":"«term_≃SL[_]_»","examples":[{"type":"∀ {R : Type u_1} {S : Type u_2} [inst : Semiring R] [inst_1 : Semiring S] {σ : R →+* S} {σ' : S →+* R}\n  [inst_2 : RingHomInvPair σ σ'] [inst_3 : RingHomInvPair σ' σ] {M : Type u_3} [inst_4 : TopologicalSpace M]\n  [inst_5 : AddCommMonoid M] {M₂ : Type u_4} [inst_6 : TopologicalSpace M₂] [inst_7 : AddCommMonoid M₂]\n  [inst_8 : Module R M] [inst_9 : Module S M₂] (self : M ≃SL[σ] M₂), Continuous self.invFun","name":"ContinuousLinearEquiv.continuous_invFun","isProp":true,"doc":"Continuous linear equivalences between modules. We only put the type classes that are necessary\nfor the definition, although in applications `M` and `M₂` will be topological modules over the\ntopological semiring `R`. ","depth":36},{"type":"{R : Type u_1} →\n  {R₂ : Type u_2} →\n    {E : Type u_5} →\n      {E₂ : Type u_6} →\n        [inst : Semiring R] →\n          [inst_1 : Semiring R₂] →\n            {σ₁₂ : R →+* R₂} →\n              {σ₂₁ : R₂ →+* R} →\n                [inst_2 : RingHomInvPair σ₁₂ σ₂₁] →\n                  [inst_3 : RingHomInvPair σ₂₁ σ₁₂] →\n                    [inst_4 : SeminormedAddCommGroup E] →\n                      [inst_5 : SeminormedAddCommGroup E₂] →\n                        [inst_6 : Module R E] → [inst_7 : Module R₂ E₂] → (E ≃ₛₗᵢ[σ₁₂] E₂) → E ≃SL[σ₁₂] E₂","name":"LinearIsometryEquiv.toContinuousLinearEquiv","isProp":false,"doc":"Interpret a `LinearIsometryEquiv` as a `ContinuousLinearEquiv`. ","depth":31},{"type":"{R₁ : Type u_1} →\n  {R₂ : Type u_2} →\n    [inst : Semiring R₁] →\n      [inst_1 : Semiring R₂] →\n        {σ₁₂ : R₁ →+* R₂} →\n          {σ₂₁ : R₂ →+* R₁} →\n            [inst_2 : RingHomInvPair σ₁₂ σ₂₁] →\n              [inst_3 : RingHomInvPair σ₂₁ σ₁₂] →\n                {M₁ : Type u_4} →\n                  [inst_4 : TopologicalSpace M₁] →\n                    [inst_5 : AddCommMonoid M₁] →\n                      {M₂ : Type u_6} →\n                        [inst_6 : TopologicalSpace M₂] →\n                          [inst_7 : AddCommMonoid M₂] →\n                            [inst_8 : Module R₁ M₁] → [inst_9 : Module R₂ M₂] → (M₁ ≃SL[σ₁₂] M₂) → M₂ → M₁","name":"ContinuousLinearEquiv.Simps.symm_apply","isProp":false,"doc":"See Note [custom simps projection] ","depth":33}],"count":32}
{"noDocExamples":[{"type":"∀ {α : Type u_1} (l : List α), [] <:+: l","name":"List.nil_infix","isProp":true,"depth":5}],"kind":"List.«term_<:+:_»","examples":[{"type":"∀ {α : Type u_1} {l : List α}, l <:+: [] → l = []","name":"List.eq_nil_of_infix_nil","isProp":true,"doc":"**Alias** of the forward direction of `List.infix_nil`.","depth":7},{"type":"∀ {α : Type u_1} {l₁ l₂ : List α}, l₁ <:+: l₂ → List.reverse l₁ <:+: List.reverse l₂","name":"List.isInfix.reverse","isProp":true,"doc":"**Alias** of the reverse direction of `List.reverse_infix`.","depth":8}],"count":30}
{"noDocExamples":[],"kind":"«term_<<<_»","examples":[{"type":"∀ (m n : ℕ), Nat.shiftLeft m n = m <<< n","name":"Nat.shiftLeft_eq'","isProp":true,"doc":"Std4 takes the unprimed name for `Nat.shiftLeft_eq m n : m <<< n = m * 2 ^ n`. ","depth":9},{"type":"∀ (m n : ℕ), m <<< (n + 1) = (2 * m) <<< n","name":"Nat.shiftLeft_succ_inside","isProp":true,"doc":"Shiftleft on successor with multiple moved inside. ","depth":11},{"type":"∀ (m n : ℕ), m <<< (n + 1) = 2 * m <<< n","name":"Nat.shiftLeft_succ","isProp":true,"doc":"Shiftleft on successor with multiple moved to outside. ","depth":11}],"count":30}
{"noDocExamples":[{"type":"∀ {V : Type u} [inst : Quiver V],\n  CategoryTheory.Groupoid.Free.of V =\n    Quiver.Symmetrify.of ⋙q CategoryTheory.Paths.of ⋙q\n      (CategoryTheory.Quotient.functor CategoryTheory.Groupoid.Free.redStep).toPrefunctor","name":"CategoryTheory.Groupoid.Free.of_eq","isProp":true,"depth":14},{"type":"∀ {U : Type u_1} {V : Type u_2} [inst : Quiver U] [inst_1 : Quiver V] (F : U ⥤q V), 𝟭q U ⋙q F = F","name":"Prefunctor.id_comp","isProp":true,"depth":15}],"kind":"Prefunctor.«term_⋙q_»","examples":[{"type":"∀ {V : Type u_2} [inst : Quiver V] {V' : Type u_4} [inst_1 : Quiver V'] [inst_2 : Quiver.HasReverse V'] (φ : V ⥤q V')\n  (Φ : Quiver.Symmetrify V ⥤q V'),\n  Quiver.Symmetrify.of ⋙q Φ = φ →\n    (∀ {X Y : Quiver.Symmetrify V} (f : X ⟶ Y), Φ.map (Quiver.reverse f) = Quiver.reverse (Φ.map f)) →\n      Φ = Quiver.Symmetrify.lift φ","name":"Quiver.Symmetrify.lift_unique","isProp":true,"doc":"`lift φ` is the only prefunctor extending `φ` and preserving reverses. ","depth":24}],"count":29}
{"noDocExamples":[],"kind":"SimpleGraph.«term_□_»","examples":[{"type":"{α : Type u_1} → {β : Type u_2} → (G : SimpleGraph α) → (H : SimpleGraph β) → G □ H ≃g H □ G","name":"SimpleGraph.boxProdComm","isProp":false,"doc":"The box product is commutative up to isomorphism. `Equiv.prodComm` as a graph isomorphism. ","depth":10},{"type":"{α : Type u_1} → {β : Type u_2} → (G : SimpleGraph α) → (H : SimpleGraph β) → β → G ↪g G □ H","name":"SimpleGraph.boxProdLeft","isProp":false,"doc":"The embedding of `G` into `G □ H` given by `b`. ","depth":10},{"type":"{α : Type u_1} → {β : Type u_2} → (G : SimpleGraph α) → (H : SimpleGraph β) → α → H ↪g G □ H","name":"SimpleGraph.boxProdRight","isProp":false,"doc":"The embedding of `H` into `G □ H` given by `a`. ","depth":10}],"count":27}
{"noDocExamples":[{"type":"∀ {α : Type u} (s : Stream'.WSeq α), s ~ʷ s","name":"Stream'.WSeq.Equiv.refl","isProp":true,"depth":5},{"type":"∀ {α : Type u} (s : Stream'.WSeq α), Stream'.WSeq.think s ~ʷ s","name":"Stream'.WSeq.think_equiv","isProp":true,"depth":6},{"type":"∀ {α : Type u} {s t : Stream'.WSeq α}, s ~ʷ t → t ~ʷ s","name":"Stream'.WSeq.Equiv.symm","isProp":true,"depth":7}],"kind":"Stream'.WSeq.«term_~ʷ_»","examples":[],"count":27}
{"noDocExamples":[],"kind":"MeasureTheory.«term∀ᵐ_,_»","examples":[{"type":"∀ (f : StieltjesFunction),\n  ∀ᵐ (x : ℝ),\n    HasDerivAt (↑f)\n      (ENNReal.toReal (MeasureTheory.Measure.rnDeriv (StieltjesFunction.measure f) MeasureTheory.volume x)) x","name":"StieltjesFunction.ae_hasDerivAt","isProp":true,"doc":"A Stieltjes function is almost everywhere differentiable, with derivative equal to the\nRadon-Nikodym derivative of the associated Stieltjes measure with respect to Lebesgue. ","depth":13},{"type":"∀ {f : ℝ → ℝ} (hf : Monotone f),\n  ∀ᵐ (x : ℝ),\n    HasDerivAt f\n      (ENNReal.toReal\n        (MeasureTheory.Measure.rnDeriv (StieltjesFunction.measure (Monotone.stieltjesFunction hf)) MeasureTheory.volume\n          x))\n      x","name":"Monotone.ae_hasDerivAt","isProp":true,"doc":"A monotone function is almost everywhere differentiable, with derivative equal to the\nRadon-Nikodym derivative of the associated Stieltjes measure with respect to Lebesgue. ","depth":14},{"type":"∀ {f : ℝ → ℝ}, Monotone f → ∀ᵐ (x : ℝ), DifferentiableAt ℝ f x","name":"Monotone.ae_differentiableAt","isProp":true,"doc":"A monotone real function is differentiable Lebesgue-almost everywhere. ","depth":16}],"count":26}
{"noDocExamples":[],"kind":"«term_→CO_»","examples":[{"type":"(α : Type u_2) → [inst : TopologicalSpace α] → α →CO α","name":"ContinuousOpenMap.id","isProp":false,"doc":"`id` as a `ContinuousOpenMap`. ","depth":6},{"type":"{α : Type u_2} →\n  {β : Type u_3} →\n    {γ : Type u_4} →\n      [inst : TopologicalSpace α] →\n        [inst_1 : TopologicalSpace β] → [inst_2 : TopologicalSpace γ] → (β →CO γ) → (α →CO β) → α →CO γ","name":"ContinuousOpenMap.comp","isProp":false,"doc":"Composition of `ContinuousOpenMap`s as a `ContinuousOpenMap`. ","depth":12},{"type":"{α : Type u_2} →\n  {β : Type u_3} →\n    [inst : TopologicalSpace α] → [inst_1 : TopologicalSpace β] → (f : α →CO β) → (f' : α → β) → f' = ⇑f → α →CO β","name":"ContinuousOpenMap.copy","isProp":false,"doc":"Copy of a `ContinuousOpenMap` with a new `ContinuousMap` equal to the old one. Useful to fix\ndefinitional equalities. ","depth":21}],"count":26}
{"noDocExamples":[{"type":"∀ {α : Type u_1} {M : Matroid α} [inst : Matroid.Finite M], Matroid.Finite M﹡","name":"Matroid.dual_finite","isProp":true,"depth":6},{"type":"∀ {α : Type u_1} {M : Matroid α} [inst : Matroid.Nonempty M], Matroid.Nonempty M﹡","name":"Matroid.dual_nonempty","isProp":true,"depth":6},{"type":"∀ {α : Type u_1} (M : Matroid α) [h : Matroid.RkPos M﹡], ¬M.Base M.E","name":"Matroid.ground_not_base","isProp":true,"depth":7}],"kind":"Matroid.«term_﹡»","examples":[],"count":25}
{"noDocExamples":[],"kind":"Function.«term↿_»","examples":[{"type":"∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β]\n  [inst_2 : WeaklyLocallyCompactSpace α] [inst_3 : CompactSpace β] [inst_4 : UniformSpace γ] (f : α → β → γ),\n  Continuous ↿f → ∀ (x : α), TendstoUniformly f (f x) (nhds x)","name":"Continuous.tendstoUniformly","isProp":true,"doc":"A continuous family of functions `α → β → γ` tends uniformly to its value at `x`\nif `α` is weakly locally compact and `β` is compact. ","depth":18},{"type":"∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {p : Filter ι} {c : β},\n  Filter.Tendsto (↿F) (p ×ˢ ⊤) (nhds c) ↔ TendstoUniformly F (fun x => c) p","name":"tendsto_prod_top_iff","isProp":true,"doc":"Uniform convergence to a constant function is equivalent to convergence in `p ×ˢ ⊤`. ","depth":19},{"type":"∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {s : Set α} {p : Filter ι} {c : β},\n  Filter.Tendsto (↿F) (p ×ˢ Filter.principal s) (nhds c) ↔ TendstoUniformlyOn F (fun x => c) p s","name":"tendsto_prod_principal_iff","isProp":true,"doc":"Uniform convergence on a set `s` to a constant function is equivalent to convergence in\n`p ×ˢ 𝓟 s`. ","depth":20}],"count":24}
{"noDocExamples":[],"kind":"CategoryTheory.MonoidalOpposite.«term_ᴹᵒᵖ»","examples":[{"type":"{C : Type u₁} → Cᴹᵒᵖ → C","name":"CategoryTheory.MonoidalOpposite.unmop","isProp":false,"doc":"Think of an object of `Cᴹᵒᵖ` as an object of `C`. ","depth":3},{"type":"{C : Type u₁} → C → Cᴹᵒᵖ","name":"CategoryTheory.MonoidalOpposite.mop","isProp":false,"doc":"Think of an object of `C` as an object of `Cᴹᵒᵖ`. ","depth":3},{"type":"{C : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} C] →\n    {X Y : Cᴹᵒᵖ} → (X ⟶ Y) → (CategoryTheory.MonoidalOpposite.unmop X ⟶ CategoryTheory.MonoidalOpposite.unmop Y)","name":"Quiver.Hom.unmop","isProp":false,"doc":"We can think of a morphism `f : mop X ⟶ mop Y` as a morphism `X ⟶ Y`. ","depth":12}],"count":24}
{"noDocExamples":[],"kind":"«term_→r_»","examples":[{"type":"∀ {α : Type u_1} {β : Type u_2} {r : α → α → Prop} {s : β → β → Prop} [inst : IsTrichotomous α r] [inst : IsIrrefl β s]\n  (f : r →r s), Function.Injective ⇑f","name":"RelHom.injective_of_increasing","isProp":true,"doc":"An increasing function is injective ","depth":20},{"type":"{α : Type u_1} → (r : α → α → Prop) → r →r r","name":"RelHom.id","isProp":false,"doc":"Identity map is a relation homomorphism. ","depth":6},{"type":"{α : Type u_1} → {β : Type u_2} → {r : α → α → Prop} → {s : β → β → Prop} → r ↪r s → r →r s","name":"RelEmbedding.toRelHom","isProp":false,"doc":"A relation embedding is also a relation homomorphism ","depth":9}],"count":24}
{"noDocExamples":[{"type":"∀ {C : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} C] [inst_1 : CategoryTheory.MonoidalCategory C] (X Y : C)\n  [inst_2 : CategoryTheory.ExactPairing X Y],\n  CategoryTheory.CategoryStruct.comp\n      (CategoryTheory.MonoidalCategory.tensorHom (η_ X Y) (CategoryTheory.CategoryStruct.id X))\n      (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategory.associator X Y X).hom\n        (CategoryTheory.MonoidalCategory.tensorHom (CategoryTheory.CategoryStruct.id X) (ε_ X Y))) =\n    CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategory.leftUnitor X).hom\n      (CategoryTheory.MonoidalCategory.rightUnitor X).inv","name":"CategoryTheory.ExactPairing.evaluation_coevaluation","isProp":true,"depth":22},{"type":"∀ {C : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} C] [inst_1 : CategoryTheory.MonoidalCategory C] {X Y : C}\n  [inst_2 : CategoryTheory.HasLeftDual X] [inst_3 : CategoryTheory.HasLeftDual Y] (f : X ⟶ Y),\n  CategoryTheory.CategoryStruct.comp\n      (CategoryTheory.MonoidalCategory.tensorHom (CategoryTheory.CategoryStruct.id X) (ᘁf)) (ε_ (ᘁX) X) =\n    CategoryTheory.CategoryStruct.comp\n      (CategoryTheory.MonoidalCategory.tensorHom f (CategoryTheory.CategoryStruct.id ᘁY)) (ε_ (ᘁY) Y)","name":"CategoryTheory.leftAdjointMate_comp_evaluation","isProp":true,"depth":22}],"kind":"CategoryTheory.ExactPairing.termε_","examples":[{"type":"{C : Type u_1} →\n  {D : Type u_2} →\n    [inst : CategoryTheory.Category.{u_3, u_1} C] →\n      [inst_1 : CategoryTheory.Category.{u_4, u_2} D] →\n        [inst_2 : CategoryTheory.MonoidalCategory C] →\n          [inst_3 : CategoryTheory.MonoidalCategory D] →\n            (F : CategoryTheory.MonoidalFunctor C D) →\n              [inst_4 : CategoryTheory.Faithful F.toFunctor] →\n                {X Y : C} →\n                  (eval : CategoryTheory.MonoidalCategory.tensorObj Y X ⟶ 𝟙_ C) →\n                    (coeval : 𝟙_ C ⟶ CategoryTheory.MonoidalCategory.tensorObj X Y) →\n                      [inst_5 : CategoryTheory.ExactPairing (F.obj X) (F.obj Y)] →\n                        F.map eval =\n                            CategoryTheory.CategoryStruct.comp\n                              (CategoryTheory.inv (CategoryTheory.LaxMonoidalFunctor.μ F.toLaxMonoidalFunctor Y X))\n                              (CategoryTheory.CategoryStruct.comp (ε_ (F.obj X) (F.obj Y)) F.ε) →\n                          F.map coeval =\n                              CategoryTheory.CategoryStruct.comp (CategoryTheory.inv F.ε)\n                                (CategoryTheory.CategoryStruct.comp (η_ (F.obj X) (F.obj Y))\n                                  (CategoryTheory.LaxMonoidalFunctor.μ F.toLaxMonoidalFunctor X Y)) →\n                            CategoryTheory.ExactPairing X Y","name":"CategoryTheory.exactPairingOfFaithful","isProp":false,"doc":"Given candidate data for an exact pairing,\nwhich is sent by a faithful monoidal functor to an exact pairing,\nthe equations holds automatically. ","depth":34}],"count":24}
{"noDocExamples":[{"type":"∀ {C : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} C] [inst_1 : CategoryTheory.MonoidalCategory C] {X Y : C}\n  [inst_2 : CategoryTheory.HasRightDual X] [inst_3 : CategoryTheory.HasRightDual Y] (f : X ⟶ Y),\n  CategoryTheory.CategoryStruct.comp (η_ Y Yᘁ)\n      (CategoryTheory.MonoidalCategory.tensorHom (CategoryTheory.CategoryStruct.id Y) (fᘁ)) =\n    CategoryTheory.CategoryStruct.comp (η_ X Xᘁ)\n      (CategoryTheory.MonoidalCategory.tensorHom f (CategoryTheory.CategoryStruct.id Xᘁ))","name":"CategoryTheory.coevaluation_comp_rightAdjointMate","isProp":true,"depth":21},{"type":"∀ {C : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} C] [inst_1 : CategoryTheory.MonoidalCategory C] {X Y : C}\n  [inst_2 : CategoryTheory.HasLeftDual X] [inst_3 : CategoryTheory.HasLeftDual Y] (f : X ⟶ Y),\n  CategoryTheory.CategoryStruct.comp (η_ (ᘁY) Y)\n      (CategoryTheory.MonoidalCategory.tensorHom (ᘁf) (CategoryTheory.CategoryStruct.id Y)) =\n    CategoryTheory.CategoryStruct.comp (η_ (ᘁX) X)\n      (CategoryTheory.MonoidalCategory.tensorHom (CategoryTheory.CategoryStruct.id ᘁX) f)","name":"CategoryTheory.coevaluation_comp_leftAdjointMate","isProp":true,"depth":22}],"kind":"CategoryTheory.ExactPairing.termη_","examples":[{"type":"{C : Type u_1} →\n  {D : Type u_2} →\n    [inst : CategoryTheory.Category.{u_3, u_1} C] →\n      [inst_1 : CategoryTheory.Category.{u_4, u_2} D] →\n        [inst_2 : CategoryTheory.MonoidalCategory C] →\n          [inst_3 : CategoryTheory.MonoidalCategory D] →\n            (F : CategoryTheory.MonoidalFunctor C D) →\n              [inst_4 : CategoryTheory.Faithful F.toFunctor] →\n                {X Y : C} →\n                  (eval : CategoryTheory.MonoidalCategory.tensorObj Y X ⟶ 𝟙_ C) →\n                    (coeval : 𝟙_ C ⟶ CategoryTheory.MonoidalCategory.tensorObj X Y) →\n                      [inst_5 : CategoryTheory.ExactPairing (F.obj X) (F.obj Y)] →\n                        F.map eval =\n                            CategoryTheory.CategoryStruct.comp\n                              (CategoryTheory.inv (CategoryTheory.LaxMonoidalFunctor.μ F.toLaxMonoidalFunctor Y X))\n                              (CategoryTheory.CategoryStruct.comp (ε_ (F.obj X) (F.obj Y)) F.ε) →\n                          F.map coeval =\n                              CategoryTheory.CategoryStruct.comp (CategoryTheory.inv F.ε)\n                                (CategoryTheory.CategoryStruct.comp (η_ (F.obj X) (F.obj Y))\n                                  (CategoryTheory.LaxMonoidalFunctor.μ F.toLaxMonoidalFunctor X Y)) →\n                            CategoryTheory.ExactPairing X Y","name":"CategoryTheory.exactPairingOfFaithful","isProp":false,"doc":"Given candidate data for an exact pairing,\nwhich is sent by a faithful monoidal functor to an exact pairing,\nthe equations holds automatically. ","depth":34}],"count":24}
{"noDocExamples":[{"type":"∀ {R : Type u_1} [inst : Ring R] {M : Type u_2} [inst_1 : AddCommGroup M] [inst_2 : Module R M] {U : Submodule R M}\n  {x : M}, x ≡ x [SMOD U]","name":"SModEq.rfl","isProp":true,"depth":15},{"type":"∀ {R : Type u_1} [inst : Ring R] {M : Type u_2} [inst_1 : AddCommGroup M] [inst_2 : Module R M] {U : Submodule R M}\n  (x : M), x ≡ x [SMOD U]","name":"SModEq.refl","isProp":true,"depth":15},{"type":"∀ {R : Type u_4} [inst : CommRing R] {I : Ideal R} {x y : R},\n  x ≡ y [SMOD I] → ∀ (f : Polynomial R), Polynomial.eval x f ≡ Polynomial.eval y f [SMOD I]","name":"SModEq.eval","isProp":true,"depth":16}],"kind":"«term_≡_[SMOD_]»","examples":[],"count":23}
{"noDocExamples":[{"type":"∀ {α : Type u_1} {a : α} {n : ℕ}, Sym.replicate (Nat.succ n) a = a ::ₛ Sym.replicate n a","name":"Sym.replicate_succ","isProp":true,"depth":8},{"type":"∀ {α : Type u_1} {n : ℕ} (a : α) (v : Vector α n), a ::ₛ Sym.ofVector v = Sym.ofVector (a ::ᵥ v)","name":"Sym.cons_of_coe_eq","isProp":true,"depth":10},{"type":"∀ {α : Type u_1} {n : ℕ} (a : α) (s : Sym α n), a ∈ a ::ₛ s","name":"Sym.mem_cons_self","isProp":true,"depth":10}],"kind":"Sym.«term_::ₛ_»","examples":[],"count":23}
{"noDocExamples":[],"kind":"Matrix.termGL","examples":[{"type":"{n : Type u} →\n  [inst : DecidableEq n] →\n    [inst_1 : Fintype n] → {R : Type v} → [inst_2 : CommRing R] → Matrix.SpecialLinearGroup n R → GL n R","name":"Matrix.SpecialLinearGroup.coeToGL","isProp":false,"doc":"The map from SL(n) to GL(n) underlying the coercion, forgetting the value of the determinant.\n","depth":14},{"type":"{n : Type u} →\n  [inst : DecidableEq n] →\n    [inst_1 : Fintype n] →\n      {R : Type v} → [inst_2 : CommRing R] → (A : Matrix n n R) → Invertible (Matrix.det A) → GL n R","name":"Matrix.GeneralLinearGroup.mk'","isProp":false,"doc":"Given a matrix with invertible determinant we get an element of `GL n R`","depth":17},{"type":"{n : Type u} →\n  [inst : DecidableEq n] →\n    [inst_1 : Fintype n] → {K : Type u_1} → [inst_2 : Field K] → (A : Matrix n n K) → Matrix.det A ≠ 0 → GL n K","name":"Matrix.GeneralLinearGroup.mkOfDetNeZero","isProp":false,"doc":"Given a matrix with non-zero determinant over a field, we get an element of `GL n K`","depth":18}],"count":23}
{"noDocExamples":[{"type":"∀ (p q : Num), Num.lxor p q = p ^^^ q","name":"Num.lxor_eq_xor","isProp":true,"depth":9},{"type":"∀ {n : ℕ}, Function.Injective fun m => m ^^^ n","name":"Nat.xor_left_injective","isProp":true,"depth":9}],"kind":"«term_^^^_»","examples":[{"type":"∀ (n m : ℕ), SetTheory.PGame.grundyValue (SetTheory.PGame.nim ↑n + SetTheory.PGame.nim ↑m) = ↑(n ^^^ m)","name":"SetTheory.PGame.grundyValue_nim_add_nim","isProp":true,"doc":"The Grundy value of the sum of two nim games with natural numbers of piles equals their bitwise\nxor. ","depth":12}],"count":23}
{"noDocExamples":[{"type":"∀ (n : ℤ), 0 >>> n = 0","name":"Int.zero_shiftRight","isProp":true,"depth":9},{"type":"∀ (m n : ℕ), Nat.shiftRight m n = m >>> n","name":"Nat.shiftRight_eq","isProp":true,"depth":9}],"kind":"«term_>>>_»","examples":[{"type":"∀ (m n : ℕ), m >>> (n + 1) = (m / 2) >>> n","name":"Nat.shiftRight_succ_inside","isProp":true,"doc":"Shiftright on successor with division moved inside. ","depth":11}],"count":22}
{"noDocExamples":[],"kind":"Complex.«term_×ℂ_»","examples":[{"type":"∀ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] [inst_2 : CompleteSpace E] (f : ℂ → E)\n  (z w : ℂ),\n  DifferentiableOn ℂ f (Set.uIcc z.re w.re ×ℂ Set.uIcc z.im w.im) →\n    (((∫ (x : ℝ) in z.re..w.re, f (↑x + ↑z.im * Complex.I)) - ∫ (x : ℝ) in z.re..w.re, f (↑x + ↑w.im * Complex.I)) +\n          Complex.I • ∫ (y : ℝ) in z.im..w.im, f (↑w.re + ↑y * Complex.I)) -\n        Complex.I • ∫ (y : ℝ) in z.im..w.im, f (↑z.re + ↑y * Complex.I) =\n      0","name":"Complex.integral_boundary_rect_eq_zero_of_differentiableOn","isProp":true,"doc":"**Cauchy-Goursat theorem** for a rectangle: the integral of a complex differentiable function\nover the boundary of a rectangle equals zero. More precisely, if `f` is complex differentiable on a\nclosed rectangle, then its integral over the boundary of the rectangle equals zero. ","depth":29},{"type":"∀ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] [inst_2 : CompleteSpace E] (f : ℂ → E)\n  (z w : ℂ),\n  ContinuousOn f (Set.uIcc z.re w.re ×ℂ Set.uIcc z.im w.im) →\n    DifferentiableOn ℂ f (Set.Ioo (min z.re w.re) (max z.re w.re) ×ℂ Set.Ioo (min z.im w.im) (max z.im w.im)) →\n      (((∫ (x : ℝ) in z.re..w.re, f (↑x + ↑z.im * Complex.I)) - ∫ (x : ℝ) in z.re..w.re, f (↑x + ↑w.im * Complex.I)) +\n            Complex.I • ∫ (y : ℝ) in z.im..w.im, f (↑w.re + ↑y * Complex.I)) -\n          Complex.I • ∫ (y : ℝ) in z.im..w.im, f (↑z.re + ↑y * Complex.I) =\n        0","name":"Complex.integral_boundary_rect_eq_zero_of_continuousOn_of_differentiableOn","isProp":true,"doc":"**Cauchy-Goursat theorem for a rectangle**: the integral of a complex differentiable function\nover the boundary of a rectangle equals zero. More precisely, if `f` is continuous on a closed\nrectangle and is complex differentiable on the corresponding open rectangle, then its integral over\nthe boundary of the rectangle equals zero. ","depth":30},{"type":"∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {f : ℂ → E},\n  DiffContOnCl ℂ f (Set.Iio 0 ×ℂ Set.Iio 0) →\n    (∃ c < 2,\n        ∃ B,\n          f =O[Bornology.cobounded ℂ ⊓ Filter.principal (Set.Iio 0 ×ℂ Set.Iio 0)] fun z =>\n            Real.exp (B * Complex.abs z ^ c)) →\n      (∀ x ≤ 0, f ↑x = 0) → (∀ x ≤ 0, f (↑x * Complex.I) = 0) → Set.EqOn f 0 {z | z.re ≤ 0 ∧ z.im ≤ 0}","name":"PhragmenLindelof.eq_zero_on_quadrant_III","isProp":true,"doc":"**Phragmen-Lindelöf principle** in the third quadrant. Let `f : ℂ → E` be a function such that\n\n* `f` is differentiable in the open third quadrant and is continuous on its closure;\n* `‖f z‖` is bounded from above by `A * exp(B * (abs z) ^ c)` on the open third quadrant\n  for some `A`, `B`, and `c < 2`;\n* `f` is equal to zero on the boundary of the third quadrant.\n\nThen `f` is equal to zero on the closed third quadrant. ","depth":31}],"count":22}
{"noDocExamples":[{"type":"∀ {R : Type u_1} [inst : CommRing R] {M : Type u_2} [inst_1 : AddCommGroup M] [inst_2 : Module R M] (f g : M ≃ₗ[R] M),\n  LinearEquiv.det (f ≪≫ₗ g) = LinearEquiv.det g * LinearEquiv.det f","name":"LinearEquiv.det_trans","isProp":true,"depth":41},{"type":"∀ {M : Type u_7} {M₂ : Type u_9} {M₃ : Type u_10} [inst : AddCommMonoid M] [inst_1 : AddCommMonoid M₂]\n  [inst_2 : AddCommMonoid M₃] (e : M ≃+ M₂) (e₂ : M₂ ≃+ M₃),\n  AddEquiv.toNatLinearEquiv e ≪≫ₗ AddEquiv.toNatLinearEquiv e₂ = AddEquiv.toNatLinearEquiv (AddEquiv.trans e e₂)","name":"AddEquiv.toNatLinearEquiv_trans","isProp":true,"depth":41}],"kind":"LinearEquiv.transNotation","examples":[{"type":"∀ {R : Type u_1} [inst : CommRing R] {M : Type u_2} [inst_1 : AddCommGroup M] [inst_2 : Module R M] {M' : Type u_3}\n  [inst_3 : AddCommGroup M'] [inst_4 : Module R M'] (f : M ≃ₗ[R] M) (e : M ≃ₗ[R] M'),\n  LinearEquiv.det (LinearEquiv.symm e ≪≫ₗ f ≪≫ₗ e) = LinearEquiv.det f","name":"LinearEquiv.det_conj","isProp":true,"doc":"Conjugating a linear equiv by a linear equiv does not change its determinant. ","depth":46}],"count":21}
{"noDocExamples":[],"kind":"Set.term𝒫_","examples":[{"type":"∀ {α : Type u} (x : α), 𝒫{x} = {∅, {x}}","name":"Set.powerset_singleton","isProp":true,"doc":"The powerset of a singleton contains only `∅` and the singleton itself. ","depth":9},{"type":"∀ {α : Type u} (s : Set α), Cardinal.mk ↑(𝒫 s) = 2 ^ Cardinal.mk ↑s","name":"Cardinal.mk_powerset","isProp":true,"doc":"A variant of `Cardinal.mk_set` expressed in terms of a `Set` instead of a `Type`. ","depth":11},{"type":"∀ {α : Type u_1}, GaloisConnection (fun x => ⋃₀ x) fun x => 𝒫 x","name":"Set.sUnion_powerset_gc","isProp":true,"doc":"`⋃₀` and `𝒫` form a Galois connection. ","depth":13}],"count":21}
{"noDocExamples":[],"kind":"MeasureTheory.«term∫⋯∫⁻__,_∂_»","examples":[{"type":"∀ {δ : Type u_1} {π : δ → Type u_3} [inst : (x : δ) → MeasurableSpace (π x)] (μ : (i : δ) → MeasureTheory.Measure (π i))\n  [inst_1 : DecidableEq δ] {s : Finset δ} {x y : (i : δ) → π i} (f : ((i : δ) → π i) → ENNReal),\n  (∀ i ∉ s, x i = y i) → (∫⋯∫⁻_s, f ∂μ) x = (∫⋯∫⁻_s, f ∂μ) y","name":"MeasureTheory.lmarginal_congr","isProp":true,"doc":"The marginal distribution is independent of the variables in `s`. ","depth":21},{"type":"∀ {δ : Type u_1} {π : δ → Type u_3} [inst : (x : δ) → MeasurableSpace (π x)] {μ : (i : δ) → MeasureTheory.Measure (π i)}\n  [inst_1 : ∀ (i : δ), MeasureTheory.SigmaFinite (μ i)] [inst_2 : DecidableEq δ] {s : Finset δ}\n  (f : ((i : δ) → π i) → ENNReal),\n  Measurable f →\n    ∀ {i : δ}, i ∉ s → ∫⋯∫⁻_insert i s, f ∂μ = ∫⋯∫⁻_s, fun x => ∫⁻ (xᵢ : π i), f (Function.update x i xᵢ) ∂μ i ∂μ","name":"MeasureTheory.lmarginal_insert'","isProp":true,"doc":"Peel off a single integral from a `lmarginal` integral at the end (compare with\n`lmarginal_insert`, which peels off an integral at the beginning). ","depth":25},{"type":"∀ {δ : Type u_1} {π : δ → Type u_3} [inst : (x : δ) → MeasurableSpace (π x)] {μ : (i : δ) → MeasureTheory.Measure (π i)}\n  [inst_1 : ∀ (i : δ), MeasureTheory.SigmaFinite (μ i)] [inst_2 : DecidableEq δ] {s : Finset δ}\n  (f : ((i : δ) → π i) → ENNReal),\n  Measurable f →\n    ∀ {i : δ}, i ∈ s → ∫⋯∫⁻_s, f ∂μ = ∫⋯∫⁻_Finset.erase s i, fun x => ∫⁻ (xᵢ : π i), f (Function.update x i xᵢ) ∂μ i ∂μ","name":"MeasureTheory.lmarginal_erase'","isProp":true,"doc":"Peel off a single integral from a `lmarginal` integral at the end (compare with\n`lmarginal_erase`, which peels off an integral at the beginning). ","depth":25}],"count":20}
{"noDocExamples":[],"kind":"MeasureTheory.«term⨍⁻_,_∂_»","examples":[{"type":"∀ {α : Type u_1} {m0 : MeasurableSpace α} {μ : MeasureTheory.Measure α} {f : α → ENNReal},\n  μ ≠ 0 → ∫⁻ (a : α), f a ∂μ ≠ ⊤ → ∃ x, ⨍⁻ (a : α), f a ∂μ ≤ f x","name":"MeasureTheory.exists_laverage_le","isProp":true,"doc":"**First moment method**. The maximum of a measurable function is greater than its mean. ","depth":18},{"type":"∀ {α : Type u_1} {m0 : MeasurableSpace α} {μ : MeasureTheory.Measure α} {f : α → ENNReal}\n  [inst : MeasureTheory.IsFiniteMeasure μ], μ ≠ 0 → AEMeasurable f → ∃ x, f x ≤ ⨍⁻ (a : α), f a ∂μ","name":"MeasureTheory.exists_le_laverage","isProp":true,"doc":"**First moment method**. The minimum of a measurable function is smaller than its mean. ","depth":19},{"type":"∀ {α : Type u_1} {m0 : MeasurableSpace α} {μ : MeasureTheory.Measure α} {f : α → ENNReal},\n  μ ≠ 0 → ∫⁻ (a : α), f a ∂μ ≠ ⊤ → 0 < ↑↑μ {x | ⨍⁻ (a : α), f a ∂μ ≤ f x}","name":"MeasureTheory.measure_laverage_le_pos","isProp":true,"doc":"**First moment method**. A measurable function is greater than its mean on a set of positive\nmeasure. ","depth":20}],"count":20}
{"noDocExamples":[],"kind":"«term_→L⋆[_]_»","examples":[{"type":"(𝕜 : Type u_1) →\n  {E : Type u_2} →\n    [inst : IsROrC 𝕜] → [inst_1 : NormedAddCommGroup E] → [inst_2 : InnerProductSpace 𝕜 E] → E →L[𝕜] E →L⋆[𝕜] 𝕜","name":"innerSLFlip","isProp":false,"doc":"The inner product as a continuous sesquilinear map, with the two arguments flipped. ","depth":29},{"type":"(𝕜 : Type u_1) →\n  {E : Type u_2} →\n    [inst : IsROrC 𝕜] → [inst_1 : NormedAddCommGroup E] → [inst_2 : InnerProductSpace 𝕜 E] → E →L⋆[𝕜] E →L[𝕜] 𝕜","name":"innerSL","isProp":false,"doc":"The inner product as a continuous sesquilinear map. Note that `toDualMap` (resp. `toDual`)\nin `InnerProductSpace.Dual` is a version of this given as a linear isometry (resp. linear\nisometric equivalence). ","depth":29},{"type":"{𝕜 : Type u_1} →\n  {E : Type u_2} →\n    [inst : IsROrC 𝕜] →\n      [inst_1 : NormedAddCommGroup E] →\n        [inst_2 : InnerProductSpace 𝕜 E] → [inst_3 : CompleteSpace E] → (E →L⋆[𝕜] E →L[𝕜] 𝕜) → E →L[𝕜] E","name":"InnerProductSpace.continuousLinearMapOfBilin","isProp":false,"doc":"Maps a bounded sesquilinear form to its continuous linear map,\ngiven by interpreting the form as a map `B : E →L⋆[𝕜] NormedSpace.Dual 𝕜 E`\nand dualizing the result using `toDual`.\n","depth":31}],"count":19}
{"noDocExamples":[{"type":"∀ {C : Type uC} [inst : CategoryTheory.Category.{uC', uC} C] {W : CategoryTheory.MorphismProperty C} {D : Type uD}\n  [inst_1 : CategoryTheory.Category.{uD', uD} D]\n  {F G : CategoryTheory.Functor (CategoryTheory.MorphismProperty.Localization W) D}\n  (τ :\n    CategoryTheory.Functor.comp (CategoryTheory.MorphismProperty.Q W) F ⟶\n      CategoryTheory.Functor.comp (CategoryTheory.MorphismProperty.Q W) G),\n  CategoryTheory.CategoryStruct.id (CategoryTheory.MorphismProperty.Q W) ◫\n      CategoryTheory.Localization.Construction.natTransExtension τ =\n    τ","name":"CategoryTheory.Localization.Construction.natTransExtension_hcomp","isProp":true,"depth":23},{"type":"∀ {C : Type uC} [inst : CategoryTheory.Category.{uC', uC} C] {W : CategoryTheory.MorphismProperty C} {D : Type uD}\n  [inst_1 : CategoryTheory.Category.{uD', uD} D]\n  {F G : CategoryTheory.Functor (CategoryTheory.MorphismProperty.Localization W) D} {τ₁ τ₂ : F ⟶ G},\n  CategoryTheory.CategoryStruct.id (CategoryTheory.MorphismProperty.Q W) ◫ τ₁ =\n      CategoryTheory.CategoryStruct.id (CategoryTheory.MorphismProperty.Q W) ◫ τ₂ →\n    τ₁ = τ₂","name":"CategoryTheory.Localization.Construction.natTrans_hcomp_injective","isProp":true,"depth":26},{"type":"∀ {C : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} C] {D : Type u₂} [inst_1 : CategoryTheory.Category.{v₂, u₂} D]\n  {E : Type u₃} [inst_2 : CategoryTheory.Category.{v₃, u₃} E] {F G : CategoryTheory.Functor C D}\n  {H I : CategoryTheory.Functor D E} (α : F ≅ G) (β : H ≅ I), (CategoryTheory.NatIso.hcomp α β).hom = α.hom ◫ β.hom","name":"CategoryTheory.NatIso.hcomp_hom","isProp":true,"depth":27}],"kind":"CategoryTheory.NatTrans.«term_◫_»","examples":[],"count":19}
{"noDocExamples":[],"kind":"CategoryTheory.«term_⥤ₑ_»","examples":[{"type":"(C : Type u₁) →\n  [inst : CategoryTheory.Category.{v₁, u₁} C] →\n    (D : Type u₂) → [inst_1 : CategoryTheory.Category.{v₂, u₂} D] → CategoryTheory.Functor (C ⥤ₑ D) (C ⥤ₗ D)","name":"CategoryTheory.LeftExactFunctor.ofExact","isProp":false,"doc":"Turn an exact functor into a left exact functor. ","depth":12},{"type":"{C : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} C] →\n    {D : Type u₂} →\n      [inst_1 : CategoryTheory.Category.{v₂, u₂} D] →\n        (F : CategoryTheory.Functor C D) →\n          [inst_2 : CategoryTheory.Limits.PreservesFiniteLimits F] →\n            [inst_3 : CategoryTheory.Limits.PreservesFiniteColimits F] → C ⥤ₑ D","name":"CategoryTheory.ExactFunctor.of","isProp":false,"doc":"Turn an exact functor into an object of the category `ExactFunctor C D`. ","depth":12},{"type":"(C : Type u₁) →\n  [inst : CategoryTheory.Category.{v₁, u₁} C] →\n    (D : Type u₂) →\n      [inst_1 : CategoryTheory.Category.{v₂, u₂} D] → CategoryTheory.Functor (C ⥤ₑ D) (CategoryTheory.Functor C D)","name":"CategoryTheory.ExactFunctor.forget","isProp":false,"doc":"An exact functor is in particular a functor. ","depth":12}],"count":18}
{"noDocExamples":[],"kind":"MeasureTheory.«term⨍⁻_In_,_∂_»","examples":[{"type":"∀ {α : Type u_1} {m0 : MeasurableSpace α} {μ : MeasureTheory.Measure α} {s : Set α} {f : α → ENNReal},\n  ↑↑μ s ≠ 0 → ↑↑μ s ≠ ⊤ → AEMeasurable f → ∃ x ∈ s, f x ≤ ⨍⁻ (a : α) in s, f a ∂μ","name":"MeasureTheory.exists_le_setLaverage","isProp":true,"doc":"**First moment method**. The minimum of a measurable function is smaller than its mean. ","depth":21},{"type":"∀ {α : Type u_1} {m0 : MeasurableSpace α} {μ : MeasureTheory.Measure α} {s : Set α} {f : α → ENNReal},\n  ↑↑μ s ≠ 0 → MeasureTheory.NullMeasurableSet s → ∫⁻ (a : α) in s, f a ∂μ ≠ ⊤ → ∃ x ∈ s, ⨍⁻ (a : α) in s, f a ∂μ ≤ f x","name":"MeasureTheory.exists_setLaverage_le","isProp":true,"doc":"**First moment method**. The maximum of a measurable function is greater than its mean. ","depth":21},{"type":"∀ {α : Type u_1} {m0 : MeasurableSpace α} {μ : MeasureTheory.Measure α} {s : Set α} {f : α → ENNReal},\n  ↑↑μ s ≠ 0 →\n    MeasureTheory.NullMeasurableSet s →\n      ∫⁻ (a : α) in s, f a ∂μ ≠ ⊤ → 0 < ↑↑μ {x | x ∈ s ∧ ⨍⁻ (a : α) in s, f a ∂μ ≤ f x}","name":"MeasureTheory.measure_setLaverage_le_pos","isProp":true,"doc":"**First moment method**. A measurable function is greater than its mean on a set of positive\nmeasure. ","depth":23}],"count":18}
{"noDocExamples":[],"kind":"MeasureTheory.«term∫⁻_In_,_»","examples":[{"type":"∀ {x r : ℝ}, x ≤ 0 → ∫⁻ (y : ℝ) in Set.Iio x, ProbabilityTheory.exponentialPdf r y = 0","name":"ProbabilityTheory.lintegral_exponentialPdf_of_nonpos","isProp":true,"doc":"the Lebesgue-Integral of the exponential PDF over nonpositive Reals equals 0","depth":12},{"type":"∀ (t : ℝ) (f : UnitAddCircle → ENNReal), ∫⁻ (a : ℝ) in Set.Ioc t (t + 1), f ↑a = ∫⁻ (b : UnitAddCircle), f b","name":"UnitAddCircle.lintegral_preimage","isProp":true,"doc":"The integral of a measurable function over `UnitAddCircle` is equal to the integral over an\ninterval (t, t + 1] in `ℝ` of its lift to `ℝ`. ","depth":15},{"type":"∀ {α : Type u_1} [inst : MeasurableSpace α] {f : α → ℝ} (μ : MeasureTheory.Measure α),\n  0 ≤ᶠ[MeasureTheory.Measure.ae μ] f →\n    AEMeasurable f → ∫⁻ (ω : α), ENNReal.ofReal (f ω) ∂μ = ∫⁻ (t : ℝ) in Set.Ioi 0, ↑↑μ {a | t ≤ f a}","name":"MeasureTheory.lintegral_eq_lintegral_meas_le","isProp":true,"doc":"The standard case of the layer cake formula / Cavalieri's principle / tail probability formula:\n\nFor a nonnegative function `f` on a measure space, the Lebesgue integral of `f` can\nbe written (roughly speaking) as: `∫⁻ f ∂μ = ∫⁻ t in 0..∞, μ {ω | f(ω) ≥ t}`.\n\nSee `lintegral_eq_lintegral_meas_lt` for a version with sets of the form `{ω | f(ω) > t}`\ninstead. ","depth":16}],"count":17}
{"noDocExamples":[{"type":"∀ (x : ℕ), 0 &&& x = 0","name":"Nat.zero_and","isProp":true,"depth":9},{"type":"∀ (p q : PosNum), PosNum.land p q = p &&& q","name":"PosNum.land_eq_and","isProp":true,"depth":9},{"type":"∀ (p q : Num), Num.land p q = p &&& q","name":"Num.land_eq_and","isProp":true,"depth":9}],"kind":"«term_&&&_»","examples":[],"count":17}
{"noDocExamples":[],"kind":"«term#[_,]»","examples":[{"type":"Lean.Name →\n  List (Bool × Lean.Expr) →\n    optParam (Array Lean.Expr) #[] → optParam (Array Lean.Expr) #[] → Lean.Elab.TermElabM Lean.Expr","name":"Mathlib.Deriving.Traversable.traverseConstructor.mkFunCtor","isProp":false,"doc":"`mkFunCtor ctor [(true, (arg₁ : m type₁)), (false, (arg₂ : type₂)), (true, (arg₃ : m type₃)),\n(false, (arg₄ : type₄))]` makes `fun (x₁ : type₁) (x₃ : type₃) => ctor x₁ arg₂ x₃ arg₄`. ","depth":7},{"type":"Lean.Syntax →\n  Lean.Name →\n    optParam Bool false →\n      optParam (Array Simps.ProjectionRule) #[] →\n        optParam Bool false → Lean.CoreM (List Lean.Name × Array Simps.ProjectionData)","name":"Simps.getRawProjections","isProp":false,"doc":"Get the projections used by `simps` associated to a given structure `str`.\n\nThe returned information is also stored in the environment extension `Simps.structureExt`, which\nis given to `str`. If `str` already has this attribute, the information is read from this\nextension instead. See the documentation for this extension for the data this tactic returns.\n\nThe returned universe levels are the universe levels of the structure. For the projections there\nare three cases\n* If the declaration `{StructureName}.Simps.{projectionName}` has been declared, then the value\n  of this declaration is used (after checking that it is definitionally equal to the actual\n  projection. If you rename the projection name, the declaration should have the *new* projection\n  name.\n* You can also declare a custom projection that is a composite of multiple projections.\n* Otherwise, for every class with the `notation_class` attribute, and the structure has an\n  instance of that notation class, then the projection of that notation class is used for the\n  projection that is definitionally equal to it (if there is such a projection).\n  This means in practice that coercions to function types and sorts will be used instead of\n  a projection, if this coercion is definitionally equal to a projection. Furthermore, for\n  notation classes like `Mul` and `Zero` those projections are used instead of the\n  corresponding projection.\n  Projections for coercions and notation classes are not automatically generated if they are\n  composites of multiple projections (for example when you use `extend` without the\n  `oldStructureCmd` (does this exist?)).\n* Otherwise, the projection of the structure is chosen.\n  For example: ``getRawProjections env `Prod`` gives the default projections.\n```\n  ([u, v], [(`fst, `(Prod.fst.{u v}), [0], true, false),\n     (`snd, `(@Prod.snd.{u v}), [1], true, false)])\n```\n\nOptionally, this command accepts three optional arguments:\n* If `traceIfExists` the command will always generate a trace message when the structure already\n  has an entry in `structureExt`.\n* The `rules` argument specifies whether projections should be added, renamed, used as prefix, and\n  not used by default.\n* if `trc` is true, this tactic will trace information just as if\n  `set_option trace.simps.verbose true` was set.\n","depth":9},{"type":"Lean.MVarId →\n  Lean.Meta.Simp.Context →\n    optParam (Option Lean.Meta.Simp.Discharge) none →\n      optParam Bool true →\n        optParam (Array Lean.FVarId) #[] →\n          optParam Lean.Meta.Simp.UsedSimps ∅ →\n            Lean.MetaM (Option (Array Lean.FVarId × Lean.MVarId) × Lean.Meta.Simp.UsedSimps)","name":"Mathlib.Deriving.Traversable.simpFunctorGoal","isProp":false,"doc":"Simplify the goal `m` using `functor_norm`. ","depth":13}],"count":17}
{"noDocExamples":[{"type":"∀ {C : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} C] [inst_1 : CategoryTheory.MonoidalCategory C] {X : C}\n  [inst_2 : CategoryTheory.HasRightDual X], ᘁXᘁ = X","name":"CategoryTheory.leftDual_rightDual","isProp":true,"depth":14},{"type":"∀ {C : Type u_4} {D : Type u_2} [inst : CategoryTheory.Groupoid C] [inst_1 : CategoryTheory.Category.{u_1, u_2} D]\n  [inst_2 : CategoryTheory.MonoidalCategory D] [inst_3 : CategoryTheory.LeftRigidCategory D]\n  (F : CategoryTheory.Functor C D) (X : C),\n  (ᘁF.map (CategoryTheory.inv (CategoryTheory.CategoryStruct.id X))) = CategoryTheory.CategoryStruct.id ᘁ(F.obj X)","name":"CategoryTheory.Monoidal.functorHasLeftDual.proof_1","isProp":true,"depth":24}],"kind":"CategoryTheory.«termᘁ_»","examples":[{"type":"{C : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} C] →\n    [inst_1 : CategoryTheory.MonoidalCategory C] →\n      {X Y : C} →\n        [inst_2 : CategoryTheory.HasLeftDual X] → [inst_3 : CategoryTheory.HasLeftDual Y] → (X ⟶ Y) → (ᘁY ⟶ ᘁX)","name":"CategoryTheory.leftAdjointMate","isProp":false,"doc":"The left adjoint mate `ᘁf : ᘁY ⟶ ᘁX` of a morphism `f : X ⟶ Y`. ","depth":15}],"count":16}
{"noDocExamples":[{"type":"{C : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} C] →\n    [inst_1 : CategoryTheory.MonoidalCategory C] →\n      {X : C} → [self : CategoryTheory.HasRightDual X] → CategoryTheory.ExactPairing X Xᘁ","name":"CategoryTheory.HasRightDual.exact","isProp":false,"depth":11},{"type":"∀ {C : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} C] [inst_1 : CategoryTheory.MonoidalCategory C] {X : C}\n  [inst_2 : CategoryTheory.HasLeftDual X], (ᘁX)ᘁ = X","name":"CategoryTheory.rightDual_leftDual","isProp":true,"depth":14}],"kind":"CategoryTheory.«term_ᘁ»","examples":[{"type":"{C : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} C] →\n    [inst_1 : CategoryTheory.MonoidalCategory C] →\n      {X Y : C} →\n        [inst_2 : CategoryTheory.HasRightDual X] → [inst_3 : CategoryTheory.HasRightDual Y] → (X ⟶ Y) → (Yᘁ ⟶ Xᘁ)","name":"CategoryTheory.rightAdjointMate","isProp":false,"doc":"The right adjoint mate `fᘁ : Xᘁ ⟶ Yᘁ` of a morphism `f : X ⟶ Y`. ","depth":15}],"count":16}
{"noDocExamples":[{"type":"∀ {α : Type u_1} {a : Array α}, a[Array.size a]? = none","name":"Array.get?_size","isProp":true,"depth":15},{"type":"∀ {α : Type u_1} (a : Array α) (i : ℕ), Array.get? a i = a[i]?","name":"Array.get?_eq_getElem?","isProp":true,"depth":15},{"type":"∀ {α : Type u_1} (a : Array α) (i : ℕ), a[i]? = List.get? a.data i","name":"Array.getElem?_eq_data_get?","isProp":true,"depth":16}],"kind":"«term__[_]_?»","examples":[],"count":16}
{"noDocExamples":[],"kind":"CategoryTheory.LaxMonoidalFunctor.«term_⊗⋙_»","examples":[{"type":"{C : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} C] →\n    [inst_1 : CategoryTheory.MonoidalCategory C] →\n      {D : Type u₂} →\n        [inst_2 : CategoryTheory.Category.{v₂, u₂} D] →\n          (e : C ≌ D) →\n            CategoryTheory.LaxMonoidalFunctor.id C ≅\n              (CategoryTheory.Monoidal.toTransported e).toLaxMonoidalFunctor ⊗⋙\n                (CategoryTheory.Monoidal.fromTransported e).toLaxMonoidalFunctor","name":"CategoryTheory.Monoidal.transportedMonoidalUnitIso","isProp":false,"doc":"The unit isomorphism upgrades to a monoidal isomorphism. ","depth":20},{"type":"{C : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} C] →\n    [inst_1 : CategoryTheory.MonoidalCategory C] →\n      {D : Type u₂} →\n        [inst_2 : CategoryTheory.Category.{v₂, u₂} D] →\n          [inst_3 : CategoryTheory.MonoidalCategory D] →\n            (F : CategoryTheory.MonoidalFunctor C D) →\n              [inst_4 : CategoryTheory.IsEquivalence F.toFunctor] →\n                CategoryTheory.LaxMonoidalFunctor.id C ⟶\n                  F.toLaxMonoidalFunctor ⊗⋙ (CategoryTheory.monoidalInverse F).toLaxMonoidalFunctor","name":"CategoryTheory.monoidalUnit","isProp":false,"doc":"The unit of a monoidal equivalence can be upgraded to a monoidal natural transformation. ","depth":20},{"type":"{C : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} C] →\n    [inst_1 : CategoryTheory.MonoidalCategory C] →\n      {D : Type u₂} →\n        [inst_2 : CategoryTheory.Category.{v₂, u₂} D] →\n          [inst_3 : CategoryTheory.MonoidalCategory D] →\n            (F : CategoryTheory.MonoidalFunctor C D) →\n              [inst_4 : CategoryTheory.IsEquivalence F.toFunctor] →\n                (CategoryTheory.monoidalInverse F).toLaxMonoidalFunctor ⊗⋙ F.toLaxMonoidalFunctor ⟶\n                  CategoryTheory.LaxMonoidalFunctor.id D","name":"CategoryTheory.monoidalCounit","isProp":false,"doc":"The counit of a monoidal equivalence can be upgraded to a monoidal natural transformation. ","depth":21}],"count":16}
{"noDocExamples":[],"kind":"«term_⊇_»","examples":[{"type":"∀ {X : Type u} [inst : TopologicalSpace X] {ι : Type v} [hι : Nonempty ι] (t : ι → Set X),\n  Directed (fun x x_1 => x ⊇ x_1) t →\n    (∀ (i : ι), Set.Nonempty (t i)) →\n      (∀ (i : ι), IsCompact (t i)) → (∀ (i : ι), IsClosed (t i)) → Set.Nonempty (⋂ i, t i)","name":"IsCompact.nonempty_iInter_of_directed_nonempty_compact_closed","isProp":true,"doc":"Cantor's intersection theorem:\nthe intersection of a directed family of nonempty compact closed sets is nonempty. ","depth":15},{"type":"∀ {X : Type u} {ι : Type u_1} [inst : TopologicalSpace X] [inst_1 : Nonempty ι] {V : ι → Set X},\n  Directed (fun x x_1 => x ⊇ x_1) V →\n    (∀ (i : ι), IsCompact (V i)) →\n      (∀ (i : ι), IsClosed (V i)) → ∀ {U : Set X}, (∀ x ∈ ⋂ i, V i, U ∈ nhds x) → ∃ i, V i ⊆ U","name":"exists_subset_nhds_of_isCompact'","isProp":true,"doc":"If `V : ι → Set X` is a decreasing family of closed compact sets then any neighborhood of\n`⋂ i, V i` contains some `V i`. We assume each `V i` is compact *and* closed because `X` is\nnot assumed to be Hausdorff. See `exists_subset_nhd_of_compact` for version assuming this. ","depth":18},{"type":"∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : T2Space X] {ι : Type u_4} [inst_2 : Nonempty ι] {V : ι → Set X},\n  Directed (fun x x_1 => x ⊇ x_1) V →\n    (∀ (i : ι), IsCompact (V i)) → ∀ {U : Set X}, (∀ x ∈ ⋂ i, V i, U ∈ nhds x) → ∃ i, V i ⊆ U","name":"exists_subset_nhds_of_isCompact","isProp":true,"doc":"If `V : ι → Set X` is a decreasing family of compact sets then any neighborhood of\n`⋂ i, V i` contains some `V i`. This is a version of `exists_subset_nhds_of_isCompact'` where we\ndon't need to assume each `V i` closed because it follows from compactness since `X` is\nassumed to be Hausdorff. ","depth":18}],"count":15}
{"noDocExamples":[{"type":"∀ {L : FirstOrder.Language} {T : FirstOrder.Language.Theory L} {φ : FirstOrder.Language.Sentence L}, φ ∈ T → T ⊨ᵇ φ","name":"FirstOrder.Language.Theory.models_sentence_of_mem","isProp":true,"depth":10},{"type":"∀ {L : FirstOrder.Language} {T : FirstOrder.Language.Theory L},\n  FirstOrder.Language.Theory.IsMaximal T → ∀ {φ : FirstOrder.Language.Sentence L}, T ⊨ᵇ φ → φ ∈ T","name":"FirstOrder.Language.Theory.IsMaximal.mem_of_models","isProp":true,"depth":11}],"kind":"FirstOrder.Language.Theory.«term_⊨ᵇ_»","examples":[{"type":"∀ {L : FirstOrder.Language} {T : FirstOrder.Language.Theory L} {φ : FirstOrder.Language.Sentence L},\n  T ⊨ᵇ φ ↔ ∃ T0, ↑T0 ⊆ T ∧ ↑T0 ⊨ᵇ φ","name":"FirstOrder.Language.Theory.models_iff_finset_models","isProp":true,"doc":"An alternative statement of the Compactness Theorem. A formula `φ` is modeled by a\ntheory iff there is a finite subset `T0` of the theory such that `φ` is modeled by `T0` ","depth":14}],"count":14}
{"noDocExamples":[{"type":"∀ {α : Type u_1} [inst : Primcodable α] (p : α → Prop), p ≤₀ p","name":"manyOneReducible_refl","isProp":true,"depth":9},{"type":"∀ {α : Type u} [inst : Primcodable α] [inst_1 : Inhabited α] {p : Set α}, p ≤₀ toNat p","name":"manyOneReducible_toNat","isProp":true,"depth":10},{"type":"∀ {α : Type u} [inst : Primcodable α] [inst_1 : Inhabited α] {p : Set α}, toNat p ≤₀ p","name":"toNat_manyOneReducible","isProp":true,"depth":10}],"kind":"«term_≤₀_»","examples":[],"count":14}
{"noDocExamples":[],"kind":"AlgebraicGeometry.«term_∣_ᵤ_»","examples":[{"type":"{X : AlgebraicGeometry.Scheme} → (U : TopologicalSpace.Opens ↑↑X.toPresheafedSpace) → X ∣_ᵤ U ⟶ X","name":"AlgebraicGeometry.Scheme.ιOpens","isProp":false,"doc":"The restriction of a scheme to an open subset. ","depth":27},{"type":"(X : AlgebraicGeometry.Scheme) → {U V : TopologicalSpace.Opens ↑↑X.toPresheafedSpace} → U = V → (X ∣_ᵤ U ≅ X ∣_ᵤ V)","name":"AlgebraicGeometry.Scheme.restrictIsoOfEq","isProp":false,"doc":"If `U = V`, then `X ∣_ U` is isomorphic to `X ∣_ V`. ","depth":29},{"type":"{X Y : AlgebraicGeometry.Scheme} →\n  (f : X ⟶ Y) → (U : TopologicalSpace.Opens ↑↑Y.toPresheafedSpace) → X ∣_ᵤ f⁻¹ᵁ U ⟶ Y ∣_ᵤ U","name":"AlgebraicGeometry.morphismRestrict","isProp":false,"doc":"The restriction of a morphism `X ⟶ Y` onto `X |_{f ⁻¹ U} ⟶ Y |_ U`. ","depth":30}],"count":14}
{"noDocExamples":[{"type":"∀ (p q : PosNum), PosNum.lor p q = p ||| q","name":"PosNum.lor_eq_or","isProp":true,"depth":9},{"type":"∀ (x : ℕ), 0 ||| x = x","name":"Nat.or_zero","isProp":true,"depth":9}],"kind":"«term_|||_»","examples":[{"type":"∀ {x y n m : ℕ}, x < 2 ^ n → y < 2 ^ m → y <<< n ||| x < 2 ^ (n + m)","name":"Nat.append_lt","isProp":true,"doc":"Note that the LHS is the expression used within `Std.BitVec.append`, hence the name. ","depth":16}],"count":13}
{"noDocExamples":[{"type":"∀ {C : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} C] [inst_1 : CategoryTheory.MonoidalCategory C] {X : C}\n  [inst_2 : CategoryTheory.HasRightDual X], CategoryTheory.CategoryStruct.id Xᘁ = CategoryTheory.CategoryStruct.id Xᘁ","name":"CategoryTheory.rightAdjointMate_id","isProp":true,"depth":15},{"type":"∀ {C : Type u_2} [inst : CategoryTheory.Category.{u_1, u_2} C] [inst_1 : CategoryTheory.MonoidalCategory C]\n  {X Y₁ Y₂ : C} (p₁ : CategoryTheory.ExactPairing X Y₁) (p₂ : CategoryTheory.ExactPairing X Y₂),\n  CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.id Xᘁ) (CategoryTheory.CategoryStruct.id Xᘁ) =\n    CategoryTheory.CategoryStruct.id Y₂","name":"CategoryTheory.rightDualIso.proof_2","isProp":true,"depth":21}],"kind":"CategoryTheory.«term_ᘁ_1»","examples":[{"type":"∀ {C : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} C] [inst_1 : CategoryTheory.MonoidalCategory C] {X Y Z : C}\n  [inst_2 : CategoryTheory.HasRightDual X] [inst_3 : CategoryTheory.HasRightDual Y]\n  [inst_4 : CategoryTheory.HasRightDual Z] {f : X ⟶ Y} {g : Y ⟶ Z},\n  CategoryTheory.CategoryStruct.comp f gᘁ = CategoryTheory.CategoryStruct.comp (gᘁ) (fᘁ)","name":"CategoryTheory.comp_rightAdjointMate","isProp":true,"doc":"The composition of right adjoint mates is the adjoint mate of the composition. ","depth":22}],"count":13}
{"noDocExamples":[],"kind":"Bundle.«term_*ᵖ_»","examples":[{"type":"{B : Type u_1} →\n  {F : Type u_2} →\n    {E : B → Type u_3} → {B' : Type u_4} → (f : B' → B) → Bundle.TotalSpace F (f *ᵖ E) → B' × Bundle.TotalSpace F E","name":"Bundle.pullbackTotalSpaceEmbedding","isProp":false,"doc":"Natural embedding of the total space of `f *ᵖ E` into `B' × TotalSpace F E`. ","depth":11},{"type":"{B : Type u_1} →\n  {F : Type u_2} →\n    {E : B → Type u_3} → {B' : Type u_4} → (f : B' → B) → Bundle.TotalSpace F (f *ᵖ E) → Bundle.TotalSpace F E","name":"Bundle.Pullback.lift","isProp":false,"doc":"The base map `f : B' → B` lifts to a canonical map on the total spaces. ","depth":11},{"type":"{B : Type u} →\n  (F : Type v) →\n    (E : B → Type w₁) →\n      {B' : Type w₂} →\n        (f : B' → B) →\n          [inst : TopologicalSpace B'] →\n            [inst : TopologicalSpace (Bundle.TotalSpace F E)] → TopologicalSpace (Bundle.TotalSpace F (f *ᵖ E))","name":"Pullback.TotalSpace.topologicalSpace","isProp":false,"doc":"The topology on the total space of a pullback bundle is the coarsest topology for which both\nthe projections to the base and the map to the original bundle are continuous. ","depth":13}],"count":13}
{"noDocExamples":[],"kind":"GradedTensorProduct.«term_ᵍ⊗ₜ[_]_»","examples":[{"type":"∀ {R : Type u_1} {ι : Type u_2} {A : Type u_3} {B : Type u_4} [inst : CommSemiring ι] [inst_1 : Module ι (Additive ℤˣ)]\n  [inst_2 : DecidableEq ι] [inst_3 : CommRing R] [inst_4 : Ring A] [inst_5 : Ring B] [inst_6 : Algebra R A]\n  [inst_7 : Algebra R B] (𝒜 : ι → Submodule R A) (ℬ : ι → Submodule R B) [inst_8 : GradedAlgebra 𝒜]\n  [inst_9 : GradedAlgebra ℬ] {i₂ : ι} (a₁ : A) (b₁ : ↥(ℬ 0)) (a₂ : ↥(𝒜 i₂)) (b₂ : B),\n  a₁ ᵍ⊗ₜ[R] ↑b₁ * ↑a₂ ᵍ⊗ₜ[R] b₂ = (a₁ * ↑a₂) ᵍ⊗ₜ[R] (↑b₁ * b₂)","name":"GradedTensorProduct.tmul_zero_coe_mul_coe_tmul","isProp":true,"doc":"A special case for when `b₁` has grade 0. ","depth":44},{"type":"∀ {R : Type u_1} {ι : Type u_2} {A : Type u_3} {B : Type u_4} [inst : CommSemiring ι] [inst_1 : Module ι (Additive ℤˣ)]\n  [inst_2 : DecidableEq ι] [inst_3 : CommRing R] [inst_4 : Ring A] [inst_5 : Ring B] [inst_6 : Algebra R A]\n  [inst_7 : Algebra R B] (𝒜 : ι → Submodule R A) (ℬ : ι → Submodule R B) [inst_8 : GradedAlgebra 𝒜]\n  [inst_9 : GradedAlgebra ℬ] {j₁ : ι} (a₁ : A) (b₁ : ↥(ℬ j₁)) (a₂ : ↥(𝒜 0)) (b₂ : B),\n  a₁ ᵍ⊗ₜ[R] ↑b₁ * ↑a₂ ᵍ⊗ₜ[R] b₂ = (a₁ * ↑a₂) ᵍ⊗ₜ[R] (↑b₁ * b₂)","name":"GradedTensorProduct.tmul_coe_mul_zero_coe_tmul","isProp":true,"doc":"A special case for when `a₂` has grade 0. ","depth":44},{"type":"∀ {R : Type u_1} {ι : Type u_2} {A : Type u_3} {B : Type u_4} [inst : CommSemiring ι] [inst_1 : Module ι (Additive ℤˣ)]\n  [inst_2 : DecidableEq ι] [inst_3 : CommRing R] [inst_4 : Ring A] [inst_5 : Ring B] [inst_6 : Algebra R A]\n  [inst_7 : Algebra R B] (𝒜 : ι → Submodule R A) (ℬ : ι → Submodule R B) [inst_8 : GradedAlgebra 𝒜]\n  [inst_9 : GradedAlgebra ℬ] {j₁ i₂ : ι} (a₁ : A) (b₁ : ↥(ℬ j₁)) (a₂ : ↥(𝒜 i₂)) (b₂ : B),\n  a₁ ᵍ⊗ₜ[R] ↑b₁ * ↑a₂ ᵍ⊗ₜ[R] b₂ = (-1) ^ (j₁ * i₂) • (a₁ * ↑a₂) ᵍ⊗ₜ[R] (↑b₁ * b₂)","name":"GradedTensorProduct.tmul_coe_mul_coe_tmul","isProp":true,"doc":"The characterization of this multiplication on partially homogenous elements. ","depth":48}],"count":13}
{"noDocExamples":[{"type":"∀ {C : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} C] [inst_1 : CategoryTheory.MonoidalCategory C] {X : C}\n  [inst_2 : CategoryTheory.HasLeftDual X], (ᘁCategoryTheory.CategoryStruct.id X) = CategoryTheory.CategoryStruct.id ᘁX","name":"CategoryTheory.leftAdjointMate_id","isProp":true,"depth":15},{"type":"∀ {C : Type u_2} [inst : CategoryTheory.Category.{u_1, u_2} C] [inst_1 : CategoryTheory.MonoidalCategory C]\n  {X₁ X₂ Y : C} (p₁ : CategoryTheory.ExactPairing X₁ Y) (p₂ : CategoryTheory.ExactPairing X₂ Y),\n  CategoryTheory.CategoryStruct.comp (ᘁCategoryTheory.CategoryStruct.id Y) (ᘁCategoryTheory.CategoryStruct.id Y) =\n    CategoryTheory.CategoryStruct.id X₁","name":"CategoryTheory.leftDualIso.proof_1","isProp":true,"depth":21}],"kind":"CategoryTheory.«termᘁ__1»","examples":[{"type":"∀ {C : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} C] [inst_1 : CategoryTheory.MonoidalCategory C] {X Y Z : C}\n  [inst_2 : CategoryTheory.HasLeftDual X] [inst_3 : CategoryTheory.HasLeftDual Y]\n  [inst_4 : CategoryTheory.HasLeftDual Z] {f : X ⟶ Y} {g : Y ⟶ Z},\n  (ᘁCategoryTheory.CategoryStruct.comp f g) = CategoryTheory.CategoryStruct.comp (ᘁg) (ᘁf)","name":"CategoryTheory.comp_leftAdjointMate","isProp":true,"doc":"The composition of left adjoint mates is the adjoint mate of the composition. ","depth":22}],"count":13}
{"noDocExamples":[{"type":"∀ {x : ZFSet}, ZFSet.IsTransitive x → ZFSet.IsTransitive (⋃₀ x)","name":"ZFSet.IsTransitive.sUnion","isProp":true,"depth":4},{"type":"∀ (x : ZFSet), ↑(⋃₀ x) = ⋃₀ ↑x","name":"Class.coe_sUnion","isProp":true,"depth":5}],"kind":"ZFSet.«term⋃₀_»","examples":[{"type":"∀ {x : ZFSet}, ZFSet.IsTransitive x → ⋃₀ x ⊆ x","name":"ZFSet.IsTransitive.sUnion_subset","isProp":true,"doc":"**Alias** of the forward direction of `ZFSet.isTransitive_iff_sUnion_subset`.","depth":6}],"count":12}
{"noDocExamples":[{"type":"∀ {α : Type u} (s : Stream' α), [] ++ₛ s = s","name":"Stream'.nil_append_stream","isProp":true,"depth":7},{"type":"∀ {α : Type u} (l : List α) (h : l ≠ []), Stream'.cycle l h = l ++ₛ Stream'.cycle l h","name":"Stream'.cycle_eq","isProp":true,"depth":8},{"type":"∀ {α : Type u} (l : List α) (s : Stream' α), ↑(l ++ₛ s) = Stream'.Seq.append ↑l ↑s","name":"Stream'.Seq.ofStream_append","isProp":true,"depth":9}],"kind":"Stream'.«term_++ₛ_»","examples":[],"count":11}
{"noDocExamples":[],"kind":"«term∯_InT(_,_),_»","examples":[{"type":"∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] (f : (Fin 1 → ℂ) → E) (c : Fin 1 → ℂ)\n  (R : Fin 1 → ℝ), (∯ (x : Fin 1 → ℂ) in T(c, R), f x) = ∮ (z : ℂ) in C(c 0, R 0), f fun x => z","name":"torusIntegral_dim1","isProp":true,"doc":"In dimension one, `torusIntegral` is the same as `circleIntegral`\n(up to the natural equivalence between `ℂ` and `Fin 1 → ℂ`). ","depth":18},{"type":"∀ {n : ℕ} {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {f : (Fin n → ℂ) → E} {c : Fin n → ℂ}\n  {R : Fin n → ℝ} {C : ℝ},\n  (∀ (θ : Fin n → ℝ), ‖f (torusMap c R θ)‖ ≤ C) →\n    ‖∯ (x : Fin n → ℂ) in T(c, R), f x‖ ≤ ((2 * Real.pi) ^ n * Finset.prod Finset.univ fun i => |R i|) * C","name":"norm_torusIntegral_le_of_norm_le_const","isProp":true,"doc":"If for all `θ : ℝⁿ`, `‖f (torusMap c R θ)‖` is less than or equal to a constant `C : ℝ`, then\n`‖∯ x in T(c, R), f x‖` is less than or equal to `(2 * π)^n * (∏ i, |R i|) * C`","depth":24},{"type":"∀ {n : ℕ} {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {f : (Fin (n + 1) → ℂ) → E}\n  {c : Fin (n + 1) → ℂ} {R : Fin (n + 1) → ℝ},\n  TorusIntegrable f c R →\n    (∯ (x : Fin (n + 1) → ℂ) in T(c, R), f x) =\n      ∮ (x : ℂ) in C(c 0, R 0), ∯ (y : Fin n → ℂ) in T(c ∘ Fin.succ, R ∘ Fin.succ), f (Fin.cons x y)","name":"torusIntegral_succ","isProp":true,"doc":"Recurrent formula for `torusIntegral`, see also `torusIntegral_succAbove`. ","depth":29}],"count":11}
{"noDocExamples":[],"kind":"CategoryTheory.«term_⥤ᵣ_»","examples":[{"type":"{C : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} C] →\n    {D : Type u₂} →\n      [inst_1 : CategoryTheory.Category.{v₂, u₂} D] →\n        (F : CategoryTheory.Functor C D) → [inst_2 : CategoryTheory.Limits.PreservesFiniteColimits F] → C ⥤ᵣ D","name":"CategoryTheory.RightExactFunctor.of","isProp":false,"doc":"Turn a right exact functor into an object of the category `RightExactFunctor C D`. ","depth":11},{"type":"(C : Type u₁) →\n  [inst : CategoryTheory.Category.{v₁, u₁} C] →\n    (D : Type u₂) →\n      [inst_1 : CategoryTheory.Category.{v₂, u₂} D] → CategoryTheory.Functor (C ⥤ᵣ D) (CategoryTheory.Functor C D)","name":"CategoryTheory.RightExactFunctor.forget","isProp":false,"doc":"A right exact functor is in particular a functor. ","depth":12},{"type":"(C : Type u₁) →\n  [inst : CategoryTheory.Category.{v₁, u₁} C] →\n    (D : Type u₂) → [inst_1 : CategoryTheory.Category.{v₂, u₂} D] → CategoryTheory.Functor (C ⥤ₑ D) (C ⥤ᵣ D)","name":"CategoryTheory.RightExactFunctor.ofExact","isProp":false,"doc":"Turn an exact functor into a left exact functor. ","depth":12}],"count":11}
{"noDocExamples":[{"type":"∀ {α : Type u_1} [inst : Primcodable α] (p : α → Prop), p ≤₁ p","name":"oneOneReducible_refl","isProp":true,"depth":9},{"type":"∀ {α : Type u_1} {β : Type u_2} [inst : Primcodable α] [inst_1 : Primcodable β] {p : α → Prop} {q : β → Prop},\n  p ≤₁ Sum.elim p q","name":"OneOneReducible.disjoin_left","isProp":true,"depth":13},{"type":"∀ {α : Type u_1} {β : Type u_2} [inst : Primcodable α] [inst_1 : Primcodable β] {p : α → Prop} {q : β → Prop},\n  p ≤₁ q → p ≤₀ q","name":"OneOneReducible.to_many_one","isProp":true,"depth":13}],"kind":"«term_≤₁_»","examples":[],"count":11}
{"noDocExamples":[{"type":"∀ (a : Cardinal.{u_1}), Monotone fun c => a ^< c","name":"Cardinal.powerlt_mono_left","isProp":true,"depth":6},{"type":"∀ {c : Cardinal.{u_1}}, Cardinal.aleph0 ≤ c → c ^< Cardinal.aleph0 = c","name":"Cardinal.powerlt_aleph0","isProp":true,"depth":6},{"type":"∀ (c : Cardinal.{u_1}), c ^< Cardinal.aleph0 ≤ max c Cardinal.aleph0","name":"Cardinal.powerlt_aleph0_le","isProp":true,"depth":7}],"kind":"Cardinal.«term_^<_»","examples":[],"count":11}
{"noDocExamples":[],"kind":"CategoryTheory.«term_⥤ₗ_»","examples":[{"type":"{C : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} C] →\n    {D : Type u₂} →\n      [inst_1 : CategoryTheory.Category.{v₂, u₂} D] →\n        (F : CategoryTheory.Functor C D) → [inst_2 : CategoryTheory.Limits.PreservesFiniteLimits F] → C ⥤ₗ D","name":"CategoryTheory.LeftExactFunctor.of","isProp":false,"doc":"Turn a left exact functor into an object of the category `LeftExactFunctor C D`. ","depth":11},{"type":"(C : Type u₁) →\n  [inst : CategoryTheory.Category.{v₁, u₁} C] →\n    (D : Type u₂) → [inst_1 : CategoryTheory.Category.{v₂, u₂} D] → CategoryTheory.Functor (C ⥤ₑ D) (C ⥤ₗ D)","name":"CategoryTheory.LeftExactFunctor.ofExact","isProp":false,"doc":"Turn an exact functor into a left exact functor. ","depth":12},{"type":"(C : Type u₁) →\n  [inst : CategoryTheory.Category.{v₁, u₁} C] →\n    (D : Type u₂) →\n      [inst_1 : CategoryTheory.Category.{v₂, u₂} D] → CategoryTheory.Functor (C ⥤ₗ D) (CategoryTheory.Functor C D)","name":"CategoryTheory.LeftExactFunctor.forget","isProp":false,"doc":"A left exact functor is in particular a functor. ","depth":12}],"count":11}
{"noDocExamples":[{"type":"∀ {U : Type u_1} [inst : Quiver U] [inst_1 : Quiver.HasReverse U], Prefunctor.MapReverse (𝟭q U)","name":"Prefunctor.mapReverseId","isProp":true,"depth":10},{"type":"∀ {V : Type u} [inst : Quiver V],\n  CategoryTheory.freeGroupoidFunctor (𝟭q V) = CategoryTheory.Functor.id (CategoryTheory.FreeGroupoid V)","name":"CategoryTheory.Groupoid.Free.freeGroupoidFunctor_id","isProp":true,"depth":11},{"type":"∀ (V : Type u_1) [inst : Quiver V] (X : V), (𝟭q V).obj X = X","name":"Prefunctor.id_obj","isProp":true,"depth":11}],"kind":"Prefunctor.«term𝟭q»","examples":[],"count":10}
{"noDocExamples":[],"kind":"CategoryTheory.«term_⥤+_»","examples":[{"type":"{C : Type u_1} →\n  {D : Type u_2} →\n    [inst : CategoryTheory.Category.{u_3, u_1} C] →\n      [inst_1 : CategoryTheory.Category.{u_4, u_2} D] →\n        [inst_2 : CategoryTheory.Preadditive C] →\n          [inst_3 : CategoryTheory.Preadditive D] →\n            (F : CategoryTheory.Functor C D) → [inst_4 : CategoryTheory.Functor.Additive F] → C ⥤+ D","name":"CategoryTheory.AdditiveFunctor.of","isProp":false,"doc":"Turn an additive functor into an object of the category `AdditiveFunctor C D`. ","depth":15},{"type":"(C : Type u_1) →\n  (D : Type u_2) →\n    [inst : CategoryTheory.Category.{u_3, u_1} C] →\n      [inst_1 : CategoryTheory.Category.{u_4, u_2} D] →\n        [inst_2 : CategoryTheory.Preadditive C] →\n          [inst_3 : CategoryTheory.Preadditive D] → CategoryTheory.Functor (C ⥤+ D) (CategoryTheory.Functor C D)","name":"CategoryTheory.AdditiveFunctor.forget","isProp":false,"doc":"An additive functor is in particular a functor. ","depth":16},{"type":"(C : Type u₁) →\n  (D : Type u₂) →\n    [inst : CategoryTheory.Category.{v₁, u₁} C] →\n      [inst_1 : CategoryTheory.Category.{v₂, u₂} D] →\n        [inst_2 : CategoryTheory.Preadditive C] →\n          [inst_3 : CategoryTheory.Preadditive D] →\n            [inst_4 : CategoryTheory.Limits.HasZeroObject C] →\n              [inst_5 : CategoryTheory.Limits.HasZeroObject D] →\n                [inst_6 : CategoryTheory.Limits.HasBinaryBiproducts C] → CategoryTheory.Functor (C ⥤ₗ D) (C ⥤+ D)","name":"CategoryTheory.AdditiveFunctor.ofLeftExact","isProp":false,"doc":"Turn a left exact functor into an additive functor. ","depth":17}],"count":10}
{"noDocExamples":[{"type":"∀ {x y : CategoryTheory.Limits.WalkingParallelFamily (ULift.{w, 0} Bool)} (h : x ⟶ y),\n  CategoryTheory.Limits.walkingParallelFamilyEquivWalkingParallelPair.functor.map h =\n    match x, y, h with\n    | x, .(x), CategoryTheory.Limits.WalkingParallelFamily.Hom.id .(x) =>\n      CategoryTheory.CategoryStruct.id\n        (CategoryTheory.Limits.WalkingParallelFamily.rec CategoryTheory.Limits.WalkingParallelPair.zero\n          CategoryTheory.Limits.WalkingParallelPair.one x)\n    | .(CategoryTheory.Limits.WalkingParallelFamily.zero), .(CategoryTheory.Limits.WalkingParallelFamily.one),\n      CategoryTheory.Limits.WalkingParallelFamily.Hom.line j =>\n      bif j.down then CategoryTheory.Limits.WalkingParallelPairHom.left\n      else CategoryTheory.Limits.WalkingParallelPairHom.right","name":"CategoryTheory.Limits.walkingParallelFamilyEquivWalkingParallelPair_functor_map","isProp":true,"depth":22},{"type":"∀ {X Y : CategoryTheory.Limits.WalkingParallelPair} (h : X ⟶ Y),\n  CategoryTheory.Limits.walkingParallelFamilyEquivWalkingParallelPair.inverse.map h =\n    match X, Y, h with\n    | x, .(x), CategoryTheory.Limits.WalkingParallelPairHom.id .(x) =>\n      CategoryTheory.CategoryStruct.id\n        (match x with\n        | CategoryTheory.Limits.WalkingParallelPair.zero => CategoryTheory.Limits.WalkingParallelFamily.zero\n        | CategoryTheory.Limits.WalkingParallelPair.one => CategoryTheory.Limits.WalkingParallelFamily.one)\n    | .(CategoryTheory.Limits.WalkingParallelPair.zero), .(CategoryTheory.Limits.WalkingParallelPair.one),\n      CategoryTheory.Limits.WalkingParallelPairHom.left =>\n      CategoryTheory.Limits.WalkingParallelFamily.Hom.line { down := true }\n    | .(CategoryTheory.Limits.WalkingParallelPair.zero), .(CategoryTheory.Limits.WalkingParallelPair.one),\n      CategoryTheory.Limits.WalkingParallelPairHom.right =>\n      CategoryTheory.Limits.WalkingParallelFamily.Hom.line { down := false }","name":"CategoryTheory.Limits.walkingParallelFamilyEquivWalkingParallelPair_inverse_map","isProp":true,"depth":23},{"type":"∀ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] (I : CategoryTheory.Limits.MulticospanIndex C)\n  [inst_1 : CategoryTheory.Limits.HasProduct I.left] [inst_2 : CategoryTheory.Limits.HasProduct I.right]\n  {X Y : CategoryTheory.Limits.WalkingParallelPair} (h : X ⟶ Y),\n  (CategoryTheory.Limits.MulticospanIndex.parallelPairDiagram I).map h =\n    match X, Y, h with\n    | x, .(x), CategoryTheory.Limits.WalkingParallelPairHom.id .(x) =>\n      CategoryTheory.CategoryStruct.id\n        (match x with\n        | CategoryTheory.Limits.WalkingParallelPair.zero => ∏ I.left\n        | CategoryTheory.Limits.WalkingParallelPair.one => ∏ I.right)\n    | .(CategoryTheory.Limits.WalkingParallelPair.zero), .(CategoryTheory.Limits.WalkingParallelPair.one),\n      CategoryTheory.Limits.WalkingParallelPairHom.left => CategoryTheory.Limits.MulticospanIndex.fstPiMap I\n    | .(CategoryTheory.Limits.WalkingParallelPair.zero), .(CategoryTheory.Limits.WalkingParallelPair.one),\n      CategoryTheory.Limits.WalkingParallelPairHom.right => CategoryTheory.Limits.MulticospanIndex.sndPiMap I","name":"CategoryTheory.Limits.MulticospanIndex.parallelPairDiagram_map","isProp":true,"depth":32}],"kind":"Lean.Parser.Term.inaccessible","examples":[],"count":9}
{"noDocExamples":[],"kind":"MeasureTheory.«term∫⁻_,_»","examples":[{"type":"∀ (r : ℝ), 0 < r → ∫⁻ (x : ℝ), ProbabilityTheory.exponentialPdf r x = 1","name":"ProbabilityTheory.lintegral_exponentialPdf_eq_one","isProp":true,"doc":"The Pdf of the exponential Distribution integrates to 1","depth":9},{"type":"∀ (μ : ℝ) {v : NNReal}, v ≠ 0 → ∫⁻ (x : ℝ), ENNReal.ofReal (ProbabilityTheory.gaussianPdfReal μ v x) = 1","name":"ProbabilityTheory.lintegral_gaussianPdfReal_eq_one","isProp":true,"doc":"The gaussian distribution pdf integrates to 1 when the variance is not zero.  ","depth":11},{"type":"∀ (t : ℝ) (f : UnitAddCircle → ENNReal), ∫⁻ (a : ℝ) in Set.Ioc t (t + 1), f ↑a = ∫⁻ (b : UnitAddCircle), f b","name":"UnitAddCircle.lintegral_preimage","isProp":true,"doc":"The integral of a measurable function over `UnitAddCircle` is equal to the integral over an\ninterval (t, t + 1] in `ℝ` of its lift to `ℝ`. ","depth":15}],"count":9}
{"noDocExamples":[{"type":"∀ {α : Type u} (s₁ : Stream' α), Stream'.even s₁ ⋈ Stream'.odd s₁ = s₁","name":"Stream'.interleave_even_odd","isProp":true,"depth":8},{"type":"∀ {α : Type u} (s₁ s₂ : Stream' α), Stream'.tail s₁ ⋈ Stream'.tail s₂ = Stream'.tail (Stream'.tail (s₁ ⋈ s₂))","name":"Stream'.interleave_tail_tail","isProp":true,"depth":9},{"type":"∀ {α : Type u} (s₁ s₂ : Stream' α), Stream'.tail (s₁ ⋈ s₂) = s₂ ⋈ Stream'.tail s₁","name":"Stream'.tail_interleave","isProp":true,"depth":9}],"kind":"Stream'.«term_⋈_»","examples":[],"count":9}
{"noDocExamples":[{"type":"∀ (b : Bool), (Bool.toNat b != 1) = !b","name":"Bool.toNat_bne_one","isProp":true,"depth":7},{"type":"∀ (b : Bool), (Bool.toNat b != 0) = b","name":"Bool.toNat_bne_zero","isProp":true,"depth":7},{"type":"∀ (n : ℕ), Nat.bodd n = (n &&& 1 != 0)","name":"Nat.bodd_eq_and_one_ne_zero","isProp":true,"depth":10}],"kind":"«term_!=_»","examples":[],"count":7}
{"noDocExamples":[{"type":"⋂₀ ∅ = ∅","name":"ZFSet.sInter_empty","isProp":true,"depth":5},{"type":"∀ {x : ZFSet}, ZFSet.Nonempty x → ↑(⋂₀ x) = ⋂₀ ↑x","name":"Class.coe_sInter","isProp":true,"depth":6},{"type":"∀ {x : ZFSet}, ⋂₀ {x} = x","name":"ZFSet.sInter_singleton","isProp":true,"depth":8}],"kind":"ZFSet.«term⋂₀_»","examples":[],"count":7}
{"noDocExamples":[{"type":"∀ {α : Type u_1} [inst : MeasurableSpace α] {μ : MeasureTheory.Measure α} {p : α → Prop},\n  (∃ᵐ (a : α) ∂μ, p a) ↔ ↑↑μ {a | p a} ≠ 0","name":"MeasureTheory.frequently_ae_iff","isProp":true,"depth":12},{"type":"∀ {α : Type u_1} [inst : MeasurableSpace α] {μ : MeasureTheory.Measure α} {s : Set α},\n  (∃ᵐ (a : α) ∂μ, a ∈ s) ↔ ↑↑μ s ≠ 0","name":"MeasureTheory.frequently_ae_mem_iff","isProp":true,"depth":14}],"kind":"MeasureTheory.«term∃ᵐ_∂_,_»","examples":[{"type":"∀ {α : Type u_2} [inst : MeasurableSpace α] {f : α → α} {s : Set α} {μ : MeasureTheory.Measure α},\n  MeasureTheory.Conservative f μ →\n    MeasurableSet s → ↑↑μ s ≠ 0 → ∃ᵐ (x : α) ∂μ, x ∈ s ∧ ∃ᶠ (n : ℕ) in Filter.atTop, f^[n] x ∈ s","name":"MeasureTheory.Conservative.frequently_ae_mem_and_frequently_image_mem","isProp":true,"doc":"If `f` is a conservative self-map and `s` is a measurable set of positive measure, then\n`μ.ae`-frequently we have `x ∈ s` and `s` returns to `s` under infinitely many iterations of `f`. ","depth":21}],"count":5}
{"noDocExamples":[{"type":"⋂₀ ∅ = Class.univ","name":"Class.sInter_empty","isProp":true,"depth":5},{"type":"∀ {x : ZFSet}, ZFSet.Nonempty x → ↑(⋂₀ x) = ⋂₀ ↑x","name":"Class.coe_sInter","isProp":true,"depth":6},{"type":"∀ {x : Class} {y : ZFSet}, (⋂₀ x) y ↔ ∀ (z : ZFSet), x z → y ∈ z","name":"Class.sInter_apply","isProp":true,"depth":10}],"kind":"Class.«term⋂₀_»","examples":[],"count":5}
{"noDocExamples":[],"kind":"«term_≃ₗᵢ⋆[_]_»","examples":[{"type":"(𝕜 : Type u_1) →\n  {E : Type u_2} →\n    [inst : CommSemiring 𝕜] →\n      [inst_1 : StarRing 𝕜] →\n        [inst_2 : SeminormedAddCommGroup E] →\n          [inst_3 : StarAddMonoid E] →\n            [inst_4 : NormedStarGroup E] → [inst_5 : Module 𝕜 E] → [inst_6 : StarModule 𝕜 E] → E ≃ₗᵢ⋆[𝕜] E","name":"starₗᵢ","isProp":false,"doc":"`star` bundled as a linear isometric equivalence ","depth":23},{"type":"(𝕜 : Type u_1) →\n  (E : Type u_2) →\n    [inst : IsROrC 𝕜] →\n      [inst_1 : NormedAddCommGroup E] →\n        [inst_2 : InnerProductSpace 𝕜 E] → [inst_3 : CompleteSpace E] → E ≃ₗᵢ⋆[𝕜] NormedSpace.Dual 𝕜 E","name":"InnerProductSpace.toDual","isProp":false,"doc":"Fréchet-Riesz representation: any `ℓ` in the dual of a Hilbert space `E` is of the form\n`fun u => ⟪y, u⟫` for some `y : E`, i.e. `toDualMap` is surjective.\n","depth":31},{"type":"{𝕜 : Type u_1} →\n  {E : Type u_2} →\n    {F : Type u_3} →\n      [inst : IsROrC 𝕜] →\n        [inst_1 : NormedAddCommGroup E] →\n          [inst_2 : NormedAddCommGroup F] →\n            [inst_3 : InnerProductSpace 𝕜 E] →\n              [inst_4 : InnerProductSpace 𝕜 F] →\n                [inst_5 : CompleteSpace E] → [inst_6 : CompleteSpace F] → (E →L[𝕜] F) ≃ₗᵢ⋆[𝕜] F →L[𝕜] E","name":"ContinuousLinearMap.adjoint","isProp":false,"doc":"The adjoint of a bounded operator from Hilbert space `E` to Hilbert space `F`. ","depth":35}],"count":5}
{"noDocExamples":[{"type":"∀ {α : Type u} (s : Stream' α), Stream'.pure id ⊛ s = s","name":"Stream'.identity","isProp":true,"depth":9},{"type":"∀ {α : Type u} {β : Type v} (f : α → β) (s : Stream' α), Stream'.map f s = Stream'.pure f ⊛ s","name":"Stream'.map_eq_apply","isProp":true,"depth":10},{"type":"∀ {α : Type u} {β : Type v} (f : α → β) (a : α), Stream'.pure f ⊛ Stream'.pure a = Stream'.pure (f a)","name":"Stream'.homomorphism","isProp":true,"depth":11}],"kind":"Stream'.«term_⊛_»","examples":[],"count":5}
{"noDocExamples":[{"type":"∀ {α : Type u} [inst : Lattice α] [inst_1 : AddGroup α] (a : α), |(-a)| = |a|","name":"LatticeOrderedGroup.abs_neg","isProp":true,"depth":15}],"kind":"Lean.Parser.Term.paren","examples":[{"type":"∀ {α : Type u} [inst : Lattice α] [inst_1 : AddGroup α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1]\n  [inst_3 : CovariantClass α α (Function.swap fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] (a : α), |(|a|)| = |a|","name":"LatticeOrderedGroup.abs_abs","isProp":true,"doc":"The unary operation of taking the absolute value is idempotent.","depth":19},{"type":"∀ {α : Type u} [inst : Lattice α] [inst_1 : Group α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x * x_1) fun x x_1 => x ≤ x_1]\n  [inst_3 : CovariantClass α α (Function.swap fun x x_1 => x * x_1) fun x x_1 => x ≤ x_1] (a : α), |(|a|)| = |a|","name":"LatticeOrderedGroup.mabs_mabs","isProp":true,"doc":"The unary operation of taking the absolute value is idempotent. ","depth":19}],"count":5}
{"noDocExamples":[{"type":"∀ {m : Type u → Type v} [inst : Monad m] [inst_1 : LawfulMonad m] {α : Type u_1} {β : Type u} (f : α → m β),\n  f >=> pure = f","name":"fish_pure","isProp":true,"depth":15},{"type":"∀ (m : Type u_1 → Type u_1) [inst : Monad m] [inst_1 : LawfulMonad m] {X Y : CategoryTheory.KleisliCat m} (f : X ⟶ Y),\n  f >=> pure = pure >=> f","name":"CategoryTheory.eq.proof_5","isProp":true,"depth":15},{"type":"∀ {m : Type u → Type v} [inst : Monad m] [inst_1 : LawfulMonad m] {α β : Type u} (f : α → m β), pure >=> f = f","name":"fish_pipe","isProp":true,"depth":15}],"kind":"«term_>=>_»","examples":[],"count":4}
{"noDocExamples":[{"type":"∀ (x : ZFSet), ↑(⋃₀ x) = ⋃₀ ↑x","name":"Class.coe_sUnion","isProp":true,"depth":5},{"type":"⋃₀ ∅ = ∅","name":"Class.sUnion_empty","isProp":true,"depth":5},{"type":"∀ {x : Class} {y : ZFSet}, (⋃₀ x) y ↔ ∃ z, x z ∧ y ∈ z","name":"Class.sUnion_apply","isProp":true,"depth":11}],"kind":"Class.«term⋃₀_»","examples":[],"count":4}
{"noDocExamples":[{"type":"∀ (x : PSet), PSet.toSet (⋃₀ x) = ⋃₀ (PSet.toSet '' PSet.toSet x)","name":"PSet.toSet_sUnion","isProp":true,"depth":7},{"type":"∀ (x x_1 : PSet), PSet.Equiv x x_1 → PSet.Arity.Equiv (⋃₀ x) (⋃₀ x_1)","name":"ZFSet.sUnion.proof_1","isProp":true,"depth":8},{"type":"∀ {x y : PSet}, y ∈ ⋃₀ x ↔ ∃ z ∈ x, y ∈ z","name":"PSet.mem_sUnion","isProp":true,"depth":12}],"kind":"PSet.«term⋃₀_»","examples":[],"count":4}
{"noDocExamples":[{"type":"∀ (F A : Class), F ′ A ∈ Class.univ","name":"Class.fval_ex","isProp":true,"depth":7},{"type":"∀ (x : ZFSet), ∅ ∉ x → ∀ y ∈ x, ↑(ZFSet.choice x) ′ ↑y ∈ ↑y","name":"ZFSet.choice_mem","isProp":true,"depth":10},{"type":"∀ {f : ZFSet → ZFSet} [H : PSet.Definable 1 f] {x y : ZFSet}, y ∈ x → ↑(ZFSet.map f x) ′ ↑y = ↑(f y)","name":"ZFSet.map_fval","isProp":true,"depth":13}],"kind":"Class.«term_′_»","examples":[],"count":3}
{"noDocExamples":[],"kind":"«term_≃ₗ⋆[_]_»","examples":[{"type":"(R : Type u_1) →\n  {A : Type u_2} →\n    [inst : CommSemiring R] →\n      [inst_1 : StarRing R] →\n        [inst_2 : AddCommMonoid A] →\n          [inst_3 : StarAddMonoid A] → [inst_4 : Module R A] → [inst_5 : StarModule R A] → A ≃ₗ⋆[R] A","name":"starLinearEquiv","isProp":false,"doc":"If `A` is a module over a commutative `R` with compatible actions,\nthen `star` is a semilinear equivalence. ","depth":22},{"type":"(m : Type u_2) →\n  (n : Type u_3) →\n    (R : Type u_7) →\n      (α : Type v) →\n        [inst : CommSemiring R] →\n          [inst_1 : StarRing R] →\n            [inst_2 : AddCommMonoid α] →\n              [inst_3 : StarAddMonoid α] →\n                [inst_4 : Module R α] → [inst_5 : StarModule R α] → Matrix m n α ≃ₗ⋆[R] Matrix n m α","name":"Matrix.conjTransposeLinearEquiv","isProp":false,"doc":"`Matrix.conjTranspose` as a `LinearMap` ","depth":24},{"type":"{𝕜 : Type u_1} →\n  {E : Type u_2} →\n    {F : Type u_3} →\n      [inst : IsROrC 𝕜] →\n        [inst_1 : NormedAddCommGroup E] →\n          [inst_2 : NormedAddCommGroup F] →\n            [inst_3 : InnerProductSpace 𝕜 E] →\n              [inst_4 : InnerProductSpace 𝕜 F] →\n                [inst_5 : FiniteDimensional 𝕜 E] → [inst_6 : FiniteDimensional 𝕜 F] → (E →ₗ[𝕜] F) ≃ₗ⋆[𝕜] F →ₗ[𝕜] E","name":"LinearMap.adjoint","isProp":false,"doc":"The adjoint of an operator from the finite-dimensional inner product space `E` to the\nfinite-dimensional inner product space `F`. ","depth":32}],"count":3}
{"noDocExamples":[{"type":"∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] (f : ℝ → E) (a b : ℝ),\n  ⨍ (x : ℝ) in a..b, f x = ⨍ (x : ℝ) in b..a, f x","name":"interval_average_symm","isProp":true,"depth":15},{"type":"∀ (f : ℝ → ℝ) (a b : ℝ), ⨍ (x : ℝ) in a..b, f x = (∫ (x : ℝ) in a..b, f x) / (b - a)","name":"interval_average_eq_div","isProp":true,"depth":16},{"type":"∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] (f : ℝ → E) (a b : ℝ),\n  ⨍ (x : ℝ) in a..b, f x = (b - a)⁻¹ • ∫ (x : ℝ) in a..b, f x","name":"interval_average_eq","isProp":true,"depth":22}],"kind":"«term⨍_In_.._,_»","examples":[],"count":3}
{"noDocExamples":[{"type":"∀ {C : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} C] [inst_1 : CategoryTheory.MonoidalCategory C] {D : Type u₂}\n  [inst_2 : CategoryTheory.Category.{v₂, u₂} D] [inst_3 : CategoryTheory.MonoidalCategory D] {E : Type u₃}\n  [inst_4 : CategoryTheory.Category.{v₃, u₃} E] [inst_5 : CategoryTheory.MonoidalCategory E]\n  (F : CategoryTheory.MonoidalFunctor C D) (G : CategoryTheory.MonoidalFunctor D E),\n  (F ⊗⋙ G).toLaxMonoidalFunctor = F.toLaxMonoidalFunctor ⊗⋙ G.toLaxMonoidalFunctor","name":"CategoryTheory.MonoidalFunctor.comp_toLaxMonoidalFunctor","isProp":true,"depth":25}],"kind":"CategoryTheory.MonoidalFunctor.«term_⊗⋙_»","examples":[{"type":"{M : Type u} →\n  [inst : Monoid M] →\n    {N : Type u'} →\n      [inst_1 : Monoid N] →\n        {K : Type u} →\n          [inst_2 : Monoid K] →\n            (F : M →* N) →\n              (G : N →* K) →\n                CategoryTheory.Discrete.monoidalFunctor F ⊗⋙ CategoryTheory.Discrete.monoidalFunctor G ≅\n                  CategoryTheory.Discrete.monoidalFunctor (MonoidHom.comp G F)","name":"CategoryTheory.Discrete.monoidalFunctorComp","isProp":false,"doc":"The monoidal natural isomorphism corresponding to composing two multiplicative morphisms.\n","depth":22},{"type":"{M : Type u} →\n  [inst : AddMonoid M] →\n    {N : Type u'} →\n      [inst_1 : AddMonoid N] →\n        {K : Type u} →\n          [inst_2 : AddMonoid K] →\n            (F : M →+ N) →\n              (G : N →+ K) →\n                CategoryTheory.Discrete.addMonoidalFunctor F ⊗⋙ CategoryTheory.Discrete.addMonoidalFunctor G ≅\n                  CategoryTheory.Discrete.addMonoidalFunctor (AddMonoidHom.comp G F)","name":"CategoryTheory.Discrete.addMonoidalFunctorComp","isProp":false,"doc":"The monoidal natural isomorphism corresponding to\ncomposing two additive morphisms.","depth":22}],"count":3}
{"noDocExamples":[],"kind":"«term_→ₗ⋆[_]_»","examples":[{"type":"{𝕜 : Type u_1} →\n  {E : Type u_2} →\n    [inst : IsROrC 𝕜] → [inst_1 : NormedAddCommGroup E] → [inst_2 : InnerProductSpace 𝕜 E] → E →ₗ[𝕜] E →ₗ⋆[𝕜] 𝕜","name":"sesqFormOfInner","isProp":false,"doc":"The inner product as a sesquilinear form.\n\nNote that in the case `𝕜 = ℝ` this is a bilinear form. ","depth":26},{"type":"(𝕜 : Type u_1) →\n  {E : Type u_2} →\n    [inst : IsROrC 𝕜] → [inst_1 : NormedAddCommGroup E] → [inst_2 : InnerProductSpace 𝕜 E] → E →ₗ⋆[𝕜] E →ₗ[𝕜] 𝕜","name":"innerₛₗ","isProp":false,"doc":"The inner product as a sesquilinear map. ","depth":26}],"count":2}
{"noDocExamples":[],"kind":"«term_≃L⋆[_]_»","examples":[{"type":"(R : Type u_1) →\n  {A : Type u_2} →\n    [inst : CommSemiring R] →\n      [inst_1 : StarRing R] →\n        [inst_2 : AddCommMonoid A] →\n          [inst_3 : StarAddMonoid A] →\n            [inst_4 : Module R A] →\n              [inst_5 : StarModule R A] → [inst_6 : TopologicalSpace A] → [inst_7 : ContinuousStar A] → A ≃L⋆[R] A","name":"starL","isProp":false,"doc":"If `A` is a topological module over a commutative `R` with compatible actions,\nthen `star` is a continuous semilinear equivalence. ","depth":26}],"count":1}
{"noDocExamples":[{"type":"∀ {Cont : Type u_1} {Elem : Type u_2} {Dom : Cont → ℕ → Prop} {n : ℕ} [inst : GetElem Cont ℕ Elem Dom] (a : Cont)\n  (i : Fin n) [inst_1 : Decidable (Dom a ↑i)] [inst_2 : Inhabited Elem], a[i]! = a[↑i]!","name":"getElem!_fin","isProp":true,"depth":22}],"kind":"«term__[_]_!»","examples":[],"count":1}
{"noDocExamples":[],"kind":"«term_→ₗᵢ⋆[_]_»","examples":[{"type":"(𝕜 : Type u_1) →\n  (E : Type u_2) →\n    [inst : IsROrC 𝕜] →\n      [inst_1 : NormedAddCommGroup E] → [inst_2 : InnerProductSpace 𝕜 E] → E →ₗᵢ⋆[𝕜] NormedSpace.Dual 𝕜 E","name":"InnerProductSpace.toDualMap","isProp":false,"doc":"An element `x` of an inner product space `E` induces an element of the dual space `Dual 𝕜 E`,\nthe map `fun y => ⟪x, y⟫`; moreover this operation is a conjugate-linear isometric embedding of `E`\ninto `Dual 𝕜 E`.\nIf `E` is complete, this operation is surjective, hence a conjugate-linear isometric equivalence;\nsee `toDual`.\n","depth":30}],"count":1}
{"noDocExamples":[{"type":"∀ {δ : Type u_1} {δ' : Type u_2} {π : δ → Type u_3} [inst : (x : δ) → MeasurableSpace (π x)]\n  {μ : (i : δ) → MeasureTheory.Measure (π i)} [inst_1 : ∀ (i : δ), MeasureTheory.SigmaFinite (μ i)]\n  [inst_2 : DecidableEq δ] [inst_3 : DecidableEq δ'] {e : δ' → δ},\n  Function.Injective e →\n    ∀ (s : Finset δ') {f : ((i : δ') → π (e i)) → ENNReal},\n      Measurable f →\n        ∀ (x : (i : δ) → π i),\n          (∫⋯∫⁻_Finset.image e s, f ∘ fun x => (fun {x_1} => x) ∘' e ∂μ) x =\n            (∫⋯∫⁻_s, f ∂(fun {x} => μ) ∘' e) ((fun {x_1} => x) ∘' e)","name":"MeasureTheory.lmarginal_image","isProp":true,"depth":27}],"kind":"Function.«term_∘'_»","examples":[],"count":1}
